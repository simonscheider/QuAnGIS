# Generated from TransformationAlgebraTyped.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3 ")
        buf.write("\u00d9\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\3\2\3")
        buf.write("\2\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\6")
        buf.write("\3\6\3\6\3\6\3\7\3\7\3\7\5\7`\n\7\3\b\3\b\3\b\3\b\5\b")
        buf.write("f\n\b\3\t\3\t\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f")
        buf.write("\3\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\17\3\17\3\17")
        buf.write("\3\17\3\20\3\20\3\20\3\20\3\20\5\20\u0085\n\20\3\21\3")
        buf.write("\21\3\21\3\21\3\22\3\22\3\22\3\22\5\22\u008f\n\22\3\23")
        buf.write("\3\23\3\24\3\24\3\24\5\24\u0096\n\24\3\25\3\25\5\25\u009a")
        buf.write("\n\25\3\26\3\26\5\26\u009e\n\26\3\27\3\27\3\27\3\27\5")
        buf.write("\27\u00a4\n\27\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33")
        buf.write("\3\33\3\33\5\33\u00b0\n\33\3\34\3\34\3\35\3\35\3\35\5")
        buf.write("\35\u00b7\n\35\3\36\3\36\5\36\u00bb\n\36\3\37\3\37\5\37")
        buf.write("\u00bf\n\37\3 \3 \3 \3 \5 \u00c5\n \3!\3!\3\"\3\"\3#\3")
        buf.write("#\3$\3$\3$\3$\3$\3$\3%\3%\3%\3%\3%\3%\3%\2\2&\2\4\6\b")
        buf.write("\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668")
        buf.write(":<>@BDFH\2\2\2\u00d1\2J\3\2\2\2\4L\3\2\2\2\6P\3\2\2\2")
        buf.write("\bT\3\2\2\2\nX\3\2\2\2\f_\3\2\2\2\16e\3\2\2\2\20g\3\2")
        buf.write("\2\2\22i\3\2\2\2\24m\3\2\2\2\26q\3\2\2\2\30s\3\2\2\2\32")
        buf.write("w\3\2\2\2\34{\3\2\2\2\36\u0084\3\2\2\2 \u0086\3\2\2\2")
        buf.write("\"\u008e\3\2\2\2$\u0090\3\2\2\2&\u0095\3\2\2\2(\u0099")
        buf.write("\3\2\2\2*\u009d\3\2\2\2,\u00a3\3\2\2\2.\u00a5\3\2\2\2")
        buf.write("\60\u00a7\3\2\2\2\62\u00a9\3\2\2\2\64\u00af\3\2\2\2\66")
        buf.write("\u00b1\3\2\2\28\u00b6\3\2\2\2:\u00ba\3\2\2\2<\u00be\3")
        buf.write("\2\2\2>\u00c4\3\2\2\2@\u00c6\3\2\2\2B\u00c8\3\2\2\2D\u00ca")
        buf.write("\3\2\2\2F\u00cc\3\2\2\2H\u00d2\3\2\2\2JK\5\16\b\2K\3\3")
        buf.write("\2\2\2LM\7\34\2\2MN\7\36\2\2NO\5\36\20\2O\5\3\2\2\2PQ")
        buf.write("\5\4\3\2QR\7\36\2\2RS\5\36\20\2S\7\3\2\2\2TU\5\4\3\2U")
        buf.write("V\7\36\2\2VW\5\6\4\2W\t\3\2\2\2XY\5\4\3\2YZ\7\36\2\2Z")
        buf.write("[\5\b\5\2[\13\3\2\2\2\\`\5\6\4\2]`\5\b\5\2^`\5\n\6\2_")
        buf.write("\\\3\2\2\2_]\3\2\2\2_^\3\2\2\2`\r\3\2\2\2af\5\26\f\2b")
        buf.write("f\5\30\r\2cf\5\32\16\2df\5\34\17\2ea\3\2\2\2eb\3\2\2\2")
        buf.write("ec\3\2\2\2ed\3\2\2\2f\17\3\2\2\2gh\5\16\b\2h\21\3\2\2")
        buf.write("\2ij\5\16\b\2jk\7\36\2\2kl\5\20\t\2l\23\3\2\2\2mn\5\16")
        buf.write("\b\2no\7\36\2\2op\5\22\n\2p\25\3\2\2\2qr\5\36\20\2r\27")
        buf.write("\3\2\2\2st\5\6\4\2tu\7\36\2\2uv\5\20\t\2v\31\3\2\2\2w")
        buf.write("x\5\b\5\2xy\7\36\2\2yz\5\22\n\2z\33\3\2\2\2{|\5\n\6\2")
        buf.write("|}\7\36\2\2}~\5\24\13\2~\35\3\2\2\2\177\u0085\5\"\22\2")
        buf.write("\u0080\u0085\5\64\33\2\u0081\u0085\5F$\2\u0082\u0085\5")
        buf.write("H%\2\u0083\u0085\5 \21\2\u0084\177\3\2\2\2\u0084\u0080")
        buf.write("\3\2\2\2\u0084\u0081\3\2\2\2\u0084\u0082\3\2\2\2\u0084")
        buf.write("\u0083\3\2\2\2\u0085\37\3\2\2\2\u0086\u0087\7\3\2\2\u0087")
        buf.write("\u0088\5\f\7\2\u0088\u0089\7\4\2\2\u0089!\3\2\2\2\u008a")
        buf.write("\u008f\5&\24\2\u008b\u008f\7\27\2\2\u008c\u008f\7\30\2")
        buf.write("\2\u008d\u008f\7\31\2\2\u008e\u008a\3\2\2\2\u008e\u008b")
        buf.write("\3\2\2\2\u008e\u008c\3\2\2\2\u008e\u008d\3\2\2\2\u008f")
        buf.write("#\3\2\2\2\u0090\u0091\7\32\2\2\u0091%\3\2\2\2\u0092\u0096")
        buf.write("\7\20\2\2\u0093\u0096\5(\25\2\u0094\u0096\5$\23\2\u0095")
        buf.write("\u0092\3\2\2\2\u0095\u0093\3\2\2\2\u0095\u0094\3\2\2\2")
        buf.write("\u0096\'\3\2\2\2\u0097\u009a\7\21\2\2\u0098\u009a\5*\26")
        buf.write("\2\u0099\u0097\3\2\2\2\u0099\u0098\3\2\2\2\u009a)\3\2")
        buf.write("\2\2\u009b\u009e\7\22\2\2\u009c\u009e\5,\27\2\u009d\u009b")
        buf.write("\3\2\2\2\u009d\u009c\3\2\2\2\u009e+\3\2\2\2\u009f\u00a4")
        buf.write("\7\23\2\2\u00a0\u00a4\5.\30\2\u00a1\u00a4\5\60\31\2\u00a2")
        buf.write("\u00a4\5\62\32\2\u00a3\u009f\3\2\2\2\u00a3\u00a0\3\2\2")
        buf.write("\2\u00a3\u00a1\3\2\2\2\u00a3\u00a2\3\2\2\2\u00a4-\3\2")
        buf.write("\2\2\u00a5\u00a6\7\25\2\2\u00a6/\3\2\2\2\u00a7\u00a8\7")
        buf.write("\26\2\2\u00a8\61\3\2\2\2\u00a9\u00aa\7\24\2\2\u00aa\63")
        buf.write("\3\2\2\2\u00ab\u00b0\58\35\2\u00ac\u00b0\7\f\2\2\u00ad")
        buf.write("\u00b0\7\r\2\2\u00ae\u00b0\7\16\2\2\u00af\u00ab\3\2\2")
        buf.write("\2\u00af\u00ac\3\2\2\2\u00af\u00ad\3\2\2\2\u00af\u00ae")
        buf.write("\3\2\2\2\u00b0\65\3\2\2\2\u00b1\u00b2\7\17\2\2\u00b2\67")
        buf.write("\3\2\2\2\u00b3\u00b7\7\5\2\2\u00b4\u00b7\5:\36\2\u00b5")
        buf.write("\u00b7\5\66\34\2\u00b6\u00b3\3\2\2\2\u00b6\u00b4\3\2\2")
        buf.write("\2\u00b6\u00b5\3\2\2\2\u00b79\3\2\2\2\u00b8\u00bb\7\6")
        buf.write("\2\2\u00b9\u00bb\5<\37\2\u00ba\u00b8\3\2\2\2\u00ba\u00b9")
        buf.write("\3\2\2\2\u00bb;\3\2\2\2\u00bc\u00bf\7\7\2\2\u00bd\u00bf")
        buf.write("\5> \2\u00be\u00bc\3\2\2\2\u00be\u00bd\3\2\2\2\u00bf=")
        buf.write("\3\2\2\2\u00c0\u00c5\7\b\2\2\u00c1\u00c5\5@!\2\u00c2\u00c5")
        buf.write("\5B\"\2\u00c3\u00c5\5D#\2\u00c4\u00c0\3\2\2\2\u00c4\u00c1")
        buf.write("\3\2\2\2\u00c4\u00c2\3\2\2\2\u00c4\u00c3\3\2\2\2\u00c5")
        buf.write("?\3\2\2\2\u00c6\u00c7\7\n\2\2\u00c7A\3\2\2\2\u00c8\u00c9")
        buf.write("\7\13\2\2\u00c9C\3\2\2\2\u00ca\u00cb\7\t\2\2\u00cbE\3")
        buf.write("\2\2\2\u00cc\u00cd\7\33\2\2\u00cd\u00ce\7\36\2\2\u00ce")
        buf.write("\u00cf\5\64\33\2\u00cf\u00d0\7\36\2\2\u00d0\u00d1\5\64")
        buf.write("\33\2\u00d1G\3\2\2\2\u00d2\u00d3\7\33\2\2\u00d3\u00d4")
        buf.write("\7\36\2\2\u00d4\u00d5\5\64\33\2\u00d5\u00d6\7\36\2\2\u00d6")
        buf.write("\u00d7\5F$\2\u00d7I\3\2\2\2\17_e\u0084\u008e\u0095\u0099")
        buf.write("\u009d\u00a3\u00af\u00b6\u00ba\u00be\u00c4")
        return buf.getvalue()


class TransformationAlgebraTypedParser ( Parser ):

    grammarFileName = "TransformationAlgebraTyped.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "')'", "'Nom'", "'Ord'", "'Itv'", 
                     "'Ratio'", "'Count'", "'Ext'", "'Int'", "'O'", "'L'", 
                     "'S'", "'Bool'", "'NomV'", "'OrdV'", "'ItvV'", "'RatioV'", 
                     "'CountV'", "'ExtV'", "'IntV'", "'OV'", "'LV'", "'SV'", 
                     "'BoolV'", "'*'", "'-:'", "<INVALID>", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "NOM", "ORD", 
                      "ITV", "RAT", "COUNT", "E", "I", "O", "L", "S", "BOOL", 
                      "NOMV", "ORDV", "ITVV", "RATV", "COUNTV", "EV", "IV", 
                      "OV", "LV", "SV", "BOOLV", "REL", "IMPLIED", "DATAV", 
                      "WHITESPACE", "KEYWORD", "WS" ]

    RULE_start = 0
    RULE_fb = 1
    RULE_fc1 = 2
    RULE_fc2 = 3
    RULE_fc3 = 4
    RULE_fc = 5
    RULE_fa = 6
    RULE_a1 = 7
    RULE_a2 = 8
    RULE_a3 = 9
    RULE_fa0 = 10
    RULE_fa1 = 11
    RULE_fa2 = 12
    RULE_fa3 = 13
    RULE_c = 14
    RULE_bfc = 15
    RULE_v = 16
    RULE_boolv = 17
    RULE_nomv = 18
    RULE_ordv = 19
    RULE_itvv = 20
    RULE_ratv = 21
    RULE_ev = 22
    RULE_iv = 23
    RULE_countv = 24
    RULE_r = 25
    RULE_boolr = 26
    RULE_nom = 27
    RULE_ordr = 28
    RULE_itv = 29
    RULE_rat = 30
    RULE_e = 31
    RULE_i = 32
    RULE_count = 33
    RULE_rr = 34
    RULE_rrr = 35

    ruleNames =  [ "start", "fb", "fc1", "fc2", "fc3", "fc", "fa", "a1", 
                   "a2", "a3", "fa0", "fa1", "fa2", "fa3", "c", "bfc", "v", 
                   "boolv", "nomv", "ordv", "itvv", "ratv", "ev", "iv", 
                   "countv", "r", "boolr", "nom", "ordr", "itv", "rat", 
                   "e", "i", "count", "rr", "rrr" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    NOM=3
    ORD=4
    ITV=5
    RAT=6
    COUNT=7
    E=8
    I=9
    O=10
    L=11
    S=12
    BOOL=13
    NOMV=14
    ORDV=15
    ITVV=16
    RATV=17
    COUNTV=18
    EV=19
    IV=20
    OV=21
    LV=22
    SV=23
    BOOLV=24
    REL=25
    IMPLIED=26
    DATAV=27
    WHITESPACE=28
    KEYWORD=29
    WS=30

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraTypedParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.fa()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FbContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLIED(self):
            return self.getToken(TransformationAlgebraTypedParser.IMPLIED, 0)

        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def c(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFb" ):
                listener.enterFb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFb" ):
                listener.exitFb(self)




    def fb(self):

        localctx = TransformationAlgebraTypedParser.FbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_fb)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(TransformationAlgebraTypedParser.IMPLIED)
            self.state = 75
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 76
            self.c()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fc1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fb(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FbContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def c(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc1" ):
                listener.enterFc1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc1" ):
                listener.exitFc1(self)




    def fc1(self):

        localctx = TransformationAlgebraTypedParser.Fc1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_fc1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.fb()
            self.state = 79
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 80
            self.c()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fc2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fb(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FbContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def fc1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc1Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc2" ):
                listener.enterFc2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc2" ):
                listener.exitFc2(self)




    def fc2(self):

        localctx = TransformationAlgebraTypedParser.Fc2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fc2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.fb()
            self.state = 83
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 84
            self.fc1()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fc3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fb(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FbContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def fc2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc2Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc3" ):
                listener.enterFc3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc3" ):
                listener.exitFc3(self)




    def fc3(self):

        localctx = TransformationAlgebraTypedParser.Fc3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_fc3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.fb()
            self.state = 87
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 88
            self.fc2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc1Context,0)


        def fc2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc2Context,0)


        def fc3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc3Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc" ):
                listener.enterFc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc" ):
                listener.exitFc(self)




    def fc(self):

        localctx = TransformationAlgebraTypedParser.FcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fc)
        try:
            self.state = 93
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 90
                self.fc1()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 91
                self.fc2()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 92
                self.fc3()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa0(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa0Context,0)


        def fa1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa1Context,0)


        def fa2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa2Context,0)


        def fa3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa3Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa" ):
                listener.enterFa(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa" ):
                listener.exitFa(self)




    def fa(self):

        localctx = TransformationAlgebraTypedParser.FaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_fa)
        try:
            self.state = 99
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 95
                self.fa0()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 96
                self.fa1()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 97
                self.fa2()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 98
                self.fa3()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class A1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_a1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA1" ):
                listener.enterA1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA1" ):
                listener.exitA1(self)




    def a1(self):

        localctx = TransformationAlgebraTypedParser.A1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_a1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.fa()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class A2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A1Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_a2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA2" ):
                listener.enterA2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA2" ):
                listener.exitA2(self)




    def a2(self):

        localctx = TransformationAlgebraTypedParser.A2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_a2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.fa()
            self.state = 104
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 105
            self.a1()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class A3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A2Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_a3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA3" ):
                listener.enterA3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA3" ):
                listener.exitA3(self)




    def a3(self):

        localctx = TransformationAlgebraTypedParser.A3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_a3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.fa()
            self.state = 108
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 109
            self.a2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa0Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def c(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa0

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa0" ):
                listener.enterFa0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa0" ):
                listener.exitFa0(self)




    def fa0(self):

        localctx = TransformationAlgebraTypedParser.Fa0Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_fa0)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.c()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc1Context,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A1Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa1" ):
                listener.enterFa1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa1" ):
                listener.exitFa1(self)




    def fa1(self):

        localctx = TransformationAlgebraTypedParser.Fa1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_fa1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.fc1()
            self.state = 114
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 115
            self.a1()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc2Context,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A2Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa2" ):
                listener.enterFa2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa2" ):
                listener.exitFa2(self)




    def fa2(self):

        localctx = TransformationAlgebraTypedParser.Fa2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_fa2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.fc2()
            self.state = 118
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 119
            self.a2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc3Context,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A3Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa3" ):
                listener.enterFa3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa3" ):
                listener.exitFa3(self)




    def fa3(self):

        localctx = TransformationAlgebraTypedParser.Fa3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_fa3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.fc3()
            self.state = 122
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 123
            self.a3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.VContext,0)


        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RrContext,0)


        def rrr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RrrContext,0)


        def bfc(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.BfcContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_c

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC" ):
                listener.enterC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC" ):
                listener.exitC(self)




    def c(self):

        localctx = TransformationAlgebraTypedParser.CContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_c)
        try:
            self.state = 130
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                self.v()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 126
                self.r()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 127
                self.rr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 128
                self.rrr()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 129
                self.bfc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BfcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FcContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_bfc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBfc" ):
                listener.enterBfc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBfc" ):
                listener.exitBfc(self)




    def bfc(self):

        localctx = TransformationAlgebraTypedParser.BfcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_bfc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(TransformationAlgebraTypedParser.T__0)
            self.state = 133
            self.fc()
            self.state = 134
            self.match(TransformationAlgebraTypedParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.NomvContext,0)


        def OV(self):
            return self.getToken(TransformationAlgebraTypedParser.OV, 0)

        def LV(self):
            return self.getToken(TransformationAlgebraTypedParser.LV, 0)

        def SV(self):
            return self.getToken(TransformationAlgebraTypedParser.SV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_v

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterV" ):
                listener.enterV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitV" ):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraTypedParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_v)
        try:
            self.state = 140
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOMV, TransformationAlgebraTypedParser.ORDV, TransformationAlgebraTypedParser.ITVV, TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV, TransformationAlgebraTypedParser.BOOLV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.nomv()
                pass
            elif token in [TransformationAlgebraTypedParser.OV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 137
                self.match(TransformationAlgebraTypedParser.OV)
                pass
            elif token in [TransformationAlgebraTypedParser.LV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 138
                self.match(TransformationAlgebraTypedParser.LV)
                pass
            elif token in [TransformationAlgebraTypedParser.SV]:
                self.enterOuterAlt(localctx, 4)
                self.state = 139
                self.match(TransformationAlgebraTypedParser.SV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLV(self):
            return self.getToken(TransformationAlgebraTypedParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_boolv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolv" ):
                listener.enterBoolv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolv" ):
                listener.exitBoolv(self)




    def boolv(self):

        localctx = TransformationAlgebraTypedParser.BoolvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_boolv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(TransformationAlgebraTypedParser.BOOLV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOMV(self):
            return self.getToken(TransformationAlgebraTypedParser.NOMV, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.OrdvContext,0)


        def boolv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.BoolvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_nomv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNomv" ):
                listener.enterNomv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNomv" ):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraTypedParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_nomv)
        try:
            self.state = 147
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOMV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 144
                self.match(TransformationAlgebraTypedParser.NOMV)
                pass
            elif token in [TransformationAlgebraTypedParser.ORDV, TransformationAlgebraTypedParser.ITVV, TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 145
                self.ordv()
                pass
            elif token in [TransformationAlgebraTypedParser.BOOLV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 146
                self.boolv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDV(self):
            return self.getToken(TransformationAlgebraTypedParser.ORDV, 0)

        def itvv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.ItvvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ordv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdv" ):
                listener.enterOrdv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdv" ):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraTypedParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordv)
        try:
            self.state = 151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ORDV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 149
                self.match(TransformationAlgebraTypedParser.ORDV)
                pass
            elif token in [TransformationAlgebraTypedParser.ITVV, TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 150
                self.itvv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ItvvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITVV(self):
            return self.getToken(TransformationAlgebraTypedParser.ITVV, 0)

        def ratv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RatvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_itvv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterItvv" ):
                listener.enterItvv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitItvv" ):
                listener.exitItvv(self)




    def itvv(self):

        localctx = TransformationAlgebraTypedParser.ItvvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_itvv)
        try:
            self.state = 155
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ITVV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 153
                self.match(TransformationAlgebraTypedParser.ITVV)
                pass
            elif token in [TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 154
                self.ratv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RATV(self):
            return self.getToken(TransformationAlgebraTypedParser.RATV, 0)

        def ev(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.EvContext,0)


        def iv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.IvContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CountvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ratv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatv" ):
                listener.enterRatv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatv" ):
                listener.exitRatv(self)




    def ratv(self):

        localctx = TransformationAlgebraTypedParser.RatvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_ratv)
        try:
            self.state = 161
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.RATV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 157
                self.match(TransformationAlgebraTypedParser.RATV)
                pass
            elif token in [TransformationAlgebraTypedParser.EV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 158
                self.ev()
                pass
            elif token in [TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 159
                self.iv()
                pass
            elif token in [TransformationAlgebraTypedParser.COUNTV]:
                self.enterOuterAlt(localctx, 4)
                self.state = 160
                self.countv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EV(self):
            return self.getToken(TransformationAlgebraTypedParser.EV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ev

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEv" ):
                listener.enterEv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEv" ):
                listener.exitEv(self)




    def ev(self):

        localctx = TransformationAlgebraTypedParser.EvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_ev)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(TransformationAlgebraTypedParser.EV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IV(self):
            return self.getToken(TransformationAlgebraTypedParser.IV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_iv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIv" ):
                listener.enterIv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIv" ):
                listener.exitIv(self)




    def iv(self):

        localctx = TransformationAlgebraTypedParser.IvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_iv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(TransformationAlgebraTypedParser.IV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNTV(self):
            return self.getToken(TransformationAlgebraTypedParser.COUNTV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_countv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCountv" ):
                listener.enterCountv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCountv" ):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraTypedParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_countv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.match(TransformationAlgebraTypedParser.COUNTV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.NomContext,0)


        def O(self):
            return self.getToken(TransformationAlgebraTypedParser.O, 0)

        def L(self):
            return self.getToken(TransformationAlgebraTypedParser.L, 0)

        def S(self):
            return self.getToken(TransformationAlgebraTypedParser.S, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_r

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR" ):
                listener.enterR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR" ):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraTypedParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_r)
        try:
            self.state = 173
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOM, TransformationAlgebraTypedParser.ORD, TransformationAlgebraTypedParser.ITV, TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I, TransformationAlgebraTypedParser.BOOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 169
                self.nom()
                pass
            elif token in [TransformationAlgebraTypedParser.O]:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.match(TransformationAlgebraTypedParser.O)
                pass
            elif token in [TransformationAlgebraTypedParser.L]:
                self.enterOuterAlt(localctx, 3)
                self.state = 171
                self.match(TransformationAlgebraTypedParser.L)
                pass
            elif token in [TransformationAlgebraTypedParser.S]:
                self.enterOuterAlt(localctx, 4)
                self.state = 172
                self.match(TransformationAlgebraTypedParser.S)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL(self):
            return self.getToken(TransformationAlgebraTypedParser.BOOL, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_boolr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolr" ):
                listener.enterBoolr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolr" ):
                listener.exitBoolr(self)




    def boolr(self):

        localctx = TransformationAlgebraTypedParser.BoolrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_boolr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.match(TransformationAlgebraTypedParser.BOOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOM(self):
            return self.getToken(TransformationAlgebraTypedParser.NOM, 0)

        def ordr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.OrdrContext,0)


        def boolr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.BoolrContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_nom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNom" ):
                listener.enterNom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNom" ):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraTypedParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_nom)
        try:
            self.state = 180
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 177
                self.match(TransformationAlgebraTypedParser.NOM)
                pass
            elif token in [TransformationAlgebraTypedParser.ORD, TransformationAlgebraTypedParser.ITV, TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 2)
                self.state = 178
                self.ordr()
                pass
            elif token in [TransformationAlgebraTypedParser.BOOL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 179
                self.boolr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORD(self):
            return self.getToken(TransformationAlgebraTypedParser.ORD, 0)

        def itv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.ItvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ordr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdr" ):
                listener.enterOrdr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdr" ):
                listener.exitOrdr(self)




    def ordr(self):

        localctx = TransformationAlgebraTypedParser.OrdrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_ordr)
        try:
            self.state = 184
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ORD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 182
                self.match(TransformationAlgebraTypedParser.ORD)
                pass
            elif token in [TransformationAlgebraTypedParser.ITV, TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 2)
                self.state = 183
                self.itv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ItvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITV(self):
            return self.getToken(TransformationAlgebraTypedParser.ITV, 0)

        def rat(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RatContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_itv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterItv" ):
                listener.enterItv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitItv" ):
                listener.exitItv(self)




    def itv(self):

        localctx = TransformationAlgebraTypedParser.ItvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_itv)
        try:
            self.state = 188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ITV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                self.match(TransformationAlgebraTypedParser.ITV)
                pass
            elif token in [TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 2)
                self.state = 187
                self.rat()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAT(self):
            return self.getToken(TransformationAlgebraTypedParser.RAT, 0)

        def e(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.EContext,0)


        def i(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.IContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_rat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRat" ):
                listener.enterRat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRat" ):
                listener.exitRat(self)




    def rat(self):

        localctx = TransformationAlgebraTypedParser.RatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_rat)
        try:
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.RAT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 190
                self.match(TransformationAlgebraTypedParser.RAT)
                pass
            elif token in [TransformationAlgebraTypedParser.E]:
                self.enterOuterAlt(localctx, 2)
                self.state = 191
                self.e()
                pass
            elif token in [TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 3)
                self.state = 192
                self.i()
                pass
            elif token in [TransformationAlgebraTypedParser.COUNT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 193
                self.count()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def E(self):
            return self.getToken(TransformationAlgebraTypedParser.E, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_e

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterE" ):
                listener.enterE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitE" ):
                listener.exitE(self)




    def e(self):

        localctx = TransformationAlgebraTypedParser.EContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_e)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(TransformationAlgebraTypedParser.E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def I(self):
            return self.getToken(TransformationAlgebraTypedParser.I, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_i

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI" ):
                listener.enterI(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI" ):
                listener.exitI(self)




    def i(self):

        localctx = TransformationAlgebraTypedParser.IContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_i)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(TransformationAlgebraTypedParser.I)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(TransformationAlgebraTypedParser.COUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_count

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCount" ):
                listener.enterCount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCount" ):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraTypedParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(TransformationAlgebraTypedParser.COUNT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REL(self):
            return self.getToken(TransformationAlgebraTypedParser.REL, 0)

        def WHITESPACE(self, i:int=None):
            if i is None:
                return self.getTokens(TransformationAlgebraTypedParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, i)

        def r(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraTypedParser.RContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraTypedParser.RContext,i)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_rr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRr" ):
                listener.enterRr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRr" ):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraTypedParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(TransformationAlgebraTypedParser.REL)
            self.state = 203
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 204
            self.r()
            self.state = 205
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 206
            self.r()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REL(self):
            return self.getToken(TransformationAlgebraTypedParser.REL, 0)

        def WHITESPACE(self, i:int=None):
            if i is None:
                return self.getTokens(TransformationAlgebraTypedParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, i)

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RrContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_rrr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRrr" ):
                listener.enterRrr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRrr" ):
                listener.exitRrr(self)




    def rrr(self):

        localctx = TransformationAlgebraTypedParser.RrrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_rrr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(TransformationAlgebraTypedParser.REL)
            self.state = 209
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 210
            self.r()
            self.state = 211
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 212
            self.rr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





