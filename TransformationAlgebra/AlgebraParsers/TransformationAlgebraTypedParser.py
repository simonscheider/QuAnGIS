# Generated from TransformationAlgebraTyped.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\"")
        buf.write("\u00e4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\3\2\3\2\3\2\3\2\3\2\7\2R\n\2\f\2\16\2U\13\2\3\3\3\3")
        buf.write("\3\3\3\3\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3")
        buf.write("\6\3\7\3\7\3\7\5\7j\n\7\3\b\3\b\3\b\3\b\5\bp\n\b\3\t\3")
        buf.write("\t\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3\r\3\r")
        buf.write("\3\r\3\r\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\20")
        buf.write("\3\20\3\20\3\20\3\20\5\20\u008f\n\20\3\21\3\21\3\21\3")
        buf.write("\21\3\22\3\22\3\22\3\22\5\22\u0099\n\22\3\23\3\23\3\24")
        buf.write("\3\24\3\24\5\24\u00a0\n\24\3\25\3\25\5\25\u00a4\n\25\3")
        buf.write("\26\3\26\5\26\u00a8\n\26\3\27\3\27\3\27\3\27\5\27\u00ae")
        buf.write("\n\27\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\33\5\33")
        buf.write("\u00b9\n\33\3\34\3\34\3\35\3\35\3\36\3\36\3\36\5\36\u00c2")
        buf.write("\n\36\3\37\3\37\5\37\u00c6\n\37\3 \3 \5 \u00ca\n \3!\3")
        buf.write("!\3!\3!\5!\u00d0\n!\3\"\3\"\3#\3#\3$\3$\3%\3%\3%\3%\3")
        buf.write("%\3%\3&\3&\3&\3&\3&\3&\3&\2\2\'\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJ\2\3\4\2")
        buf.write("\f\16\21\21\2\u00dc\2L\3\2\2\2\4V\3\2\2\2\6Z\3\2\2\2\b")
        buf.write("^\3\2\2\2\nb\3\2\2\2\fi\3\2\2\2\16o\3\2\2\2\20q\3\2\2")
        buf.write("\2\22s\3\2\2\2\24w\3\2\2\2\26{\3\2\2\2\30}\3\2\2\2\32")
        buf.write("\u0081\3\2\2\2\34\u0085\3\2\2\2\36\u008e\3\2\2\2 \u0090")
        buf.write("\3\2\2\2\"\u0098\3\2\2\2$\u009a\3\2\2\2&\u009f\3\2\2\2")
        buf.write("(\u00a3\3\2\2\2*\u00a7\3\2\2\2,\u00ad\3\2\2\2.\u00af\3")
        buf.write("\2\2\2\60\u00b1\3\2\2\2\62\u00b3\3\2\2\2\64\u00b8\3\2")
        buf.write("\2\2\66\u00ba\3\2\2\28\u00bc\3\2\2\2:\u00c1\3\2\2\2<\u00c5")
        buf.write("\3\2\2\2>\u00c9\3\2\2\2@\u00cf\3\2\2\2B\u00d1\3\2\2\2")
        buf.write("D\u00d3\3\2\2\2F\u00d5\3\2\2\2H\u00d7\3\2\2\2J\u00dd\3")
        buf.write("\2\2\2LS\5\16\b\2MN\7 \2\2NR\5\16\b\2OP\7 \2\2PR\5\36")
        buf.write("\20\2QM\3\2\2\2QO\3\2\2\2RU\3\2\2\2SQ\3\2\2\2ST\3\2\2")
        buf.write("\2T\3\3\2\2\2US\3\2\2\2VW\7\36\2\2WX\7 \2\2XY\5\36\20")
        buf.write("\2Y\5\3\2\2\2Z[\5\4\3\2[\\\7 \2\2\\]\5\36\20\2]\7\3\2")
        buf.write("\2\2^_\5\4\3\2_`\7 \2\2`a\5\6\4\2a\t\3\2\2\2bc\5\4\3\2")
        buf.write("cd\7 \2\2de\5\b\5\2e\13\3\2\2\2fj\5\6\4\2gj\5\b\5\2hj")
        buf.write("\5\n\6\2if\3\2\2\2ig\3\2\2\2ih\3\2\2\2j\r\3\2\2\2kp\5")
        buf.write("\26\f\2lp\5\30\r\2mp\5\32\16\2np\5\34\17\2ok\3\2\2\2o")
        buf.write("l\3\2\2\2om\3\2\2\2on\3\2\2\2p\17\3\2\2\2qr\5\16\b\2r")
        buf.write("\21\3\2\2\2st\5\16\b\2tu\7 \2\2uv\5\20\t\2v\23\3\2\2\2")
        buf.write("wx\5\16\b\2xy\7 \2\2yz\5\22\n\2z\25\3\2\2\2{|\5\36\20")
        buf.write("\2|\27\3\2\2\2}~\5\6\4\2~\177\7 \2\2\177\u0080\5\20\t")
        buf.write("\2\u0080\31\3\2\2\2\u0081\u0082\5\b\5\2\u0082\u0083\7")
        buf.write(" \2\2\u0083\u0084\5\22\n\2\u0084\33\3\2\2\2\u0085\u0086")
        buf.write("\5\n\6\2\u0086\u0087\7 \2\2\u0087\u0088\5\24\13\2\u0088")
        buf.write("\35\3\2\2\2\u0089\u008f\5\"\22\2\u008a\u008f\5\64\33\2")
        buf.write("\u008b\u008f\5H%\2\u008c\u008f\5J&\2\u008d\u008f\5 \21")
        buf.write("\2\u008e\u0089\3\2\2\2\u008e\u008a\3\2\2\2\u008e\u008b")
        buf.write("\3\2\2\2\u008e\u008c\3\2\2\2\u008e\u008d\3\2\2\2\u008f")
        buf.write("\37\3\2\2\2\u0090\u0091\7\3\2\2\u0091\u0092\5\f\7\2\u0092")
        buf.write("\u0093\7\4\2\2\u0093!\3\2\2\2\u0094\u0099\5&\24\2\u0095")
        buf.write("\u0099\7\31\2\2\u0096\u0099\7\32\2\2\u0097\u0099\7\33")
        buf.write("\2\2\u0098\u0094\3\2\2\2\u0098\u0095\3\2\2\2\u0098\u0096")
        buf.write("\3\2\2\2\u0098\u0097\3\2\2\2\u0099#\3\2\2\2\u009a\u009b")
        buf.write("\7\34\2\2\u009b%\3\2\2\2\u009c\u00a0\7\22\2\2\u009d\u00a0")
        buf.write("\5(\25\2\u009e\u00a0\5$\23\2\u009f\u009c\3\2\2\2\u009f")
        buf.write("\u009d\3\2\2\2\u009f\u009e\3\2\2\2\u00a0\'\3\2\2\2\u00a1")
        buf.write("\u00a4\7\23\2\2\u00a2\u00a4\5*\26\2\u00a3\u00a1\3\2\2")
        buf.write("\2\u00a3\u00a2\3\2\2\2\u00a4)\3\2\2\2\u00a5\u00a8\7\24")
        buf.write("\2\2\u00a6\u00a8\5,\27\2\u00a7\u00a5\3\2\2\2\u00a7\u00a6")
        buf.write("\3\2\2\2\u00a8+\3\2\2\2\u00a9\u00ae\7\25\2\2\u00aa\u00ae")
        buf.write("\5.\30\2\u00ab\u00ae\5\60\31\2\u00ac\u00ae\5\62\32\2\u00ad")
        buf.write("\u00a9\3\2\2\2\u00ad\u00aa\3\2\2\2\u00ad\u00ab\3\2\2\2")
        buf.write("\u00ad\u00ac\3\2\2\2\u00ae-\3\2\2\2\u00af\u00b0\7\27\2")
        buf.write("\2\u00b0/\3\2\2\2\u00b1\u00b2\7\30\2\2\u00b2\61\3\2\2")
        buf.write("\2\u00b3\u00b4\7\26\2\2\u00b4\63\3\2\2\2\u00b5\u00b9\7")
        buf.write("\20\2\2\u00b6\u00b9\5:\36\2\u00b7\u00b9\5\66\34\2\u00b8")
        buf.write("\u00b5\3\2\2\2\u00b8\u00b6\3\2\2\2\u00b8\u00b7\3\2\2\2")
        buf.write("\u00b9\65\3\2\2\2\u00ba\u00bb\t\2\2\2\u00bb\67\3\2\2\2")
        buf.write("\u00bc\u00bd\7\17\2\2\u00bd9\3\2\2\2\u00be\u00c2\7\5\2")
        buf.write("\2\u00bf\u00c2\5<\37\2\u00c0\u00c2\58\35\2\u00c1\u00be")
        buf.write("\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c1\u00c0\3\2\2\2\u00c2")
        buf.write(";\3\2\2\2\u00c3\u00c6\7\6\2\2\u00c4\u00c6\5> \2\u00c5")
        buf.write("\u00c3\3\2\2\2\u00c5\u00c4\3\2\2\2\u00c6=\3\2\2\2\u00c7")
        buf.write("\u00ca\7\7\2\2\u00c8\u00ca\5@!\2\u00c9\u00c7\3\2\2\2\u00c9")
        buf.write("\u00c8\3\2\2\2\u00ca?\3\2\2\2\u00cb\u00d0\7\b\2\2\u00cc")
        buf.write("\u00d0\5B\"\2\u00cd\u00d0\5D#\2\u00ce\u00d0\5F$\2\u00cf")
        buf.write("\u00cb\3\2\2\2\u00cf\u00cc\3\2\2\2\u00cf\u00cd\3\2\2\2")
        buf.write("\u00cf\u00ce\3\2\2\2\u00d0A\3\2\2\2\u00d1\u00d2\7\n\2")
        buf.write("\2\u00d2C\3\2\2\2\u00d3\u00d4\7\13\2\2\u00d4E\3\2\2\2")
        buf.write("\u00d5\u00d6\7\t\2\2\u00d6G\3\2\2\2\u00d7\u00d8\7\35\2")
        buf.write("\2\u00d8\u00d9\7 \2\2\u00d9\u00da\5\64\33\2\u00da\u00db")
        buf.write("\7 \2\2\u00db\u00dc\5\64\33\2\u00dcI\3\2\2\2\u00dd\u00de")
        buf.write("\7\35\2\2\u00de\u00df\7 \2\2\u00df\u00e0\5\64\33\2\u00e0")
        buf.write("\u00e1\7 \2\2\u00e1\u00e2\5H%\2\u00e2K\3\2\2\2\21QSio")
        buf.write("\u008e\u0098\u009f\u00a3\u00a7\u00ad\u00b8\u00c1\u00c5")
        buf.write("\u00c9\u00cf")
        return buf.getvalue()


class TransformationAlgebraTypedParser ( Parser ):

    grammarFileName = "TransformationAlgebraTyped.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "')'", "'Nom'", "'Ord'", "'Itv'", 
                     "'Ratio'", "'Count'", "'Ext'", "'Int'", "'O'", "'L'", 
                     "'S'", "'Bool'", "'R'", "'NQ'", "'NomV'", "'OrdV'", 
                     "'ItvV'", "'RatioV'", "'CountV'", "'ExtV'", "'IntV'", 
                     "'OV'", "'LV'", "'SV'", "'BoolV'", "'*'", "'-:'", "<INVALID>", 
                     "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "NOM", "ORD", 
                      "ITV", "RAT", "COUNT", "E", "I", "O", "L", "S", "BOOL", 
                      "R", "NQ", "NOMV", "ORDV", "ITVV", "RATV", "COUNTV", 
                      "EV", "IV", "OV", "LV", "SV", "BOOLV", "REL", "IMPLIED", 
                      "DATAV", "WHITESPACE", "KEYWORD", "WS" ]

    RULE_start = 0
    RULE_fb = 1
    RULE_fc1 = 2
    RULE_fc2 = 3
    RULE_fc3 = 4
    RULE_fc = 5
    RULE_fa = 6
    RULE_a1 = 7
    RULE_a2 = 8
    RULE_a3 = 9
    RULE_fa0 = 10
    RULE_fa1 = 11
    RULE_fa2 = 12
    RULE_fa3 = 13
    RULE_c = 14
    RULE_bfc = 15
    RULE_v = 16
    RULE_boolv = 17
    RULE_nomv = 18
    RULE_ordv = 19
    RULE_itvv = 20
    RULE_ratv = 21
    RULE_ev = 22
    RULE_iv = 23
    RULE_countv = 24
    RULE_r = 25
    RULE_nq = 26
    RULE_boolr = 27
    RULE_nom = 28
    RULE_ordr = 29
    RULE_itv = 30
    RULE_rat = 31
    RULE_e = 32
    RULE_i = 33
    RULE_count = 34
    RULE_rr = 35
    RULE_rrr = 36

    ruleNames =  [ "start", "fb", "fc1", "fc2", "fc3", "fc", "fa", "a1", 
                   "a2", "a3", "fa0", "fa1", "fa2", "fa3", "c", "bfc", "v", 
                   "boolv", "nomv", "ordv", "itvv", "ratv", "ev", "iv", 
                   "countv", "r", "nq", "boolr", "nom", "ordr", "itv", "rat", 
                   "e", "i", "count", "rr", "rrr" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    NOM=3
    ORD=4
    ITV=5
    RAT=6
    COUNT=7
    E=8
    I=9
    O=10
    L=11
    S=12
    BOOL=13
    R=14
    NQ=15
    NOMV=16
    ORDV=17
    ITVV=18
    RATV=19
    COUNTV=20
    EV=21
    IV=22
    OV=23
    LV=24
    SV=25
    BOOLV=26
    REL=27
    IMPLIED=28
    DATAV=29
    WHITESPACE=30
    KEYWORD=31
    WS=32

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraTypedParser.FaContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,i)


        def WHITESPACE(self, i:int=None):
            if i is None:
                return self.getTokens(TransformationAlgebraTypedParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, i)

        def c(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraTypedParser.CContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,i)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraTypedParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.fa()
            self.state = 81
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==TransformationAlgebraTypedParser.WHITESPACE:
                self.state = 79
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 75
                    self.match(TransformationAlgebraTypedParser.WHITESPACE)
                    self.state = 76
                    self.fa()
                    pass

                elif la_ == 2:
                    self.state = 77
                    self.match(TransformationAlgebraTypedParser.WHITESPACE)
                    self.state = 78
                    self.c()
                    pass


                self.state = 83
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FbContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPLIED(self):
            return self.getToken(TransformationAlgebraTypedParser.IMPLIED, 0)

        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def c(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFb" ):
                listener.enterFb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFb" ):
                listener.exitFb(self)




    def fb(self):

        localctx = TransformationAlgebraTypedParser.FbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_fb)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(TransformationAlgebraTypedParser.IMPLIED)
            self.state = 85
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 86
            self.c()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fc1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fb(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FbContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def c(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc1" ):
                listener.enterFc1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc1" ):
                listener.exitFc1(self)




    def fc1(self):

        localctx = TransformationAlgebraTypedParser.Fc1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_fc1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.fb()
            self.state = 89
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 90
            self.c()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fc2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fb(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FbContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def fc1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc1Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc2" ):
                listener.enterFc2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc2" ):
                listener.exitFc2(self)




    def fc2(self):

        localctx = TransformationAlgebraTypedParser.Fc2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_fc2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.fb()
            self.state = 93
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 94
            self.fc1()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fc3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fb(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FbContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def fc2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc2Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc3" ):
                listener.enterFc3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc3" ):
                listener.exitFc3(self)




    def fc3(self):

        localctx = TransformationAlgebraTypedParser.Fc3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_fc3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.fb()
            self.state = 97
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 98
            self.fc2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc1Context,0)


        def fc2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc2Context,0)


        def fc3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc3Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFc" ):
                listener.enterFc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFc" ):
                listener.exitFc(self)




    def fc(self):

        localctx = TransformationAlgebraTypedParser.FcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fc)
        try:
            self.state = 103
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 100
                self.fc1()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.fc2()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 102
                self.fc3()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa0(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa0Context,0)


        def fa1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa1Context,0)


        def fa2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa2Context,0)


        def fa3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fa3Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa" ):
                listener.enterFa(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa" ):
                listener.exitFa(self)




    def fa(self):

        localctx = TransformationAlgebraTypedParser.FaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_fa)
        try:
            self.state = 109
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 105
                self.fa0()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.fa1()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 107
                self.fa2()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 108
                self.fa3()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class A1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_a1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA1" ):
                listener.enterA1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA1" ):
                listener.exitA1(self)




    def a1(self):

        localctx = TransformationAlgebraTypedParser.A1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_a1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.fa()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class A2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A1Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_a2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA2" ):
                listener.enterA2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA2" ):
                listener.exitA2(self)




    def a2(self):

        localctx = TransformationAlgebraTypedParser.A2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_a2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self.fa()
            self.state = 114
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 115
            self.a1()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class A3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fa(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FaContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A2Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_a3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA3" ):
                listener.enterA3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA3" ):
                listener.exitA3(self)




    def a3(self):

        localctx = TransformationAlgebraTypedParser.A3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_a3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.fa()
            self.state = 118
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 119
            self.a2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa0Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def c(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa0

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa0" ):
                listener.enterFa0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa0" ):
                listener.exitFa0(self)




    def fa0(self):

        localctx = TransformationAlgebraTypedParser.Fa0Context(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_fa0)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.c()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc1Context,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a1(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A1Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa1" ):
                listener.enterFa1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa1" ):
                listener.exitFa1(self)




    def fa1(self):

        localctx = TransformationAlgebraTypedParser.Fa1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_fa1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.fc1()
            self.state = 124
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 125
            self.a1()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc2Context,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a2(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A2Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa2" ):
                listener.enterFa2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa2" ):
                listener.exitFa2(self)




    def fa2(self):

        localctx = TransformationAlgebraTypedParser.Fa2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_fa2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.fc2()
            self.state = 128
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 129
            self.a2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fa3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.Fc3Context,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, 0)

        def a3(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.A3Context,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_fa3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFa3" ):
                listener.enterFa3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFa3" ):
                listener.exitFa3(self)




    def fa3(self):

        localctx = TransformationAlgebraTypedParser.Fa3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_fa3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.fc3()
            self.state = 132
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 133
            self.a3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.VContext,0)


        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RrContext,0)


        def rrr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RrrContext,0)


        def bfc(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.BfcContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_c

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterC" ):
                listener.enterC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitC" ):
                listener.exitC(self)




    def c(self):

        localctx = TransformationAlgebraTypedParser.CContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_c)
        try:
            self.state = 140
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 135
                self.v()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 136
                self.r()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 137
                self.rr()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 138
                self.rrr()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 139
                self.bfc()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BfcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fc(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.FcContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_bfc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBfc" ):
                listener.enterBfc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBfc" ):
                listener.exitBfc(self)




    def bfc(self):

        localctx = TransformationAlgebraTypedParser.BfcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_bfc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(TransformationAlgebraTypedParser.T__0)
            self.state = 143
            self.fc()
            self.state = 144
            self.match(TransformationAlgebraTypedParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.NomvContext,0)


        def OV(self):
            return self.getToken(TransformationAlgebraTypedParser.OV, 0)

        def LV(self):
            return self.getToken(TransformationAlgebraTypedParser.LV, 0)

        def SV(self):
            return self.getToken(TransformationAlgebraTypedParser.SV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_v

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterV" ):
                listener.enterV(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitV" ):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraTypedParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_v)
        try:
            self.state = 150
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOMV, TransformationAlgebraTypedParser.ORDV, TransformationAlgebraTypedParser.ITVV, TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV, TransformationAlgebraTypedParser.BOOLV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 146
                self.nomv()
                pass
            elif token in [TransformationAlgebraTypedParser.OV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 147
                self.match(TransformationAlgebraTypedParser.OV)
                pass
            elif token in [TransformationAlgebraTypedParser.LV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 148
                self.match(TransformationAlgebraTypedParser.LV)
                pass
            elif token in [TransformationAlgebraTypedParser.SV]:
                self.enterOuterAlt(localctx, 4)
                self.state = 149
                self.match(TransformationAlgebraTypedParser.SV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLV(self):
            return self.getToken(TransformationAlgebraTypedParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_boolv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolv" ):
                listener.enterBoolv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolv" ):
                listener.exitBoolv(self)




    def boolv(self):

        localctx = TransformationAlgebraTypedParser.BoolvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_boolv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(TransformationAlgebraTypedParser.BOOLV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOMV(self):
            return self.getToken(TransformationAlgebraTypedParser.NOMV, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.OrdvContext,0)


        def boolv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.BoolvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_nomv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNomv" ):
                listener.enterNomv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNomv" ):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraTypedParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_nomv)
        try:
            self.state = 157
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOMV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 154
                self.match(TransformationAlgebraTypedParser.NOMV)
                pass
            elif token in [TransformationAlgebraTypedParser.ORDV, TransformationAlgebraTypedParser.ITVV, TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 155
                self.ordv()
                pass
            elif token in [TransformationAlgebraTypedParser.BOOLV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 156
                self.boolv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDV(self):
            return self.getToken(TransformationAlgebraTypedParser.ORDV, 0)

        def itvv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.ItvvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ordv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdv" ):
                listener.enterOrdv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdv" ):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraTypedParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordv)
        try:
            self.state = 161
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ORDV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 159
                self.match(TransformationAlgebraTypedParser.ORDV)
                pass
            elif token in [TransformationAlgebraTypedParser.ITVV, TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 160
                self.itvv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ItvvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITVV(self):
            return self.getToken(TransformationAlgebraTypedParser.ITVV, 0)

        def ratv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RatvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_itvv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterItvv" ):
                listener.enterItvv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitItvv" ):
                listener.exitItvv(self)




    def itvv(self):

        localctx = TransformationAlgebraTypedParser.ItvvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_itvv)
        try:
            self.state = 165
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ITVV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 163
                self.match(TransformationAlgebraTypedParser.ITVV)
                pass
            elif token in [TransformationAlgebraTypedParser.RATV, TransformationAlgebraTypedParser.COUNTV, TransformationAlgebraTypedParser.EV, TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 164
                self.ratv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RATV(self):
            return self.getToken(TransformationAlgebraTypedParser.RATV, 0)

        def ev(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.EvContext,0)


        def iv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.IvContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CountvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ratv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatv" ):
                listener.enterRatv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatv" ):
                listener.exitRatv(self)




    def ratv(self):

        localctx = TransformationAlgebraTypedParser.RatvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_ratv)
        try:
            self.state = 171
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.RATV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.match(TransformationAlgebraTypedParser.RATV)
                pass
            elif token in [TransformationAlgebraTypedParser.EV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 168
                self.ev()
                pass
            elif token in [TransformationAlgebraTypedParser.IV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 169
                self.iv()
                pass
            elif token in [TransformationAlgebraTypedParser.COUNTV]:
                self.enterOuterAlt(localctx, 4)
                self.state = 170
                self.countv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EV(self):
            return self.getToken(TransformationAlgebraTypedParser.EV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ev

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEv" ):
                listener.enterEv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEv" ):
                listener.exitEv(self)




    def ev(self):

        localctx = TransformationAlgebraTypedParser.EvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_ev)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(TransformationAlgebraTypedParser.EV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IV(self):
            return self.getToken(TransformationAlgebraTypedParser.IV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_iv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIv" ):
                listener.enterIv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIv" ):
                listener.exitIv(self)




    def iv(self):

        localctx = TransformationAlgebraTypedParser.IvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_iv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.match(TransformationAlgebraTypedParser.IV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNTV(self):
            return self.getToken(TransformationAlgebraTypedParser.COUNTV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_countv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCountv" ):
                listener.enterCountv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCountv" ):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraTypedParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_countv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(TransformationAlgebraTypedParser.COUNTV)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def R(self):
            return self.getToken(TransformationAlgebraTypedParser.R, 0)

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.NomContext,0)


        def nq(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.NqContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_r

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterR" ):
                listener.enterR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitR" ):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraTypedParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_r)
        try:
            self.state = 182
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.R]:
                self.enterOuterAlt(localctx, 1)
                self.state = 179
                self.match(TransformationAlgebraTypedParser.R)
                pass
            elif token in [TransformationAlgebraTypedParser.NOM, TransformationAlgebraTypedParser.ORD, TransformationAlgebraTypedParser.ITV, TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I, TransformationAlgebraTypedParser.BOOL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 180
                self.nom()
                pass
            elif token in [TransformationAlgebraTypedParser.O, TransformationAlgebraTypedParser.L, TransformationAlgebraTypedParser.S, TransformationAlgebraTypedParser.NQ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 181
                self.nq()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NQ(self):
            return self.getToken(TransformationAlgebraTypedParser.NQ, 0)

        def O(self):
            return self.getToken(TransformationAlgebraTypedParser.O, 0)

        def L(self):
            return self.getToken(TransformationAlgebraTypedParser.L, 0)

        def S(self):
            return self.getToken(TransformationAlgebraTypedParser.S, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_nq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNq" ):
                listener.enterNq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNq" ):
                listener.exitNq(self)




    def nq(self):

        localctx = TransformationAlgebraTypedParser.NqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_nq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TransformationAlgebraTypedParser.O) | (1 << TransformationAlgebraTypedParser.L) | (1 << TransformationAlgebraTypedParser.S) | (1 << TransformationAlgebraTypedParser.NQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL(self):
            return self.getToken(TransformationAlgebraTypedParser.BOOL, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_boolr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolr" ):
                listener.enterBoolr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolr" ):
                listener.exitBoolr(self)




    def boolr(self):

        localctx = TransformationAlgebraTypedParser.BoolrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_boolr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(TransformationAlgebraTypedParser.BOOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOM(self):
            return self.getToken(TransformationAlgebraTypedParser.NOM, 0)

        def ordr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.OrdrContext,0)


        def boolr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.BoolrContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_nom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNom" ):
                listener.enterNom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNom" ):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraTypedParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_nom)
        try:
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.NOM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 188
                self.match(TransformationAlgebraTypedParser.NOM)
                pass
            elif token in [TransformationAlgebraTypedParser.ORD, TransformationAlgebraTypedParser.ITV, TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 2)
                self.state = 189
                self.ordr()
                pass
            elif token in [TransformationAlgebraTypedParser.BOOL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 190
                self.boolr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORD(self):
            return self.getToken(TransformationAlgebraTypedParser.ORD, 0)

        def itv(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.ItvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_ordr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrdr" ):
                listener.enterOrdr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrdr" ):
                listener.exitOrdr(self)




    def ordr(self):

        localctx = TransformationAlgebraTypedParser.OrdrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_ordr)
        try:
            self.state = 195
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ORD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 193
                self.match(TransformationAlgebraTypedParser.ORD)
                pass
            elif token in [TransformationAlgebraTypedParser.ITV, TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 2)
                self.state = 194
                self.itv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ItvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITV(self):
            return self.getToken(TransformationAlgebraTypedParser.ITV, 0)

        def rat(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RatContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_itv

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterItv" ):
                listener.enterItv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitItv" ):
                listener.exitItv(self)




    def itv(self):

        localctx = TransformationAlgebraTypedParser.ItvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_itv)
        try:
            self.state = 199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.ITV]:
                self.enterOuterAlt(localctx, 1)
                self.state = 197
                self.match(TransformationAlgebraTypedParser.ITV)
                pass
            elif token in [TransformationAlgebraTypedParser.RAT, TransformationAlgebraTypedParser.COUNT, TransformationAlgebraTypedParser.E, TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 2)
                self.state = 198
                self.rat()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAT(self):
            return self.getToken(TransformationAlgebraTypedParser.RAT, 0)

        def e(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.EContext,0)


        def i(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.IContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_rat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRat" ):
                listener.enterRat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRat" ):
                listener.exitRat(self)




    def rat(self):

        localctx = TransformationAlgebraTypedParser.RatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_rat)
        try:
            self.state = 205
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraTypedParser.RAT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 201
                self.match(TransformationAlgebraTypedParser.RAT)
                pass
            elif token in [TransformationAlgebraTypedParser.E]:
                self.enterOuterAlt(localctx, 2)
                self.state = 202
                self.e()
                pass
            elif token in [TransformationAlgebraTypedParser.I]:
                self.enterOuterAlt(localctx, 3)
                self.state = 203
                self.i()
                pass
            elif token in [TransformationAlgebraTypedParser.COUNT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 204
                self.count()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def E(self):
            return self.getToken(TransformationAlgebraTypedParser.E, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_e

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterE" ):
                listener.enterE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitE" ):
                listener.exitE(self)




    def e(self):

        localctx = TransformationAlgebraTypedParser.EContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_e)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self.match(TransformationAlgebraTypedParser.E)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def I(self):
            return self.getToken(TransformationAlgebraTypedParser.I, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_i

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI" ):
                listener.enterI(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI" ):
                listener.exitI(self)




    def i(self):

        localctx = TransformationAlgebraTypedParser.IContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_i)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(TransformationAlgebraTypedParser.I)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(TransformationAlgebraTypedParser.COUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_count

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCount" ):
                listener.enterCount(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCount" ):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraTypedParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(TransformationAlgebraTypedParser.COUNT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REL(self):
            return self.getToken(TransformationAlgebraTypedParser.REL, 0)

        def WHITESPACE(self, i:int=None):
            if i is None:
                return self.getTokens(TransformationAlgebraTypedParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, i)

        def r(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraTypedParser.RContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraTypedParser.RContext,i)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_rr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRr" ):
                listener.enterRr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRr" ):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraTypedParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(TransformationAlgebraTypedParser.REL)
            self.state = 214
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 215
            self.r()
            self.state = 216
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 217
            self.r()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REL(self):
            return self.getToken(TransformationAlgebraTypedParser.REL, 0)

        def WHITESPACE(self, i:int=None):
            if i is None:
                return self.getTokens(TransformationAlgebraTypedParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraTypedParser.WHITESPACE, i)

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraTypedParser.RrContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraTypedParser.RULE_rrr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRrr" ):
                listener.enterRrr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRrr" ):
                listener.exitRrr(self)




    def rrr(self):

        localctx = TransformationAlgebraTypedParser.RrrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_rrr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.match(TransformationAlgebraTypedParser.REL)
            self.state = 220
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 221
            self.r()
            self.state = 222
            self.match(TransformationAlgebraTypedParser.WHITESPACE)
            self.state = 223
            self.rr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





