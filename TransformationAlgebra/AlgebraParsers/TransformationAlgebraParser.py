# Generated from TransformationAlgebra.g4 by ANTLR 4.8
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"\62\u0256\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7")
        buf.write(u"\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t")
        buf.write(u"\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22")
        buf.write(u"\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4")
        buf.write(u"\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35")
        buf.write(u"\t\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4")
        buf.write(u"$\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t")
        buf.write(u",\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63")
        buf.write(u"\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\4")
        buf.write(u"9\t9\3\2\3\2\3\2\5\2v\n\2\3\3\3\3\3\3\3\3\5\3|\n\3\3")
        buf.write(u"\4\3\4\3\4\3\4\3\4\5\4\u0083\n\4\3\5\3\5\3\5\3\5\5\5")
        buf.write(u"\u0089\n\5\3\6\3\6\3\6\3\6\3\6\5\6\u0090\n\6\3\7\3\7")
        buf.write(u"\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write(u"\5\7\u00a1\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00ab")
        buf.write(u"\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t")
        buf.write(u"\u00b8\n\t\3\n\3\n\3\n\3\n\5\n\u00be\n\n\3\13\3\13\3")
        buf.write(u"\13\5\13\u00c3\n\13\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u00cb")
        buf.write(u"\n\f\3\r\3\r\3\r\3\16\3\16\3\16\5\16\u00d3\n\16\3\17")
        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\5\17\u00e5\n\17\3\20\3\20\3\20")
        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u00f1\n\20\3")
        buf.write(u"\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write(u"\3\21\3\21\3\21\3\21\3\21\5\21\u0103\n\21\3\22\3\22\3")
        buf.write(u"\22\3\23\3\23\3\23\3\23\3\23\5\23\u010d\n\23\3\24\3\24")
        buf.write(u"\3\24\3\24\3\24\3\24\3\24\5\24\u0116\n\24\3\25\3\25\3")
        buf.write(u"\25\5\25\u011b\n\25\3\26\3\26\3\26\5\26\u0120\n\26\3")
        buf.write(u"\27\3\27\3\27\5\27\u0125\n\27\3\30\3\30\3\31\3\31\5\31")
        buf.write(u"\u012b\n\31\3\32\3\32\3\33\3\33\3\34\3\34\3\34\5\34\u0134")
        buf.write(u"\n\34\3\35\3\35\3\36\3\36\3\37\3\37\3 \3 \3 \3 \3 \3")
        buf.write(u" \3 \3 \3 \3 \3 \5 \u0147\n \3!\3!\3!\3!\3!\3!\3!\3!")
        buf.write(u"\3!\3!\3!\3!\3!\5!\u0156\n!\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write(u"\"\3\"\3\"\3\"\3\"\5\"\u0163\n\"\3#\3#\3#\3#\3#\3#\3")
        buf.write(u"#\3#\3#\3#\3#\3#\3#\3#\3#\5#\u0174\n#\3$\3$\3$\3$\3$")
        buf.write(u"\3$\3$\3$\3$\3$\3$\3$\3$\3$\5$\u0184\n$\3%\3%\3&\3&\3")
        buf.write(u"&\3&\3&\3&\3&\3&\3&\3&\3&\5&\u0193\n&\3\'\3\'\3(\3(\3")
        buf.write(u"(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u01a9")
        buf.write(u"\n(\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\5")
        buf.write(u")\u01bb\n)\3*\3*\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\5+")
        buf.write(u"\u01ca\n+\3,\3,\3,\3,\3,\3-\3-\3-\3-\3-\3-\3-\3-\3-\3")
        buf.write(u"-\3-\3-\3-\3-\3-\3-\3-\5-\u01e2\n-\3.\3.\3.\3.\3.\3.")
        buf.write(u"\5.\u01ea\n.\3/\3/\3/\3/\3/\3/\5/\u01f2\n/\3\60\3\60")
        buf.write(u"\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u01ff")
        buf.write(u"\n\60\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3")
        buf.write(u"\61\5\61\u020b\n\61\3\62\3\62\3\62\3\62\3\62\3\62\5\62")
        buf.write(u"\u0213\n\62\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3")
        buf.write(u"\63\3\63\5\63\u021f\n\63\3\64\3\64\3\64\3\64\3\64\3\64")
        buf.write(u"\3\64\3\64\3\64\3\64\5\64\u022b\n\64\3\65\3\65\3\65\3")
        buf.write(u"\65\3\65\3\65\5\65\u0233\n\65\3\66\3\66\3\66\3\66\3\66")
        buf.write(u"\3\66\5\66\u023b\n\66\3\67\3\67\3\67\3\67\3\67\3\67\3")
        buf.write(u"\67\5\67\u0244\n\67\38\38\38\38\38\38\38\38\38\38\38")
        buf.write(u"\38\58\u0252\n8\39\39\39\2\2:\2\4\6\b\n\f\16\20\22\24")
        buf.write(u"\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTV")
        buf.write(u"XZ\\^`bdfhjlnp\2\3\3\2\33\34\2\u0287\2u\3\2\2\2\4{\3")
        buf.write(u"\2\2\2\6\u0082\3\2\2\2\b\u0088\3\2\2\2\n\u008f\3\2\2")
        buf.write(u"\2\f\u00a0\3\2\2\2\16\u00aa\3\2\2\2\20\u00b7\3\2\2\2")
        buf.write(u"\22\u00bd\3\2\2\2\24\u00c2\3\2\2\2\26\u00ca\3\2\2\2\30")
        buf.write(u"\u00cc\3\2\2\2\32\u00d2\3\2\2\2\34\u00e4\3\2\2\2\36\u00f0")
        buf.write(u"\3\2\2\2 \u0102\3\2\2\2\"\u0104\3\2\2\2$\u010c\3\2\2")
        buf.write(u"\2&\u0115\3\2\2\2(\u011a\3\2\2\2*\u011f\3\2\2\2,\u0124")
        buf.write(u"\3\2\2\2.\u0126\3\2\2\2\60\u012a\3\2\2\2\62\u012c\3\2")
        buf.write(u"\2\2\64\u012e\3\2\2\2\66\u0133\3\2\2\28\u0135\3\2\2\2")
        buf.write(u":\u0137\3\2\2\2<\u0139\3\2\2\2>\u0146\3\2\2\2@\u0155")
        buf.write(u"\3\2\2\2B\u0162\3\2\2\2D\u0173\3\2\2\2F\u0183\3\2\2\2")
        buf.write(u"H\u0185\3\2\2\2J\u0192\3\2\2\2L\u0194\3\2\2\2N\u01a8")
        buf.write(u"\3\2\2\2P\u01ba\3\2\2\2R\u01bc\3\2\2\2T\u01c9\3\2\2\2")
        buf.write(u"V\u01cb\3\2\2\2X\u01e1\3\2\2\2Z\u01e9\3\2\2\2\\\u01f1")
        buf.write(u"\3\2\2\2^\u01fe\3\2\2\2`\u020a\3\2\2\2b\u0212\3\2\2\2")
        buf.write(u"d\u021e\3\2\2\2f\u022a\3\2\2\2h\u0232\3\2\2\2j\u023a")
        buf.write(u"\3\2\2\2l\u0243\3\2\2\2n\u0251\3\2\2\2p\u0253\3\2\2\2")
        buf.write(u"rv\5\4\3\2sv\5\6\4\2tv\5\b\5\2ur\3\2\2\2us\3\2\2\2ut")
        buf.write(u"\3\2\2\2v\3\3\2\2\2w|\5\34\17\2x|\5\36\20\2y|\5,\27\2")
        buf.write(u"z|\5 \21\2{w\3\2\2\2{x\3\2\2\2{y\3\2\2\2{z\3\2\2\2|\5")
        buf.write(u"\3\2\2\2}\u0083\5T+\2~\u0083\5\64\33\2\177\u0083\5<\37")
        buf.write(u"\2\u0080\u0083\5J&\2\u0081\u0083\5> \2\u0082}\3\2\2\2")
        buf.write(u"\u0082~\3\2\2\2\u0082\177\3\2\2\2\u0082\u0080\3\2\2\2")
        buf.write(u"\u0082\u0081\3\2\2\2\u0083\7\3\2\2\2\u0084\u0089\5\32")
        buf.write(u"\16\2\u0085\u0089\5\30\r\2\u0086\u0089\5\26\f\2\u0087")
        buf.write(u"\u0089\5\24\13\2\u0088\u0084\3\2\2\2\u0088\u0085\3\2")
        buf.write(u"\2\2\u0088\u0086\3\2\2\2\u0088\u0087\3\2\2\2\u0089\t")
        buf.write(u"\3\2\2\2\u008a\u008b\7\7\2\2\u008b\u0090\5 \21\2\u008c")
        buf.write(u"\u008d\7\n\2\2\u008d\u0090\5\"\22\2\u008e\u0090\7/\2")
        buf.write(u"\2\u008f\u008a\3\2\2\2\u008f\u008c\3\2\2\2\u008f\u008e")
        buf.write(u"\3\2\2\2\u0090\13\3\2\2\2\u0091\u0092\7\16\2\2\u0092")
        buf.write(u"\u00a1\5N(\2\u0093\u0094\7\20\2\2\u0094\u00a1\5\34\17")
        buf.write(u"\2\u0095\u0096\7\21\2\2\u0096\u0097\5\f\7\2\u0097\u0098")
        buf.write(u"\7\60\2\2\u0098\u0099\5\f\7\2\u0099\u00a1\3\2\2\2\u009a")
        buf.write(u"\u009b\7\17\2\2\u009b\u00a1\5B\"\2\u009c\u009d\7\n\2")
        buf.write(u"\2\u009d\u00a1\5$\23\2\u009e\u00a1\5\n\6\2\u009f\u00a1")
        buf.write(u"\7/\2\2\u00a0\u0091\3\2\2\2\u00a0\u0093\3\2\2\2\u00a0")
        buf.write(u"\u0095\3\2\2\2\u00a0\u009a\3\2\2\2\u00a0\u009c\3\2\2")
        buf.write(u"\2\u00a0\u009e\3\2\2\2\u00a0\u009f\3\2\2\2\u00a1\r\3")
        buf.write(u"\2\2\2\u00a2\u00a3\7\3\2\2\u00a3\u00ab\5N(\2\u00a4\u00a5")
        buf.write(u"\7\3\2\2\u00a5\u00ab\5D#\2\u00a6\u00ab\5\f\7\2\u00a7")
        buf.write(u"\u00a8\7\n\2\2\u00a8\u00ab\5&\24\2\u00a9\u00ab\7/\2\2")
        buf.write(u"\u00aa\u00a2\3\2\2\2\u00aa\u00a4\3\2\2\2\u00aa\u00a6")
        buf.write(u"\3\2\2\2\u00aa\u00a7\3\2\2\2\u00aa\u00a9\3\2\2\2\u00ab")
        buf.write(u"\17\3\2\2\2\u00ac\u00ad\7\5\2\2\u00ad\u00b8\5P)\2\u00ae")
        buf.write(u"\u00af\7\4\2\2\u00af\u00b8\5P)\2\u00b0\u00b1\7\5\2\2")
        buf.write(u"\u00b1\u00b8\5F$\2\u00b2\u00b3\7\4\2\2\u00b3\u00b8\5")
        buf.write(u"F$\2\u00b4\u00b5\7\n\2\2\u00b5\u00b8\5(\25\2\u00b6\u00b8")
        buf.write(u"\5\16\b\2\u00b7\u00ac\3\2\2\2\u00b7\u00ae\3\2\2\2\u00b7")
        buf.write(u"\u00b0\3\2\2\2\u00b7\u00b2\3\2\2\2\u00b7\u00b4\3\2\2")
        buf.write(u"\2\u00b7\u00b6\3\2\2\2\u00b8\21\3\2\2\2\u00b9\u00be\5")
        buf.write(u"\20\t\2\u00ba\u00bb\7\n\2\2\u00bb\u00be\5*\26\2\u00bc")
        buf.write(u"\u00be\7-\2\2\u00bd\u00b9\3\2\2\2\u00bd\u00ba\3\2\2\2")
        buf.write(u"\u00bd\u00bc\3\2\2\2\u00be\23\3\2\2\2\u00bf\u00c0\7\n")
        buf.write(u"\2\2\u00c0\u00c3\5,\27\2\u00c1\u00c3\5\22\n\2\u00c2\u00bf")
        buf.write(u"\3\2\2\2\u00c2\u00c1\3\2\2\2\u00c3\25\3\2\2\2\u00c4\u00c5")
        buf.write(u"\7\b\2\2\u00c5\u00cb\5\34\17\2\u00c6\u00c7\7\n\2\2\u00c7")
        buf.write(u"\u00cb\5\36\20\2\u00c8\u00c9\7\r\2\2\u00c9\u00cb\5\36")
        buf.write(u"\20\2\u00ca\u00c4\3\2\2\2\u00ca\u00c6\3\2\2\2\u00ca\u00c8")
        buf.write(u"\3\2\2\2\u00cb\27\3\2\2\2\u00cc\u00cd\7\n\2\2\u00cd\u00ce")
        buf.write(u"\5\34\17\2\u00ce\31\3\2\2\2\u00cf\u00d0\7\n\2\2\u00d0")
        buf.write(u"\u00d3\5 \21\2\u00d1\u00d3\7)\2\2\u00d2\u00cf\3\2\2\2")
        buf.write(u"\u00d2\u00d1\3\2\2\2\u00d3\33\3\2\2\2\u00d4\u00d5\7\t")
        buf.write(u"\2\2\u00d5\u00e5\5\26\f\2\u00d6\u00d7\7\23\2\2\u00d7")
        buf.write(u"\u00e5\5N(\2\u00d8\u00d9\7\23\2\2\u00d9\u00e5\5P)\2\u00da")
        buf.write(u"\u00db\7\23\2\2\u00db\u00e5\5R*\2\u00dc\u00dd\7\23\2")
        buf.write(u"\2\u00dd\u00e5\5T+\2\u00de\u00df\7\23\2\2\u00df\u00e5")
        buf.write(u"\5L\'\2\u00e0\u00e1\7\23\2\2\u00e1\u00e5\5b\62\2\u00e2")
        buf.write(u"\u00e3\7\23\2\2\u00e3\u00e5\5d\63\2\u00e4\u00d4\3\2\2")
        buf.write(u"\2\u00e4\u00d6\3\2\2\2\u00e4\u00d8\3\2\2\2\u00e4\u00da")
        buf.write(u"\3\2\2\2\u00e4\u00dc\3\2\2\2\u00e4\u00de\3\2\2\2\u00e4")
        buf.write(u"\u00e0\3\2\2\2\u00e4\u00e2\3\2\2\2\u00e5\35\3\2\2\2\u00e6")
        buf.write(u"\u00e7\7\23\2\2\u00e7\u00f1\5.\30\2\u00e8\u00e9\7\23")
        buf.write(u"\2\2\u00e9\u00f1\5\62\32\2\u00ea\u00eb\7\23\2\2\u00eb")
        buf.write(u"\u00f1\5\60\31\2\u00ec\u00ed\7\23\2\2\u00ed\u00f1\5T")
        buf.write(u"+\2\u00ee\u00ef\7\24\2\2\u00ef\u00f1\5> \2\u00f0\u00e6")
        buf.write(u"\3\2\2\2\u00f0\u00e8\3\2\2\2\u00f0\u00ea\3\2\2\2\u00f0")
        buf.write(u"\u00ec\3\2\2\2\u00f0\u00ee\3\2\2\2\u00f1\37\3\2\2\2\u00f2")
        buf.write(u"\u00f3\7\23\2\2\u00f3\u0103\5> \2\u00f4\u00f5\7\23\2")
        buf.write(u"\2\u00f5\u0103\5B\"\2\u00f6\u00f7\7\23\2\2\u00f7\u0103")
        buf.write(u"\5D#\2\u00f8\u00f9\7\23\2\2\u00f9\u0103\5F$\2\u00fa\u00fb")
        buf.write(u"\7\23\2\2\u00fb\u0103\5H%\2\u00fc\u00fd\7\23\2\2\u00fd")
        buf.write(u"\u0103\5J&\2\u00fe\u00ff\7\23\2\2\u00ff\u0103\5^\60\2")
        buf.write(u"\u0100\u0101\7\24\2\2\u0101\u0103\5^\60\2\u0102\u00f2")
        buf.write(u"\3\2\2\2\u0102\u00f4\3\2\2\2\u0102\u00f6\3\2\2\2\u0102")
        buf.write(u"\u00f8\3\2\2\2\u0102\u00fa\3\2\2\2\u0102\u00fc\3\2\2")
        buf.write(u"\2\u0102\u00fe\3\2\2\2\u0102\u0100\3\2\2\2\u0103!\3\2")
        buf.write(u"\2\2\u0104\u0105\7\24\2\2\u0105\u0106\5@!\2\u0106#\3")
        buf.write(u"\2\2\2\u0107\u0108\7\24\2\2\u0108\u010d\5B\"\2\u0109")
        buf.write(u"\u010a\7\24\2\2\u010a\u010d\5L\'\2\u010b\u010d\5\"\22")
        buf.write(u"\2\u010c\u0107\3\2\2\2\u010c\u0109\3\2\2\2\u010c\u010b")
        buf.write(u"\3\2\2\2\u010d%\3\2\2\2\u010e\u010f\7\23\2\2\u010f\u0116")
        buf.write(u"\58\35\2\u0110\u0111\7\24\2\2\u0111\u0116\5D#\2\u0112")
        buf.write(u"\u0113\7\24\2\2\u0113\u0116\5N(\2\u0114\u0116\5$\23\2")
        buf.write(u"\u0115\u010e\3\2\2\2\u0115\u0110\3\2\2\2\u0115\u0112")
        buf.write(u"\3\2\2\2\u0115\u0114\3\2\2\2\u0116\'\3\2\2\2\u0117\u0118")
        buf.write(u"\7\23\2\2\u0118\u011b\5\66\34\2\u0119\u011b\5&\24\2\u011a")
        buf.write(u"\u0117\3\2\2\2\u011a\u0119\3\2\2\2\u011b)\3\2\2\2\u011c")
        buf.write(u"\u011d\7\23\2\2\u011d\u0120\5:\36\2\u011e\u0120\5(\25")
        buf.write(u"\2\u011f\u011c\3\2\2\2\u011f\u011e\3\2\2\2\u0120+\3\2")
        buf.write(u"\2\2\u0121\u0122\7\23\2\2\u0122\u0125\5<\37\2\u0123\u0125")
        buf.write(u"\5*\26\2\u0124\u0121\3\2\2\2\u0124\u0123\3\2\2\2\u0125")
        buf.write(u"-\3\2\2\2\u0126\u0127\7$\2\2\u0127/\3\2\2\2\u0128\u012b")
        buf.write(u"\7%\2\2\u0129\u012b\5.\30\2\u012a\u0128\3\2\2\2\u012a")
        buf.write(u"\u0129\3\2\2\2\u012b\61\3\2\2\2\u012c\u012d\5.\30\2\u012d")
        buf.write(u"\63\3\2\2\2\u012e\u012f\5\60\31\2\u012f\65\3\2\2\2\u0130")
        buf.write(u"\u0131\7\13\2\2\u0131\u0134\5P)\2\u0132\u0134\7&\2\2")
        buf.write(u"\u0133\u0130\3\2\2\2\u0133\u0132\3\2\2\2\u0134\67\3\2")
        buf.write(u"\2\2\u0135\u0136\7*\2\2\u01369\3\2\2\2\u0137\u0138\5")
        buf.write(u"\66\34\2\u0138;\3\2\2\2\u0139\u013a\5:\36\2\u013a=\3")
        buf.write(u"\2\2\2\u013b\u013c\7\25\2\2\u013c\u013d\5> \2\u013d\u013e")
        buf.write(u"\7\60\2\2\u013e\u013f\5\32\16\2\u013f\u0147\3\2\2\2\u0140")
        buf.write(u"\u0141\7\27\2\2\u0141\u0142\5> \2\u0142\u0143\7\60\2")
        buf.write(u"\2\u0143\u0144\5 \21\2\u0144\u0147\3\2\2\2\u0145\u0147")
        buf.write(u"\7(\2\2\u0146\u013b\3\2\2\2\u0146\u0140\3\2\2\2\u0146")
        buf.write(u"\u0145\3\2\2\2\u0147?\3\2\2\2\u0148\u0149\7\25\2\2\u0149")
        buf.write(u"\u014a\5@!\2\u014a\u014b\7\60\2\2\u014b\u014c\5\32\16")
        buf.write(u"\2\u014c\u0156\3\2\2\2\u014d\u014e\7\27\2\2\u014e\u014f")
        buf.write(u"\5@!\2\u014f\u0150\7\60\2\2\u0150\u0151\5 \21\2\u0151")
        buf.write(u"\u0156\3\2\2\2\u0152\u0153\7\32\2\2\u0153\u0156\5V,\2")
        buf.write(u"\u0154\u0156\7+\2\2\u0155\u0148\3\2\2\2\u0155\u014d\3")
        buf.write(u"\2\2\2\u0155\u0152\3\2\2\2\u0155\u0154\3\2\2\2\u0156")
        buf.write(u"A\3\2\2\2\u0157\u0158\7\27\2\2\u0158\u0159\5B\"\2\u0159")
        buf.write(u"\u015a\7\60\2\2\u015a\u015b\5 \21\2\u015b\u0163\3\2\2")
        buf.write(u"\2\u015c\u015d\7\31\2\2\u015d\u0163\5X-\2\u015e\u015f")
        buf.write(u"\7\31\2\2\u015f\u0163\5`\61\2\u0160\u0163\7\'\2\2\u0161")
        buf.write(u"\u0163\5@!\2\u0162\u0157\3\2\2\2\u0162\u015c\3\2\2\2")
        buf.write(u"\u0162\u015e\3\2\2\2\u0162\u0160\3\2\2\2\u0162\u0161")
        buf.write(u"\3\2\2\2\u0163C\3\2\2\2\u0164\u0165\7\26\2\2\u0165\u0166")
        buf.write(u"\5D#\2\u0166\u0167\7\60\2\2\u0167\u0168\5\16\b\2\u0168")
        buf.write(u"\u0174\3\2\2\2\u0169\u016a\7\27\2\2\u016a\u016b\5D#\2")
        buf.write(u"\u016b\u016c\7\60\2\2\u016c\u016d\5 \21\2\u016d\u0174")
        buf.write(u"\3\2\2\2\u016e\u016f\7\31\2\2\u016f\u0174\5Z.\2\u0170")
        buf.write(u"\u0171\7\31\2\2\u0171\u0174\5b\62\2\u0172\u0174\5B\"")
        buf.write(u"\2\u0173\u0164\3\2\2\2\u0173\u0169\3\2\2\2\u0173\u016e")
        buf.write(u"\3\2\2\2\u0173\u0170\3\2\2\2\u0173\u0172\3\2\2\2\u0174")
        buf.write(u"E\3\2\2\2\u0175\u0176\7\26\2\2\u0176\u0177\5F$\2\u0177")
        buf.write(u"\u0178\7\60\2\2\u0178\u0179\5\20\t\2\u0179\u0184\3\2")
        buf.write(u"\2\2\u017a\u017b\7\27\2\2\u017b\u017c\5F$\2\u017c\u017d")
        buf.write(u"\7\60\2\2\u017d\u017e\5 \21\2\u017e\u0184\3\2\2\2\u017f")
        buf.write(u"\u0180\5p9\2\u0180\u0181\5\\/\2\u0181\u0184\3\2\2\2\u0182")
        buf.write(u"\u0184\5D#\2\u0183\u0175\3\2\2\2\u0183\u017a\3\2\2\2")
        buf.write(u"\u0183\u017f\3\2\2\2\u0183\u0182\3\2\2\2\u0184G\3\2\2")
        buf.write(u"\2\u0185\u0186\5F$\2\u0186I\3\2\2\2\u0187\u0188\7\25")
        buf.write(u"\2\2\u0188\u0189\5J&\2\u0189\u018a\7\60\2\2\u018a\u018b")
        buf.write(u"\5\24\13\2\u018b\u0193\3\2\2\2\u018c\u018d\7\27\2\2\u018d")
        buf.write(u"\u018e\5J&\2\u018e\u018f\7\60\2\2\u018f\u0190\5 \21\2")
        buf.write(u"\u0190\u0193\3\2\2\2\u0191\u0193\5H%\2\u0192\u0187\3")
        buf.write(u"\2\2\2\u0192\u018c\3\2\2\2\u0192\u0191\3\2\2\2\u0193")
        buf.write(u"K\3\2\2\2\u0194\u0195\7,\2\2\u0195M\3\2\2\2\u0196\u0197")
        buf.write(u"\7\22\2\2\u0197\u0198\5.\30\2\u0198\u0199\7\60\2\2\u0199")
        buf.write(u"\u019a\5\34\17\2\u019a\u01a9\3\2\2\2\u019b\u019c\7\26")
        buf.write(u"\2\2\u019c\u019d\5N(\2\u019d\u019e\7\60\2\2\u019e\u019f")
        buf.write(u"\5\16\b\2\u019f\u01a9\3\2\2\2\u01a0\u01a1\7\27\2\2\u01a1")
        buf.write(u"\u01a2\5N(\2\u01a2\u01a3\7\60\2\2\u01a3\u01a4\5\34\17")
        buf.write(u"\2\u01a4\u01a9\3\2\2\2\u01a5\u01a6\7\31\2\2\u01a6\u01a9")
        buf.write(u"\5h\65\2\u01a7\u01a9\5L\'\2\u01a8\u0196\3\2\2\2\u01a8")
        buf.write(u"\u019b\3\2\2\2\u01a8\u01a0\3\2\2\2\u01a8\u01a5\3\2\2")
        buf.write(u"\2\u01a8\u01a7\3\2\2\2\u01a9O\3\2\2\2\u01aa\u01ab\7\f")
        buf.write(u"\2\2\u01ab\u01bb\5\66\34\2\u01ac\u01ad\7\26\2\2\u01ad")
        buf.write(u"\u01ae\5P)\2\u01ae\u01af\7\60\2\2\u01af\u01b0\5\20\t")
        buf.write(u"\2\u01b0\u01bb\3\2\2\2\u01b1\u01b2\7\27\2\2\u01b2\u01b3")
        buf.write(u"\5P)\2\u01b3\u01b4\7\60\2\2\u01b4\u01b5\5\34\17\2\u01b5")
        buf.write(u"\u01bb\3\2\2\2\u01b6\u01b7\5p9\2\u01b7\u01b8\5j\66\2")
        buf.write(u"\u01b8\u01bb\3\2\2\2\u01b9\u01bb\5N(\2\u01ba\u01aa\3")
        buf.write(u"\2\2\2\u01ba\u01ac\3\2\2\2\u01ba\u01b1\3\2\2\2\u01ba")
        buf.write(u"\u01b6\3\2\2\2\u01ba\u01b9\3\2\2\2\u01bbQ\3\2\2\2\u01bc")
        buf.write(u"\u01bd\5P)\2\u01bdS\3\2\2\2\u01be\u01bf\7\25\2\2\u01bf")
        buf.write(u"\u01c0\5T+\2\u01c0\u01c1\7\60\2\2\u01c1\u01c2\5\24\13")
        buf.write(u"\2\u01c2\u01ca\3\2\2\2\u01c3\u01c4\7\27\2\2\u01c4\u01c5")
        buf.write(u"\5T+\2\u01c5\u01c6\7\60\2\2\u01c6\u01c7\5\34\17\2\u01c7")
        buf.write(u"\u01ca\3\2\2\2\u01c8\u01ca\5R*\2\u01c9\u01be\3\2\2\2")
        buf.write(u"\u01c9\u01c3\3\2\2\2\u01c9\u01c8\3\2\2\2\u01caU\3\2\2")
        buf.write(u"\2\u01cb\u01cc\7\30\2\2\u01cc\u01cd\5^\60\2\u01cd\u01ce")
        buf.write(u"\7\60\2\2\u01ce\u01cf\5@!\2\u01cfW\3\2\2\2\u01d0\u01d1")
        buf.write(u"\7\35\2\2\u01d1\u01d2\5> \2\u01d2\u01d3\7\60\2\2\u01d3")
        buf.write(u"\u01d4\5> \2\u01d4\u01e2\3\2\2\2\u01d5\u01d6\7\"\2\2")
        buf.write(u"\u01d6\u01d7\5 \21\2\u01d7\u01d8\7\60\2\2\u01d8\u01d9")
        buf.write(u"\5 \21\2\u01d9\u01da\7\60\2\2\u01da\u01db\5X-\2\u01db")
        buf.write(u"\u01e2\3\2\2\2\u01dc\u01dd\7\30\2\2\u01dd\u01de\5^\60")
        buf.write(u"\2\u01de\u01df\7\60\2\2\u01df\u01e0\5B\"\2\u01e0\u01e2")
        buf.write(u"\3\2\2\2\u01e1\u01d0\3\2\2\2\u01e1\u01d5\3\2\2\2\u01e1")
        buf.write(u"\u01dc\3\2\2\2\u01e2Y\3\2\2\2\u01e3\u01e4\7\30\2\2\u01e4")
        buf.write(u"\u01e5\5^\60\2\u01e5\u01e6\7\60\2\2\u01e6\u01e7\5D#\2")
        buf.write(u"\u01e7\u01ea\3\2\2\2\u01e8\u01ea\5X-\2\u01e9\u01e3\3")
        buf.write(u"\2\2\2\u01e9\u01e8\3\2\2\2\u01ea[\3\2\2\2\u01eb\u01ec")
        buf.write(u"\7\26\2\2\u01ec\u01ed\5\\/\2\u01ed\u01ee\7\60\2\2\u01ee")
        buf.write(u"\u01ef\5\20\t\2\u01ef\u01f2\3\2\2\2\u01f0\u01f2\5Z.\2")
        buf.write(u"\u01f1\u01eb\3\2\2\2\u01f1\u01f0\3\2\2\2\u01f2]\3\2\2")
        buf.write(u"\2\u01f3\u01f4\7 \2\2\u01f4\u01f5\5> \2\u01f5\u01f6\7")
        buf.write(u"\60\2\2\u01f6\u01f7\5> \2\u01f7\u01ff\3\2\2\2\u01f8\u01f9")
        buf.write(u"\7\25\2\2\u01f9\u01fa\5^\60\2\u01fa\u01fb\7\60\2\2\u01fb")
        buf.write(u"\u01fc\5\22\n\2\u01fc\u01ff\3\2\2\2\u01fd\u01ff\5\\/")
        buf.write(u"\2\u01fe\u01f3\3\2\2\2\u01fe\u01f8\3\2\2\2\u01fe\u01fd")
        buf.write(u"\3\2\2\2\u01ff_\3\2\2\2\u0200\u0201\7\37\2\2\u0201\u0202")
        buf.write(u"\5\34\17\2\u0202\u0203\7\60\2\2\u0203\u0204\5 \21\2\u0204")
        buf.write(u"\u020b\3\2\2\2\u0205\u0206\7\30\2\2\u0206\u0207\5d\63")
        buf.write(u"\2\u0207\u0208\7\60\2\2\u0208\u0209\5L\'\2\u0209\u020b")
        buf.write(u"\3\2\2\2\u020a\u0200\3\2\2\2\u020a\u0205\3\2\2\2\u020b")
        buf.write(u"a\3\2\2\2\u020c\u020d\7\30\2\2\u020d\u020e\5d\63\2\u020e")
        buf.write(u"\u020f\7\60\2\2\u020f\u0210\5N(\2\u0210\u0213\3\2\2\2")
        buf.write(u"\u0211\u0213\5`\61\2\u0212\u020c\3\2\2\2\u0212\u0211")
        buf.write(u"\3\2\2\2\u0213c\3\2\2\2\u0214\u0215\7!\2\2\u0215\u0216")
        buf.write(u"\5\34\17\2\u0216\u0217\7\60\2\2\u0217\u0218\5> \2\u0218")
        buf.write(u"\u021f\3\2\2\2\u0219\u021a\7\25\2\2\u021a\u021b\5d\63")
        buf.write(u"\2\u021b\u021c\7\60\2\2\u021c\u021d\5\22\n\2\u021d\u021f")
        buf.write(u"\3\2\2\2\u021e\u0214\3\2\2\2\u021e\u0219\3\2\2\2\u021f")
        buf.write(u"e\3\2\2\2\u0220\u0221\7\36\2\2\u0221\u0222\5\34\17\2")
        buf.write(u"\u0222\u0223\7\60\2\2\u0223\u0224\5\34\17\2\u0224\u022b")
        buf.write(u"\3\2\2\2\u0225\u0226\7\30\2\2\u0226\u0227\5l\67\2\u0227")
        buf.write(u"\u0228\7\60\2\2\u0228\u0229\5L\'\2\u0229\u022b\3\2\2")
        buf.write(u"\2\u022a\u0220\3\2\2\2\u022a\u0225\3\2\2\2\u022bg\3\2")
        buf.write(u"\2\2\u022c\u022d\7\30\2\2\u022d\u022e\5l\67\2\u022e\u022f")
        buf.write(u"\7\60\2\2\u022f\u0230\5N(\2\u0230\u0233\3\2\2\2\u0231")
        buf.write(u"\u0233\5f\64\2\u0232\u022c\3\2\2\2\u0232\u0231\3\2\2")
        buf.write(u"\2\u0233i\3\2\2\2\u0234\u0235\7\26\2\2\u0235\u0236\5")
        buf.write(u"j\66\2\u0236\u0237\7\60\2\2\u0237\u0238\5\20\t\2\u0238")
        buf.write(u"\u023b\3\2\2\2\u0239\u023b\5h\65\2\u023a\u0234\3\2\2")
        buf.write(u"\2\u023a\u0239\3\2\2\2\u023bk\3\2\2\2\u023c\u023d\7\25")
        buf.write(u"\2\2\u023d\u023e\5l\67\2\u023e\u023f\7\60\2\2\u023f\u0240")
        buf.write(u"\5\22\n\2\u0240\u0244\3\2\2\2\u0241\u0244\5n8\2\u0242")
        buf.write(u"\u0244\5j\66\2\u0243\u023c\3\2\2\2\u0243\u0241\3\2\2")
        buf.write(u"\2\u0243\u0242\3\2\2\2\u0244m\3\2\2\2\u0245\u0246\7#")
        buf.write(u"\2\2\u0246\u0247\5\34\17\2\u0247\u0248\7\60\2\2\u0248")
        buf.write(u"\u0249\5\34\17\2\u0249\u024a\7\60\2\2\u024a\u024b\5D")
        buf.write(u"#\2\u024b\u0252\3\2\2\2\u024c\u024d\7\25\2\2\u024d\u024e")
        buf.write(u"\5n8\2\u024e\u024f\7\60\2\2\u024f\u0250\7.\2\2\u0250")
        buf.write(u"\u0252\3\2\2\2\u0251\u0245\3\2\2\2\u0251\u024c\3\2\2")
        buf.write(u"\2\u0252o\3\2\2\2\u0253\u0254\t\2\2\2\u0254q\3\2\2\2")
        buf.write(u"-u{\u0082\u0088\u008f\u00a0\u00aa\u00b7\u00bd\u00c2\u00ca")
        buf.write(u"\u00d2\u00e4\u00f0\u0102\u010c\u0115\u011a\u011f\u0124")
        buf.write(u"\u012a\u0133\u0146\u0155\u0162\u0173\u0183\u0192\u01a8")
        buf.write(u"\u01ba\u01c9\u01e1\u01e9\u01f1\u01fe\u020a\u0212\u021e")
        buf.write(u"\u022a\u0232\u023a\u0243\u0251")
        return buf.getvalue()


class TransformationAlgebraParser ( Parser ):

    grammarFileName = "TransformationAlgebra.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'avg '", u"'min '", u"'max '", u"'sum '", 
                     u"'count '", u"'reify '", u"'deify '", u"'get '", u"'invert '", 
                     u"'revert '", u"'merge '", u"'fcont '", u"'ocont '", 
                     u"'size '", u"'ratio '", u"'interpol '", u"'pi1 '", 
                     u"'pi2 '", u"'sigmae '", u"'sigmale '", u"'bowtie '", 
                     u"'bowtie* '", u"'groupby_avg '", u"'groupby_sum '", 
                     u"'groupby_min '", u"'groupby_max '", u"'odist '", 
                     u"'ldist '", u"'lodist '", u"'otopo '", u"'lotopo '", 
                     u"'ndist '", u"'lvis '", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"'in'", 
                     u"<INVALID>", u"<INVALID>", u"' '" ]

    symbolicNames = [ u"<INVALID>", u"AVG", u"MIN", u"MAX", u"SUM", u"COUNT", 
                      u"REIFY", u"DEIFY", u"GET", u"INVERT", u"REVERT", 
                      u"MERGE", u"FCONT", u"OCONT", u"SIZE", u"RATIO", u"INTERPOL", 
                      u"PI1", u"PI2", u"SIGMAE2", u"SIGMASE2", u"BOWTIE", 
                      u"BOWTIESTAR", u"GROUPBYAVG", u"GROUPBYSUM", u"GROUPBYMIN", 
                      u"GROUPBYMAX", u"ODIST", u"LDIST", u"LODIST", u"OTOPO", 
                      u"LOTOPO", u"NDIST", u"LVIS", u"DATAPM", u"DATAAMOUNT", 
                      u"DATACONTOUR", u"DATAOBJQ", u"DATAOBJS", u"DATAOBJV", 
                      u"DATACONTOURLINE", u"DATAOBJCOUNT", u"DATAFIELD", 
                      u"TOPOV", u"BOOLV", u"DATAV", u"WHITESPACE", u"KEYWORD", 
                      u"WS" ]

    RULE_start = 0
    RULE_r = 1
    RULE_rr = 2
    RULE_v = 3
    RULE_countv = 4
    RULE_ratiov = 5
    RULE_intv = 6
    RULE_ordv = 7
    RULE_nomv = 8
    RULE_qv = 9
    RULE_sv = 10
    RULE_lv = 11
    RULE_ov = 12
    RULE_l = 13
    RULE_s = 14
    RULE_o = 15
    RULE_count = 16
    RULE_ratio = 17
    RULE_intt = 18
    RULE_ordinal = 19
    RULE_nom = 20
    RULE_q = 21
    RULE_sint = 22
    RULE_snom = 23
    RULE_sord = 24
    RULE_sq = 25
    RULE_ords = 26
    RULE_ints = 27
    RULE_noms = 28
    RULE_qs = 29
    RULE_os = 30
    RULE_ocount = 31
    RULE_oratio = 32
    RULE_oint = 33
    RULE_oord = 34
    RULE_onom = 35
    RULE_oq = 36
    RULE_lratio = 37
    RULE_lint = 38
    RULE_lord = 39
    RULE_lnom = 40
    RULE_lq = 41
    RULE_ocounto = 42
    RULE_oratioo = 43
    RULE_ointo = 44
    RULE_oordo = 45
    RULE_onomo = 46
    RULE_lratioo = 47
    RULE_linto = 48
    RULE_lnomo = 49
    RULE_lratiol = 50
    RULE_lintl = 51
    RULE_lordl = 52
    RULE_lnoml = 53
    RULE_lbooll = 54
    RULE_groupbyaggord = 55

    ruleNames =  [ u"start", u"r", u"rr", u"v", u"countv", u"ratiov", u"intv", 
                   u"ordv", u"nomv", u"qv", u"sv", u"lv", u"ov", u"l", u"s", 
                   u"o", u"count", u"ratio", u"intt", u"ordinal", u"nom", 
                   u"q", u"sint", u"snom", u"sord", u"sq", u"ords", u"ints", 
                   u"noms", u"qs", u"os", u"ocount", u"oratio", u"oint", 
                   u"oord", u"onom", u"oq", u"lratio", u"lint", u"lord", 
                   u"lnom", u"lq", u"ocounto", u"oratioo", u"ointo", u"oordo", 
                   u"onomo", u"lratioo", u"linto", u"lnomo", u"lratiol", 
                   u"lintl", u"lordl", u"lnoml", u"lbooll", u"groupbyaggord" ]

    EOF = Token.EOF
    AVG=1
    MIN=2
    MAX=3
    SUM=4
    COUNT=5
    REIFY=6
    DEIFY=7
    GET=8
    INVERT=9
    REVERT=10
    MERGE=11
    FCONT=12
    OCONT=13
    SIZE=14
    RATIO=15
    INTERPOL=16
    PI1=17
    PI2=18
    SIGMAE2=19
    SIGMASE2=20
    BOWTIE=21
    BOWTIESTAR=22
    GROUPBYAVG=23
    GROUPBYSUM=24
    GROUPBYMIN=25
    GROUPBYMAX=26
    ODIST=27
    LDIST=28
    LODIST=29
    OTOPO=30
    LOTOPO=31
    NDIST=32
    LVIS=33
    DATAPM=34
    DATAAMOUNT=35
    DATACONTOUR=36
    DATAOBJQ=37
    DATAOBJS=38
    DATAOBJV=39
    DATACONTOURLINE=40
    DATAOBJCOUNT=41
    DATAFIELD=42
    TOPOV=43
    BOOLV=44
    DATAV=45
    WHITESPACE=46
    KEYWORD=47
    WS=48

    def __init__(self, input, output=sys.stdout):
        super(TransformationAlgebraParser, self).__init__(input, output=output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.StartContext, self).__init__(parent, invokingState)
            self.parser = parser

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RrContext,0)


        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.VContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_start

        def enterRule(self, listener):
            if hasattr(listener, "enterStart"):
                listener.enterStart(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStart"):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DEIFY, TransformationAlgebraParser.PI1, TransformationAlgebraParser.PI2]:
                self.state = 112
                self.r()
                pass
            elif token in [TransformationAlgebraParser.INVERT, TransformationAlgebraParser.REVERT, TransformationAlgebraParser.INTERPOL, TransformationAlgebraParser.SIGMAE2, TransformationAlgebraParser.SIGMASE2, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.GROUPBYAVG, TransformationAlgebraParser.GROUPBYSUM, TransformationAlgebraParser.GROUPBYMIN, TransformationAlgebraParser.GROUPBYMAX, TransformationAlgebraParser.DATAPM, TransformationAlgebraParser.DATAAMOUNT, TransformationAlgebraParser.DATACONTOUR, TransformationAlgebraParser.DATAOBJQ, TransformationAlgebraParser.DATAOBJS, TransformationAlgebraParser.DATAOBJCOUNT, TransformationAlgebraParser.DATAFIELD]:
                self.state = 113
                self.rr()
                pass
            elif token in [TransformationAlgebraParser.AVG, TransformationAlgebraParser.MIN, TransformationAlgebraParser.MAX, TransformationAlgebraParser.COUNT, TransformationAlgebraParser.REIFY, TransformationAlgebraParser.GET, TransformationAlgebraParser.MERGE, TransformationAlgebraParser.FCONT, TransformationAlgebraParser.OCONT, TransformationAlgebraParser.SIZE, TransformationAlgebraParser.RATIO, TransformationAlgebraParser.DATAOBJV, TransformationAlgebraParser.TOPOV, TransformationAlgebraParser.DATAV]:
                self.state = 114
                self.v()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RContext, self).__init__(parent, invokingState)
            self.parser = parser

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_r

        def enterRule(self, listener):
            if hasattr(listener, "enterR"):
                listener.enterR(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitR"):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_r)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 117
                self.l()
                pass

            elif la_ == 2:
                self.state = 118
                self.s()
                pass

            elif la_ == 3:
                self.state = 119
                self.q()
                pass

            elif la_ == 4:
                self.state = 120
                self.o()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RrContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def sq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SqContext,0)


        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_rr

        def enterRule(self, listener):
            if hasattr(listener, "enterRr"):
                listener.enterRr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRr"):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 123
                self.lq()
                pass

            elif la_ == 2:
                self.state = 124
                self.sq()
                pass

            elif la_ == 3:
                self.state = 125
                self.qs()
                pass

            elif la_ == 4:
                self.state = 126
                self.oq()
                pass

            elif la_ == 5:
                self.state = 127
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.VContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def lv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LvContext,0)


        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_v

        def enterRule(self, listener):
            if hasattr(listener, "enterV"):
                listener.enterV(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitV"):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_v)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 130
                self.ov()
                pass

            elif la_ == 2:
                self.state = 131
                self.lv()
                pass

            elif la_ == 3:
                self.state = 132
                self.sv()
                pass

            elif la_ == 4:
                self.state = 133
                self.qv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(TransformationAlgebraParser.COUNT, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_countv

        def enterRule(self, listener):
            if hasattr(listener, "enterCountv"):
                listener.enterCountv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCountv"):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_countv)
        try:
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.COUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.match(TransformationAlgebraParser.COUNT)
                self.state = 137
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 138
                self.match(TransformationAlgebraParser.GET)
                self.state = 139
                self.count()
                pass
            elif token in [TransformationAlgebraParser.DATAV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 140
                self.match(TransformationAlgebraParser.DATAV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatiovContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatiovContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FCONT(self):
            return self.getToken(TransformationAlgebraParser.FCONT, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def SIZE(self):
            return self.getToken(TransformationAlgebraParser.SIZE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def RATIO(self):
            return self.getToken(TransformationAlgebraParser.RATIO, 0)

        def ratiov(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.RatiovContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountvContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratiov

        def enterRule(self, listener):
            if hasattr(listener, "enterRatiov"):
                listener.enterRatiov(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatiov"):
                listener.exitRatiov(self)




    def ratiov(self):

        localctx = TransformationAlgebraParser.RatiovContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ratiov)
        try:
            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 144
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 145
                self.match(TransformationAlgebraParser.SIZE)
                self.state = 146
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 147
                self.match(TransformationAlgebraParser.RATIO)
                self.state = 148
                self.ratiov()
                self.state = 149
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 150
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 152
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 153
                self.oratio()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 154
                self.match(TransformationAlgebraParser.GET)
                self.state = 155
                self.ratio()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 156
                self.countv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 157
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def ratiov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intv

        def enterRule(self, listener):
            if hasattr(listener, "enterIntv"):
                listener.enterIntv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntv"):
                listener.exitIntv(self)




    def intv(self):

        localctx = TransformationAlgebraParser.IntvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_intv)
        try:
            self.state = 168
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 160
                self.match(TransformationAlgebraParser.AVG)
                self.state = 161
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.match(TransformationAlgebraParser.AVG)
                self.state = 163
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 164
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 165
                self.match(TransformationAlgebraParser.GET)
                self.state = 166
                self.intt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 167
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MAX(self):
            return self.getToken(TransformationAlgebraParser.MAX, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def MIN(self):
            return self.getToken(TransformationAlgebraParser.MIN, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordv

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdv"):
                listener.enterOrdv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdv"):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ordv)
        try:
            self.state = 181
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.match(TransformationAlgebraParser.MAX)
                self.state = 171
                self.lord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 172
                self.match(TransformationAlgebraParser.MIN)
                self.state = 173
                self.lord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 174
                self.match(TransformationAlgebraParser.MAX)
                self.state = 175
                self.oord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 176
                self.match(TransformationAlgebraParser.MIN)
                self.state = 177
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 178
                self.match(TransformationAlgebraParser.GET)
                self.state = 179
                self.ordinal()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 180
                self.intv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def TOPOV(self):
            return self.getToken(TransformationAlgebraParser.TOPOV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nomv

        def enterRule(self, listener):
            if hasattr(listener, "enterNomv"):
                listener.enterNomv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNomv"):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nomv)
        try:
            self.state = 187
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 183
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 184
                self.match(TransformationAlgebraParser.GET)
                self.state = 185
                self.nom()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 186
                self.match(TransformationAlgebraParser.TOPOV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qv

        def enterRule(self, listener):
            if hasattr(listener, "enterQv"):
                listener.enterQv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQv"):
                listener.exitQv(self)




    def qv(self):

        localctx = TransformationAlgebraParser.QvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_qv)
        try:
            self.state = 192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 189
                self.match(TransformationAlgebraParser.GET)
                self.state = 190
                self.q()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 191
                self.nomv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REIFY(self):
            return self.getToken(TransformationAlgebraParser.REIFY, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def MERGE(self):
            return self.getToken(TransformationAlgebraParser.MERGE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sv

        def enterRule(self, listener):
            if hasattr(listener, "enterSv"):
                listener.enterSv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSv"):
                listener.exitSv(self)




    def sv(self):

        localctx = TransformationAlgebraParser.SvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sv)
        try:
            self.state = 200
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.REIFY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 194
                self.match(TransformationAlgebraParser.REIFY)
                self.state = 195
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.match(TransformationAlgebraParser.GET)
                self.state = 197
                self.s()
                pass
            elif token in [TransformationAlgebraParser.MERGE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 198
                self.match(TransformationAlgebraParser.MERGE)
                self.state = 199
                self.s()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lv

        def enterRule(self, listener):
            if hasattr(listener, "enterLv"):
                listener.enterLv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLv"):
                listener.exitLv(self)




    def lv(self):

        localctx = TransformationAlgebraParser.LvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_lv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(TransformationAlgebraParser.GET)
            self.state = 203
            self.l()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJV(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ov

        def enterRule(self, listener):
            if hasattr(listener, "enterOv"):
                listener.enterOv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOv"):
                listener.exitOv(self)




    def ov(self):

        localctx = TransformationAlgebraParser.OvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ov)
        try:
            self.state = 208
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 205
                self.match(TransformationAlgebraParser.GET)
                self.state = 206
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 207
                self.match(TransformationAlgebraParser.DATAOBJV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DEIFY(self):
            return self.getToken(TransformationAlgebraParser.DEIFY, 0)

        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def linto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintoContext,0)


        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_l

        def enterRule(self, listener):
            if hasattr(listener, "enterL"):
                listener.enterL(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitL"):
                listener.exitL(self)




    def l(self):

        localctx = TransformationAlgebraParser.LContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_l)
        try:
            self.state = 226
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 210
                self.match(TransformationAlgebraParser.DEIFY)
                self.state = 211
                self.sv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 212
                self.match(TransformationAlgebraParser.PI1)
                self.state = 213
                self.lint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 214
                self.match(TransformationAlgebraParser.PI1)
                self.state = 215
                self.lord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 216
                self.match(TransformationAlgebraParser.PI1)
                self.state = 217
                self.lnom()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 218
                self.match(TransformationAlgebraParser.PI1)
                self.state = 219
                self.lq()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 220
                self.match(TransformationAlgebraParser.PI1)
                self.state = 221
                self.lratio()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 222
                self.match(TransformationAlgebraParser.PI1)
                self.state = 223
                self.linto()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 224
                self.match(TransformationAlgebraParser.PI1)
                self.state = 225
                self.lnomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def sord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SordContext,0)


        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_s

        def enterRule(self, listener):
            if hasattr(listener, "enterS"):
                listener.enterS(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitS"):
                listener.exitS(self)




    def s(self):

        localctx = TransformationAlgebraParser.SContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_s)
        try:
            self.state = 238
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 228
                self.match(TransformationAlgebraParser.PI1)
                self.state = 229
                self.sint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 230
                self.match(TransformationAlgebraParser.PI1)
                self.state = 231
                self.sord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 232
                self.match(TransformationAlgebraParser.PI1)
                self.state = 233
                self.snom()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 234
                self.match(TransformationAlgebraParser.PI1)
                self.state = 235
                self.lq()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 236
                self.match(TransformationAlgebraParser.PI2)
                self.state = 237
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_o

        def enterRule(self, listener):
            if hasattr(listener, "enterO"):
                listener.enterO(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitO"):
                listener.exitO(self)




    def o(self):

        localctx = TransformationAlgebraParser.OContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_o)
        try:
            self.state = 256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 240
                self.match(TransformationAlgebraParser.PI1)
                self.state = 241
                self.os()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 242
                self.match(TransformationAlgebraParser.PI1)
                self.state = 243
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 244
                self.match(TransformationAlgebraParser.PI1)
                self.state = 245
                self.oint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 246
                self.match(TransformationAlgebraParser.PI1)
                self.state = 247
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 248
                self.match(TransformationAlgebraParser.PI1)
                self.state = 249
                self.onom()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 250
                self.match(TransformationAlgebraParser.PI1)
                self.state = 251
                self.oq()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 252
                self.match(TransformationAlgebraParser.PI1)
                self.state = 253
                self.onomo()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 254
                self.match(TransformationAlgebraParser.PI2)
                self.state = 255
                self.onomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_count

        def enterRule(self, listener):
            if hasattr(listener, "enterCount"):
                listener.enterCount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCount"):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(TransformationAlgebraParser.PI2)
            self.state = 259
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratio

        def enterRule(self, listener):
            if hasattr(listener, "enterRatio"):
                listener.enterRatio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatio"):
                listener.exitRatio(self)




    def ratio(self):

        localctx = TransformationAlgebraParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ratio)
        try:
            self.state = 266
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 261
                self.match(TransformationAlgebraParser.PI2)
                self.state = 262
                self.oratio()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 263
                self.match(TransformationAlgebraParser.PI2)
                self.state = 264
                self.lratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 265
                self.count()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InttContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.InttContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ints(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntsContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intt

        def enterRule(self, listener):
            if hasattr(listener, "enterIntt"):
                listener.enterIntt(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntt"):
                listener.exitIntt(self)




    def intt(self):

        localctx = TransformationAlgebraParser.InttContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_intt)
        try:
            self.state = 275
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 268
                self.match(TransformationAlgebraParser.PI1)
                self.state = 269
                self.ints()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 270
                self.match(TransformationAlgebraParser.PI2)
                self.state = 271
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 272
                self.match(TransformationAlgebraParser.PI2)
                self.state = 273
                self.lint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 274
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdinalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdinalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordinal

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdinal"):
                listener.enterOrdinal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdinal"):
                listener.exitOrdinal(self)




    def ordinal(self):

        localctx = TransformationAlgebraParser.OrdinalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordinal)
        try:
            self.state = 280
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 277
                self.match(TransformationAlgebraParser.PI1)
                self.state = 278
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 279
                self.intt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nom

        def enterRule(self, listener):
            if hasattr(listener, "enterNom"):
                listener.enterNom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNom"):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_nom)
        try:
            self.state = 285
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 282
                self.match(TransformationAlgebraParser.PI1)
                self.state = 283
                self.noms()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 284
                self.ordinal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_q

        def enterRule(self, listener):
            if hasattr(listener, "enterQ"):
                listener.enterQ(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQ"):
                listener.exitQ(self)




    def q(self):

        localctx = TransformationAlgebraParser.QContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_q)
        try:
            self.state = 290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 287
                self.match(TransformationAlgebraParser.PI1)
                self.state = 288
                self.qs()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 289
                self.nom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAPM(self):
            return self.getToken(TransformationAlgebraParser.DATAPM, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sint

        def enterRule(self, listener):
            if hasattr(listener, "enterSint"):
                listener.enterSint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSint"):
                listener.exitSint(self)




    def sint(self):

        localctx = TransformationAlgebraParser.SintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.match(TransformationAlgebraParser.DATAPM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAAMOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAAMOUNT, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_snom

        def enterRule(self, listener):
            if hasattr(listener, "enterSnom"):
                listener.enterSnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSnom"):
                listener.exitSnom(self)




    def snom(self):

        localctx = TransformationAlgebraParser.SnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_snom)
        try:
            self.state = 296
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DATAAMOUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 294
                self.match(TransformationAlgebraParser.DATAAMOUNT)
                pass
            elif token in [TransformationAlgebraParser.DATAPM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.sint()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sord

        def enterRule(self, listener):
            if hasattr(listener, "enterSord"):
                listener.enterSord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSord"):
                listener.exitSord(self)




    def sord(self):

        localctx = TransformationAlgebraParser.SordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_sord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.sint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sq

        def enterRule(self, listener):
            if hasattr(listener, "enterSq"):
                listener.enterSq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSq"):
                listener.exitSq(self)




    def sq(self):

        localctx = TransformationAlgebraParser.SqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.snom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INVERT(self):
            return self.getToken(TransformationAlgebraParser.INVERT, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def DATACONTOUR(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOUR, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ords

        def enterRule(self, listener):
            if hasattr(listener, "enterOrds"):
                listener.enterOrds(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrds"):
                listener.exitOrds(self)




    def ords(self):

        localctx = TransformationAlgebraParser.OrdsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_ords)
        try:
            self.state = 305
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INVERT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 302
                self.match(TransformationAlgebraParser.INVERT)
                self.state = 303
                self.lord()
                pass
            elif token in [TransformationAlgebraParser.DATACONTOUR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 304
                self.match(TransformationAlgebraParser.DATACONTOUR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOURLINE(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOURLINE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ints

        def enterRule(self, listener):
            if hasattr(listener, "enterInts"):
                listener.enterInts(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInts"):
                listener.exitInts(self)




    def ints(self):

        localctx = TransformationAlgebraParser.IntsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self.match(TransformationAlgebraParser.DATACONTOURLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_noms

        def enterRule(self, listener):
            if hasattr(listener, "enterNoms"):
                listener.enterNoms(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNoms"):
                listener.exitNoms(self)




    def noms(self):

        localctx = TransformationAlgebraParser.NomsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_noms)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.ords()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qs

        def enterRule(self, listener):
            if hasattr(listener, "enterQs"):
                listener.enterQs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQs"):
                listener.exitQs(self)




    def qs(self):

        localctx = TransformationAlgebraParser.QsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_qs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.noms()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJS(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJS, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_os

        def enterRule(self, listener):
            if hasattr(listener, "enterOs"):
                listener.enterOs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOs"):
                listener.exitOs(self)




    def os(self):

        localctx = TransformationAlgebraParser.OsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_os)
        try:
            self.state = 324
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 313
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 314
                self.os()
                self.state = 315
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 316
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 318
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 319
                self.os()
                self.state = 320
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 321
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 323
                self.match(TransformationAlgebraParser.DATAOBJS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYSUM(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSUM, 0)

        def ocounto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountoContext,0)


        def DATAOBJCOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJCOUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocount

        def enterRule(self, listener):
            if hasattr(listener, "enterOcount"):
                listener.enterOcount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcount"):
                listener.exitOcount(self)




    def ocount(self):

        localctx = TransformationAlgebraParser.OcountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_ocount)
        try:
            self.state = 339
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 326
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 327
                self.ocount()
                self.state = 328
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 329
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 331
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 332
                self.ocount()
                self.state = 333
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 334
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYSUM]:
                self.enterOuterAlt(localctx, 3)
                self.state = 336
                self.match(TransformationAlgebraParser.GROUPBYSUM)
                self.state = 337
                self.ocounto()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJCOUNT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 338
                self.match(TransformationAlgebraParser.DATAOBJCOUNT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def lratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiooContext,0)


        def DATAOBJQ(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJQ, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratio

        def enterRule(self, listener):
            if hasattr(listener, "enterOratio"):
                listener.enterOratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratio"):
                listener.exitOratio(self)




    def oratio(self):

        localctx = TransformationAlgebraParser.OratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_oratio)
        try:
            self.state = 352
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 341
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 342
                self.oratio()
                self.state = 343
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 344
                self.o()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 346
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 347
                self.oratioo()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 348
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 349
                self.lratioo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 350
                self.match(TransformationAlgebraParser.DATAOBJQ)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 351
                self.ocount()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def linto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oint

        def enterRule(self, listener):
            if hasattr(listener, "enterOint"):
                listener.enterOint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOint"):
                listener.exitOint(self)




    def oint(self):

        localctx = TransformationAlgebraParser.OintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_oint)
        try:
            self.state = 369
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 354
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 355
                self.oint()
                self.state = 356
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 357
                self.intv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 359
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 360
                self.oint()
                self.state = 361
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 362
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 364
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 365
                self.ointo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 366
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 367
                self.linto()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 368
                self.oratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oord

        def enterRule(self, listener):
            if hasattr(listener, "enterOord"):
                listener.enterOord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOord"):
                listener.exitOord(self)




    def oord(self):

        localctx = TransformationAlgebraParser.OordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_oord)
        try:
            self.state = 385
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 371
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 372
                self.oord()
                self.state = 373
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 374
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 376
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 377
                self.oord()
                self.state = 378
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 379
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 381
                self.groupbyaggord()
                self.state = 382
                self.oordo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 384
                self.oint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onom

        def enterRule(self, listener):
            if hasattr(listener, "enterOnom"):
                listener.enterOnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnom"):
                listener.exitOnom(self)




    def onom(self):

        localctx = TransformationAlgebraParser.OnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_onom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.oord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oq

        def enterRule(self, listener):
            if hasattr(listener, "enterOq"):
                listener.enterOq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOq"):
                listener.exitOq(self)




    def oq(self):

        localctx = TransformationAlgebraParser.OqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_oq)
        try:
            self.state = 400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 389
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 390
                self.oq()
                self.state = 391
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 392
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 394
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 395
                self.oq()
                self.state = 396
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 397
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 399
                self.onom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAFIELD(self):
            return self.getToken(TransformationAlgebraParser.DATAFIELD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratio

        def enterRule(self, listener):
            if hasattr(listener, "enterLratio"):
                listener.enterLratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratio"):
                listener.exitLratio(self)




    def lratio(self):

        localctx = TransformationAlgebraParser.LratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_lratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.match(TransformationAlgebraParser.DATAFIELD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTERPOL(self):
            return self.getToken(TransformationAlgebraParser.INTERPOL, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lint

        def enterRule(self, listener):
            if hasattr(listener, "enterLint"):
                listener.enterLint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLint"):
                listener.exitLint(self)




    def lint(self):

        localctx = TransformationAlgebraParser.LintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_lint)
        try:
            self.state = 422
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INTERPOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 404
                self.match(TransformationAlgebraParser.INTERPOL)
                self.state = 405
                self.sint()
                self.state = 406
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 407
                self.l()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 409
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 410
                self.lint()
                self.state = 411
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 412
                self.intv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 414
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 415
                self.lint()
                self.state = 416
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 417
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYAVG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 419
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 420
                self.lintl()
                pass
            elif token in [TransformationAlgebraParser.DATAFIELD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 421
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REVERT(self):
            return self.getToken(TransformationAlgebraParser.REVERT, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lord

        def enterRule(self, listener):
            if hasattr(listener, "enterLord"):
                listener.enterLord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLord"):
                listener.exitLord(self)




    def lord(self):

        localctx = TransformationAlgebraParser.LordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_lord)
        try:
            self.state = 440
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 424
                self.match(TransformationAlgebraParser.REVERT)
                self.state = 425
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 426
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 427
                self.lord()
                self.state = 428
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 429
                self.ordv()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 431
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 432
                self.lord()
                self.state = 433
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 434
                self.l()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 436
                self.groupbyaggord()
                self.state = 437
                self.lordl()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 439
                self.lint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnom

        def enterRule(self, listener):
            if hasattr(listener, "enterLnom"):
                listener.enterLnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnom"):
                listener.exitLnom(self)




    def lnom(self):

        localctx = TransformationAlgebraParser.LnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_lnom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            self.lord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lq

        def enterRule(self, listener):
            if hasattr(listener, "enterLq"):
                listener.enterLq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLq"):
                listener.exitLq(self)




    def lq(self):

        localctx = TransformationAlgebraParser.LqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_lq)
        try:
            self.state = 455
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 444
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 445
                self.lq()
                self.state = 446
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 447
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 449
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 450
                self.lq()
                self.state = 451
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 452
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 454
                self.lnom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocounto

        def enterRule(self, listener):
            if hasattr(listener, "enterOcounto"):
                listener.enterOcounto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcounto"):
                listener.exitOcounto(self)




    def ocounto(self):

        localctx = TransformationAlgebraParser.OcountoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_ocounto)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.match(TransformationAlgebraParser.BOWTIESTAR)
            self.state = 458
            self.onomo()
            self.state = 459
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 460
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ODIST(self):
            return self.getToken(TransformationAlgebraParser.ODIST, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def NDIST(self):
            return self.getToken(TransformationAlgebraParser.NDIST, 0)

        def o(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OContext,i)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterOratioo"):
                listener.enterOratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratioo"):
                listener.exitOratioo(self)




    def oratioo(self):

        localctx = TransformationAlgebraParser.OratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_oratioo)
        try:
            self.state = 479
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.ODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 462
                self.match(TransformationAlgebraParser.ODIST)
                self.state = 463
                self.os()
                self.state = 464
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 465
                self.os()
                pass
            elif token in [TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 467
                self.match(TransformationAlgebraParser.NDIST)
                self.state = 468
                self.o()
                self.state = 469
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 470
                self.o()
                self.state = 471
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 472
                self.oratioo()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 474
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 475
                self.onomo()
                self.state = 476
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 477
                self.oratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ointo

        def enterRule(self, listener):
            if hasattr(listener, "enterOinto"):
                listener.enterOinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOinto"):
                listener.exitOinto(self)




    def ointo(self):

        localctx = TransformationAlgebraParser.OintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_ointo)
        try:
            self.state = 487
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 481
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 482
                self.onomo()
                self.state = 483
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 484
                self.oint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 486
                self.oratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oordo

        def enterRule(self, listener):
            if hasattr(listener, "enterOordo"):
                listener.enterOordo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOordo"):
                listener.exitOordo(self)




    def oordo(self):

        localctx = TransformationAlgebraParser.OordoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_oordo)
        try:
            self.state = 495
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 489
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 490
                self.oordo()
                self.state = 491
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 492
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 494
                self.ointo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OTOPO(self):
            return self.getToken(TransformationAlgebraParser.OTOPO, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onomo

        def enterRule(self, listener):
            if hasattr(listener, "enterOnomo"):
                listener.enterOnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnomo"):
                listener.exitOnomo(self)




    def onomo(self):

        localctx = TransformationAlgebraParser.OnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_onomo)
        try:
            self.state = 508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 497
                self.match(TransformationAlgebraParser.OTOPO)
                self.state = 498
                self.os()
                self.state = 499
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 500
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 502
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 503
                self.onomo()
                self.state = 504
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 505
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE2, TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 507
                self.oordo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LODIST(self):
            return self.getToken(TransformationAlgebraParser.LODIST, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterLratioo"):
                listener.enterLratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratioo"):
                listener.exitLratioo(self)




    def lratioo(self):

        localctx = TransformationAlgebraParser.LratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_lratioo)
        try:
            self.state = 520
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 510
                self.match(TransformationAlgebraParser.LODIST)
                self.state = 511
                self.l()
                self.state = 512
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 513
                self.o()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 515
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 516
                self.lnomo()
                self.state = 517
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 518
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_linto

        def enterRule(self, listener):
            if hasattr(listener, "enterLinto"):
                listener.enterLinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinto"):
                listener.exitLinto(self)




    def linto(self):

        localctx = TransformationAlgebraParser.LintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_linto)
        try:
            self.state = 528
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 522
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 523
                self.lnomo()
                self.state = 524
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 525
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 527
                self.lratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LOTOPO(self):
            return self.getToken(TransformationAlgebraParser.LOTOPO, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnomo

        def enterRule(self, listener):
            if hasattr(listener, "enterLnomo"):
                listener.enterLnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnomo"):
                listener.exitLnomo(self)




    def lnomo(self):

        localctx = TransformationAlgebraParser.LnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_lnomo)
        try:
            self.state = 540
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LOTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 530
                self.match(TransformationAlgebraParser.LOTOPO)
                self.state = 531
                self.l()
                self.state = 532
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 533
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 535
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 536
                self.lnomo()
                self.state = 537
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 538
                self.nomv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiolContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiolContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LDIST(self):
            return self.getToken(TransformationAlgebraParser.LDIST, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratiol

        def enterRule(self, listener):
            if hasattr(listener, "enterLratiol"):
                listener.enterLratiol(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratiol"):
                listener.exitLratiol(self)




    def lratiol(self):

        localctx = TransformationAlgebraParser.LratiolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_lratiol)
        try:
            self.state = 552
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 542
                self.match(TransformationAlgebraParser.LDIST)
                self.state = 543
                self.l()
                self.state = 544
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 545
                self.l()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 547
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 548
                self.lnoml()
                self.state = 549
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 550
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratiol(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiolContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lintl

        def enterRule(self, listener):
            if hasattr(listener, "enterLintl"):
                listener.enterLintl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLintl"):
                listener.exitLintl(self)




    def lintl(self):

        localctx = TransformationAlgebraParser.LintlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_lintl)
        try:
            self.state = 560
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 554
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 555
                self.lnoml()
                self.state = 556
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 557
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 559
                self.lratiol()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lordl

        def enterRule(self, listener):
            if hasattr(listener, "enterLordl"):
                listener.enterLordl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLordl"):
                listener.exitLordl(self)




    def lordl(self):

        localctx = TransformationAlgebraParser.LordlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_lordl)
        try:
            self.state = 568
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 562
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 563
                self.lordl()
                self.state = 564
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 565
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 567
                self.lintl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnoml

        def enterRule(self, listener):
            if hasattr(listener, "enterLnoml"):
                listener.enterLnoml(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnoml"):
                listener.exitLnoml(self)




    def lnoml(self):

        localctx = TransformationAlgebraParser.LnomlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_lnoml)
        try:
            self.state = 577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 570
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 571
                self.lnoml()
                self.state = 572
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 573
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 575
                self.lbooll()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 576
                self.lordl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LboollContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LboollContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LVIS(self):
            return self.getToken(TransformationAlgebraParser.LVIS, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def BOOLV(self):
            return self.getToken(TransformationAlgebraParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lbooll

        def enterRule(self, listener):
            if hasattr(listener, "enterLbooll"):
                listener.enterLbooll(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLbooll"):
                listener.exitLbooll(self)




    def lbooll(self):

        localctx = TransformationAlgebraParser.LboollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_lbooll)
        try:
            self.state = 591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LVIS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 579
                self.match(TransformationAlgebraParser.LVIS)
                self.state = 580
                self.l()
                self.state = 581
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 582
                self.l()
                self.state = 583
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 584
                self.oint()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 586
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 587
                self.lbooll()
                self.state = 588
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 589
                self.match(TransformationAlgebraParser.BOOLV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupbyaggordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.GroupbyaggordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GROUPBYMIN(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMIN, 0)

        def GROUPBYMAX(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMAX, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_groupbyaggord

        def enterRule(self, listener):
            if hasattr(listener, "enterGroupbyaggord"):
                listener.enterGroupbyaggord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGroupbyaggord"):
                listener.exitGroupbyaggord(self)




    def groupbyaggord(self):

        localctx = TransformationAlgebraParser.GroupbyaggordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_groupbyaggord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            _la = self._input.LA(1)
            if not(_la==TransformationAlgebraParser.GROUPBYMIN or _la==TransformationAlgebraParser.GROUPBYMAX):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





