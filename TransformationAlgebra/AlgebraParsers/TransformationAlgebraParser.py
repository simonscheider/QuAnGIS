# Generated from TransformationAlgebra.g4 by ANTLR 4.8
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"\67\u0281\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7")
        buf.write(u"\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t")
        buf.write(u"\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22")
        buf.write(u"\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4")
        buf.write(u"\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35")
        buf.write(u"\t\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4")
        buf.write(u"$\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t")
        buf.write(u",\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63")
        buf.write(u"\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\4")
        buf.write(u"9\t9\3\2\3\2\3\2\5\2v\n\2\3\3\3\3\3\3\3\3\5\3|\n\3\3")
        buf.write(u"\4\3\4\3\4\3\4\3\4\5\4\u0083\n\4\3\5\3\5\3\5\3\5\5\5")
        buf.write(u"\u0089\n\5\3\6\3\6\3\6\3\6\3\6\5\6\u0090\n\6\3\7\3\7")
        buf.write(u"\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write(u"\5\7\u00a1\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00ab")
        buf.write(u"\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write(u"\5\t\u00b9\n\t\3\n\3\n\3\n\3\n\3\n\5\n\u00c0\n\n\3\13")
        buf.write(u"\3\13\3\13\5\13\u00c5\n\13\3\f\3\f\3\f\3\f\3\f\3\f\5")
        buf.write(u"\f\u00cd\n\f\3\r\3\r\3\r\3\16\3\16\3\16\5\16\u00d5\n")
        buf.write(u"\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u00e7\n\17\3\20\3")
        buf.write(u"\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u00f3")
        buf.write(u"\n\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3")
        buf.write(u"\21\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u0105\n\21\3\22")
        buf.write(u"\3\22\3\22\3\23\3\23\3\23\3\23\3\23\5\23\u010f\n\23\3")
        buf.write(u"\24\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u0118\n\24\3\25")
        buf.write(u"\3\25\3\25\5\25\u011d\n\25\3\26\3\26\3\26\5\26\u0122")
        buf.write(u"\n\26\3\27\3\27\3\27\5\27\u0127\n\27\3\30\3\30\3\31\3")
        buf.write(u"\31\3\31\3\31\3\31\3\31\3\31\5\31\u0132\n\31\3\32\3\32")
        buf.write(u"\3\33\3\33\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\5")
        buf.write(u"\34\u0140\n\34\3\35\3\35\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write(u"\5\36\u014a\n\36\3\37\3\37\3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(u" \3 \3 \5 \u0159\n \3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!")
        buf.write(u"\3!\3!\3!\3!\3!\3!\5!\u016c\n!\3\"\3\"\3\"\3\"\3\"\3")
        buf.write(u"\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write(u"\"\3\"\5\"\u0182\n\"\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3")
        buf.write(u"#\3#\3#\3#\3#\5#\u0193\n#\3$\3$\3$\3$\3$\3$\3$\3$\3$")
        buf.write(u"\3$\3$\3$\3$\3$\5$\u01a3\n$\3%\3%\3%\3%\3%\3%\5%\u01ab")
        buf.write(u"\n%\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\5&\u01b8\n&\3\'")
        buf.write(u"\3\'\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(")
        buf.write(u"\3(\3(\5(\u01ce\n(\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3")
        buf.write(u")\3)\3)\3)\3)\5)\u01e0\n)\3*\3*\3*\3*\3*\3*\5*\u01e8")
        buf.write(u"\n*\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\5+\u01f5\n+\3,\3")
        buf.write(u",\3,\3,\3,\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-")
        buf.write(u"\3-\3-\3-\5-\u020d\n-\3.\3.\3.\3.\3.\3.\5.\u0215\n.\3")
        buf.write(u"/\3/\3/\3/\3/\3/\5/\u021d\n/\3\60\3\60\3\60\3\60\3\60")
        buf.write(u"\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u022a\n\60\3\61\3")
        buf.write(u"\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\5\61\u0236")
        buf.write(u"\n\61\3\62\3\62\3\62\3\62\3\62\3\62\5\62\u023e\n\62\3")
        buf.write(u"\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\5\63")
        buf.write(u"\u024a\n\63\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3")
        buf.write(u"\64\3\64\5\64\u0256\n\64\3\65\3\65\3\65\3\65\3\65\3\65")
        buf.write(u"\5\65\u025e\n\65\3\66\3\66\3\66\3\66\3\66\3\66\5\66\u0266")
        buf.write(u"\n\66\3\67\3\67\3\67\3\67\3\67\3\67\3\67\5\67\u026f\n")
        buf.write(u"\67\38\38\38\38\38\38\38\38\38\38\38\38\58\u027d\n8\3")
        buf.write(u"9\39\39\2\2:\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 ")
        buf.write(u"\"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp\2")
        buf.write(u"\3\3\2\34\35\2\u02be\2u\3\2\2\2\4{\3\2\2\2\6\u0082\3")
        buf.write(u"\2\2\2\b\u0088\3\2\2\2\n\u008f\3\2\2\2\f\u00a0\3\2\2")
        buf.write(u"\2\16\u00aa\3\2\2\2\20\u00b8\3\2\2\2\22\u00bf\3\2\2\2")
        buf.write(u"\24\u00c4\3\2\2\2\26\u00cc\3\2\2\2\30\u00ce\3\2\2\2\32")
        buf.write(u"\u00d4\3\2\2\2\34\u00e6\3\2\2\2\36\u00f2\3\2\2\2 \u0104")
        buf.write(u"\3\2\2\2\"\u0106\3\2\2\2$\u010e\3\2\2\2&\u0117\3\2\2")
        buf.write(u"\2(\u011c\3\2\2\2*\u0121\3\2\2\2,\u0126\3\2\2\2.\u0128")
        buf.write(u"\3\2\2\2\60\u0131\3\2\2\2\62\u0133\3\2\2\2\64\u0135\3")
        buf.write(u"\2\2\2\66\u013f\3\2\2\28\u0141\3\2\2\2:\u0149\3\2\2\2")
        buf.write(u"<\u014b\3\2\2\2>\u0158\3\2\2\2@\u016b\3\2\2\2B\u0181")
        buf.write(u"\3\2\2\2D\u0192\3\2\2\2F\u01a2\3\2\2\2H\u01aa\3\2\2\2")
        buf.write(u"J\u01b7\3\2\2\2L\u01b9\3\2\2\2N\u01cd\3\2\2\2P\u01df")
        buf.write(u"\3\2\2\2R\u01e7\3\2\2\2T\u01f4\3\2\2\2V\u01f6\3\2\2\2")
        buf.write(u"X\u020c\3\2\2\2Z\u0214\3\2\2\2\\\u021c\3\2\2\2^\u0229")
        buf.write(u"\3\2\2\2`\u0235\3\2\2\2b\u023d\3\2\2\2d\u0249\3\2\2\2")
        buf.write(u"f\u0255\3\2\2\2h\u025d\3\2\2\2j\u0265\3\2\2\2l\u026e")
        buf.write(u"\3\2\2\2n\u027c\3\2\2\2p\u027e\3\2\2\2rv\5\4\3\2sv\5")
        buf.write(u"\6\4\2tv\5\b\5\2ur\3\2\2\2us\3\2\2\2ut\3\2\2\2v\3\3\2")
        buf.write(u"\2\2w|\5\34\17\2x|\5\36\20\2y|\5,\27\2z|\5 \21\2{w\3")
        buf.write(u"\2\2\2{x\3\2\2\2{y\3\2\2\2{z\3\2\2\2|\5\3\2\2\2}\u0083")
        buf.write(u"\5T+\2~\u0083\5\64\33\2\177\u0083\5<\37\2\u0080\u0083")
        buf.write(u"\5J&\2\u0081\u0083\5> \2\u0082}\3\2\2\2\u0082~\3\2\2")
        buf.write(u"\2\u0082\177\3\2\2\2\u0082\u0080\3\2\2\2\u0082\u0081")
        buf.write(u"\3\2\2\2\u0083\7\3\2\2\2\u0084\u0089\5\32\16\2\u0085")
        buf.write(u"\u0089\5\30\r\2\u0086\u0089\5\26\f\2\u0087\u0089\5\24")
        buf.write(u"\13\2\u0088\u0084\3\2\2\2\u0088\u0085\3\2\2\2\u0088\u0086")
        buf.write(u"\3\2\2\2\u0088\u0087\3\2\2\2\u0089\t\3\2\2\2\u008a\u008b")
        buf.write(u"\7\7\2\2\u008b\u0090\5 \21\2\u008c\u008d\7\n\2\2\u008d")
        buf.write(u"\u0090\5\"\22\2\u008e\u0090\7\64\2\2\u008f\u008a\3\2")
        buf.write(u"\2\2\u008f\u008c\3\2\2\2\u008f\u008e\3\2\2\2\u0090\13")
        buf.write(u"\3\2\2\2\u0091\u0092\7\16\2\2\u0092\u00a1\5N(\2\u0093")
        buf.write(u"\u0094\7\20\2\2\u0094\u00a1\5\34\17\2\u0095\u0096\7\21")
        buf.write(u"\2\2\u0096\u0097\5\f\7\2\u0097\u0098\7\65\2\2\u0098\u0099")
        buf.write(u"\5\f\7\2\u0099\u00a1\3\2\2\2\u009a\u009b\7\17\2\2\u009b")
        buf.write(u"\u00a1\5B\"\2\u009c\u009d\7\n\2\2\u009d\u00a1\5$\23\2")
        buf.write(u"\u009e\u00a1\5\n\6\2\u009f\u00a1\7\64\2\2\u00a0\u0091")
        buf.write(u"\3\2\2\2\u00a0\u0093\3\2\2\2\u00a0\u0095\3\2\2\2\u00a0")
        buf.write(u"\u009a\3\2\2\2\u00a0\u009c\3\2\2\2\u00a0\u009e\3\2\2")
        buf.write(u"\2\u00a0\u009f\3\2\2\2\u00a1\r\3\2\2\2\u00a2\u00a3\7")
        buf.write(u"\3\2\2\u00a3\u00ab\5N(\2\u00a4\u00a5\7\3\2\2\u00a5\u00ab")
        buf.write(u"\5D#\2\u00a6\u00ab\5\f\7\2\u00a7\u00a8\7\n\2\2\u00a8")
        buf.write(u"\u00ab\5&\24\2\u00a9\u00ab\7\64\2\2\u00aa\u00a2\3\2\2")
        buf.write(u"\2\u00aa\u00a4\3\2\2\2\u00aa\u00a6\3\2\2\2\u00aa\u00a7")
        buf.write(u"\3\2\2\2\u00aa\u00a9\3\2\2\2\u00ab\17\3\2\2\2\u00ac\u00ad")
        buf.write(u"\7\5\2\2\u00ad\u00b9\5P)\2\u00ae\u00af\7\4\2\2\u00af")
        buf.write(u"\u00b9\5P)\2\u00b0\u00b1\7\5\2\2\u00b1\u00b9\5F$\2\u00b2")
        buf.write(u"\u00b3\7\4\2\2\u00b3\u00b9\5F$\2\u00b4\u00b5\7\n\2\2")
        buf.write(u"\u00b5\u00b9\5(\25\2\u00b6\u00b9\5\16\b\2\u00b7\u00b9")
        buf.write(u"\7\63\2\2\u00b8\u00ac\3\2\2\2\u00b8\u00ae\3\2\2\2\u00b8")
        buf.write(u"\u00b0\3\2\2\2\u00b8\u00b2\3\2\2\2\u00b8\u00b4\3\2\2")
        buf.write(u"\2\u00b8\u00b6\3\2\2\2\u00b8\u00b7\3\2\2\2\u00b9\21\3")
        buf.write(u"\2\2\2\u00ba\u00c0\5\20\t\2\u00bb\u00bc\7\n\2\2\u00bc")
        buf.write(u"\u00c0\5*\26\2\u00bd\u00c0\7\60\2\2\u00be\u00c0\7\62")
        buf.write(u"\2\2\u00bf\u00ba\3\2\2\2\u00bf\u00bb\3\2\2\2\u00bf\u00bd")
        buf.write(u"\3\2\2\2\u00bf\u00be\3\2\2\2\u00c0\23\3\2\2\2\u00c1\u00c2")
        buf.write(u"\7\n\2\2\u00c2\u00c5\5,\27\2\u00c3\u00c5\5\22\n\2\u00c4")
        buf.write(u"\u00c1\3\2\2\2\u00c4\u00c3\3\2\2\2\u00c5\25\3\2\2\2\u00c6")
        buf.write(u"\u00c7\7\b\2\2\u00c7\u00cd\5\34\17\2\u00c8\u00c9\7\n")
        buf.write(u"\2\2\u00c9\u00cd\5\36\20\2\u00ca\u00cb\7\r\2\2\u00cb")
        buf.write(u"\u00cd\5\36\20\2\u00cc\u00c6\3\2\2\2\u00cc\u00c8\3\2")
        buf.write(u"\2\2\u00cc\u00ca\3\2\2\2\u00cd\27\3\2\2\2\u00ce\u00cf")
        buf.write(u"\7\n\2\2\u00cf\u00d0\5\34\17\2\u00d0\31\3\2\2\2\u00d1")
        buf.write(u"\u00d2\7\n\2\2\u00d2\u00d5\5 \21\2\u00d3\u00d5\7,\2\2")
        buf.write(u"\u00d4\u00d1\3\2\2\2\u00d4\u00d3\3\2\2\2\u00d5\33\3\2")
        buf.write(u"\2\2\u00d6\u00d7\7\t\2\2\u00d7\u00e7\5\26\f\2\u00d8\u00d9")
        buf.write(u"\7\23\2\2\u00d9\u00e7\5N(\2\u00da\u00db\7\23\2\2\u00db")
        buf.write(u"\u00e7\5P)\2\u00dc\u00dd\7\23\2\2\u00dd\u00e7\5R*\2\u00de")
        buf.write(u"\u00df\7\23\2\2\u00df\u00e7\5T+\2\u00e0\u00e1\7\23\2")
        buf.write(u"\2\u00e1\u00e7\5L\'\2\u00e2\u00e3\7\23\2\2\u00e3\u00e7")
        buf.write(u"\5b\62\2\u00e4\u00e5\7\23\2\2\u00e5\u00e7\5d\63\2\u00e6")
        buf.write(u"\u00d6\3\2\2\2\u00e6\u00d8\3\2\2\2\u00e6\u00da\3\2\2")
        buf.write(u"\2\u00e6\u00dc\3\2\2\2\u00e6\u00de\3\2\2\2\u00e6\u00e0")
        buf.write(u"\3\2\2\2\u00e6\u00e2\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e7")
        buf.write(u"\35\3\2\2\2\u00e8\u00e9\7\23\2\2\u00e9\u00f3\5.\30\2")
        buf.write(u"\u00ea\u00eb\7\23\2\2\u00eb\u00f3\5\62\32\2\u00ec\u00ed")
        buf.write(u"\7\23\2\2\u00ed\u00f3\5\60\31\2\u00ee\u00ef\7\23\2\2")
        buf.write(u"\u00ef\u00f3\5T+\2\u00f0\u00f1\7\24\2\2\u00f1\u00f3\5")
        buf.write(u"> \2\u00f2\u00e8\3\2\2\2\u00f2\u00ea\3\2\2\2\u00f2\u00ec")
        buf.write(u"\3\2\2\2\u00f2\u00ee\3\2\2\2\u00f2\u00f0\3\2\2\2\u00f3")
        buf.write(u"\37\3\2\2\2\u00f4\u00f5\7\23\2\2\u00f5\u0105\5> \2\u00f6")
        buf.write(u"\u00f7\7\23\2\2\u00f7\u0105\5B\"\2\u00f8\u00f9\7\23\2")
        buf.write(u"\2\u00f9\u0105\5D#\2\u00fa\u00fb\7\23\2\2\u00fb\u0105")
        buf.write(u"\5F$\2\u00fc\u00fd\7\23\2\2\u00fd\u0105\5H%\2\u00fe\u00ff")
        buf.write(u"\7\23\2\2\u00ff\u0105\5J&\2\u0100\u0101\7\23\2\2\u0101")
        buf.write(u"\u0105\5^\60\2\u0102\u0103\7\24\2\2\u0103\u0105\5^\60")
        buf.write(u"\2\u0104\u00f4\3\2\2\2\u0104\u00f6\3\2\2\2\u0104\u00f8")
        buf.write(u"\3\2\2\2\u0104\u00fa\3\2\2\2\u0104\u00fc\3\2\2\2\u0104")
        buf.write(u"\u00fe\3\2\2\2\u0104\u0100\3\2\2\2\u0104\u0102\3\2\2")
        buf.write(u"\2\u0105!\3\2\2\2\u0106\u0107\7\24\2\2\u0107\u0108\5")
        buf.write(u"@!\2\u0108#\3\2\2\2\u0109\u010a\7\24\2\2\u010a\u010f")
        buf.write(u"\5B\"\2\u010b\u010c\7\24\2\2\u010c\u010f\5L\'\2\u010d")
        buf.write(u"\u010f\5\"\22\2\u010e\u0109\3\2\2\2\u010e\u010b\3\2\2")
        buf.write(u"\2\u010e\u010d\3\2\2\2\u010f%\3\2\2\2\u0110\u0111\7\23")
        buf.write(u"\2\2\u0111\u0118\58\35\2\u0112\u0113\7\24\2\2\u0113\u0118")
        buf.write(u"\5D#\2\u0114\u0115\7\24\2\2\u0115\u0118\5N(\2\u0116\u0118")
        buf.write(u"\5$\23\2\u0117\u0110\3\2\2\2\u0117\u0112\3\2\2\2\u0117")
        buf.write(u"\u0114\3\2\2\2\u0117\u0116\3\2\2\2\u0118\'\3\2\2\2\u0119")
        buf.write(u"\u011a\7\23\2\2\u011a\u011d\5\66\34\2\u011b\u011d\5&")
        buf.write(u"\24\2\u011c\u0119\3\2\2\2\u011c\u011b\3\2\2\2\u011d)")
        buf.write(u"\3\2\2\2\u011e\u011f\7\23\2\2\u011f\u0122\5:\36\2\u0120")
        buf.write(u"\u0122\5(\25\2\u0121\u011e\3\2\2\2\u0121\u0120\3\2\2")
        buf.write(u"\2\u0122+\3\2\2\2\u0123\u0124\7\23\2\2\u0124\u0127\5")
        buf.write(u"<\37\2\u0125\u0127\5*\26\2\u0126\u0123\3\2\2\2\u0126")
        buf.write(u"\u0125\3\2\2\2\u0127-\3\2\2\2\u0128\u0129\7\'\2\2\u0129")
        buf.write(u"/\3\2\2\2\u012a\u0132\7(\2\2\u012b\u012c\7\25\2\2\u012c")
        buf.write(u"\u012d\5\60\31\2\u012d\u012e\7\65\2\2\u012e\u012f\5\22")
        buf.write(u"\n\2\u012f\u0132\3\2\2\2\u0130\u0132\5.\30\2\u0131\u012a")
        buf.write(u"\3\2\2\2\u0131\u012b\3\2\2\2\u0131\u0130\3\2\2\2\u0132")
        buf.write(u"\61\3\2\2\2\u0133\u0134\5.\30\2\u0134\63\3\2\2\2\u0135")
        buf.write(u"\u0136\5\60\31\2\u0136\65\3\2\2\2\u0137\u0138\7\13\2")
        buf.write(u"\2\u0138\u0140\5P)\2\u0139\u013a\7\26\2\2\u013a\u013b")
        buf.write(u"\5\66\34\2\u013b\u013c\7\65\2\2\u013c\u013d\5\20\t\2")
        buf.write(u"\u013d\u0140\3\2\2\2\u013e\u0140\7)\2\2\u013f\u0137\3")
        buf.write(u"\2\2\2\u013f\u0139\3\2\2\2\u013f\u013e\3\2\2\2\u0140")
        buf.write(u"\67\3\2\2\2\u0141\u0142\7-\2\2\u01429\3\2\2\2\u0143\u0144")
        buf.write(u"\7\25\2\2\u0144\u0145\5:\36\2\u0145\u0146\7\65\2\2\u0146")
        buf.write(u"\u0147\5\22\n\2\u0147\u014a\3\2\2\2\u0148\u014a\5\66")
        buf.write(u"\34\2\u0149\u0143\3\2\2\2\u0149\u0148\3\2\2\2\u014a;")
        buf.write(u"\3\2\2\2\u014b\u014c\5:\36\2\u014c=\3\2\2\2\u014d\u014e")
        buf.write(u"\7\25\2\2\u014e\u014f\5> \2\u014f\u0150\7\65\2\2\u0150")
        buf.write(u"\u0151\5\32\16\2\u0151\u0159\3\2\2\2\u0152\u0153\7\27")
        buf.write(u"\2\2\u0153\u0154\5> \2\u0154\u0155\7\65\2\2\u0155\u0156")
        buf.write(u"\5 \21\2\u0156\u0159\3\2\2\2\u0157\u0159\7+\2\2\u0158")
        buf.write(u"\u014d\3\2\2\2\u0158\u0152\3\2\2\2\u0158\u0157\3\2\2")
        buf.write(u"\2\u0159?\3\2\2\2\u015a\u015b\7\25\2\2\u015b\u015c\5")
        buf.write(u"@!\2\u015c\u015d\7\65\2\2\u015d\u015e\5\32\16\2\u015e")
        buf.write(u"\u016c\3\2\2\2\u015f\u0160\7\27\2\2\u0160\u0161\5@!\2")
        buf.write(u"\u0161\u0162\7\65\2\2\u0162\u0163\5 \21\2\u0163\u016c")
        buf.write(u"\3\2\2\2\u0164\u0165\7\37\2\2\u0165\u016c\5^\60\2\u0166")
        buf.write(u"\u0167\7\32\2\2\u0167\u016c\5V,\2\u0168\u0169\7\33\2")
        buf.write(u"\2\u0169\u016c\5V,\2\u016a\u016c\7.\2\2\u016b\u015a\3")
        buf.write(u"\2\2\2\u016b\u015f\3\2\2\2\u016b\u0164\3\2\2\2\u016b")
        buf.write(u"\u0166\3\2\2\2\u016b\u0168\3\2\2\2\u016b\u016a\3\2\2")
        buf.write(u"\2\u016cA\3\2\2\2\u016d\u016e\7\27\2\2\u016e\u016f\5")
        buf.write(u"B\"\2\u016f\u0170\7\65\2\2\u0170\u0171\5 \21\2\u0171")
        buf.write(u"\u0182\3\2\2\2\u0172\u0173\7\31\2\2\u0173\u0174\5B\"")
        buf.write(u"\2\u0174\u0175\7\65\2\2\u0175\u0176\5B\"\2\u0176\u0182")
        buf.write(u"\3\2\2\2\u0177\u0178\7\32\2\2\u0178\u0182\5X-\2\u0179")
        buf.write(u"\u017a\7\33\2\2\u017a\u0182\5X-\2\u017b\u017c\7\32\2")
        buf.write(u"\2\u017c\u0182\5`\61\2\u017d\u017e\7\36\2\2\u017e\u0182")
        buf.write(u"\5d\63\2\u017f\u0182\7*\2\2\u0180\u0182\5@!\2\u0181\u016d")
        buf.write(u"\3\2\2\2\u0181\u0172\3\2\2\2\u0181\u0177\3\2\2\2\u0181")
        buf.write(u"\u0179\3\2\2\2\u0181\u017b\3\2\2\2\u0181\u017d\3\2\2")
        buf.write(u"\2\u0181\u017f\3\2\2\2\u0181\u0180\3\2\2\2\u0182C\3\2")
        buf.write(u"\2\2\u0183\u0184\7\26\2\2\u0184\u0185\5D#\2\u0185\u0186")
        buf.write(u"\7\65\2\2\u0186\u0187\5\16\b\2\u0187\u0193\3\2\2\2\u0188")
        buf.write(u"\u0189\7\27\2\2\u0189\u018a\5D#\2\u018a\u018b\7\65\2")
        buf.write(u"\2\u018b\u018c\5 \21\2\u018c\u0193\3\2\2\2\u018d\u018e")
        buf.write(u"\7\32\2\2\u018e\u0193\5Z.\2\u018f\u0190\7\32\2\2\u0190")
        buf.write(u"\u0193\5b\62\2\u0191\u0193\5B\"\2\u0192\u0183\3\2\2\2")
        buf.write(u"\u0192\u0188\3\2\2\2\u0192\u018d\3\2\2\2\u0192\u018f")
        buf.write(u"\3\2\2\2\u0192\u0191\3\2\2\2\u0193E\3\2\2\2\u0194\u0195")
        buf.write(u"\7\26\2\2\u0195\u0196\5F$\2\u0196\u0197\7\65\2\2\u0197")
        buf.write(u"\u0198\5\20\t\2\u0198\u01a3\3\2\2\2\u0199\u019a\7\27")
        buf.write(u"\2\2\u019a\u019b\5F$\2\u019b\u019c\7\65\2\2\u019c\u019d")
        buf.write(u"\5 \21\2\u019d\u01a3\3\2\2\2\u019e\u019f\5p9\2\u019f")
        buf.write(u"\u01a0\5\\/\2\u01a0\u01a3\3\2\2\2\u01a1\u01a3\5D#\2\u01a2")
        buf.write(u"\u0194\3\2\2\2\u01a2\u0199\3\2\2\2\u01a2\u019e\3\2\2")
        buf.write(u"\2\u01a2\u01a1\3\2\2\2\u01a3G\3\2\2\2\u01a4\u01a5\7\25")
        buf.write(u"\2\2\u01a5\u01a6\5H%\2\u01a6\u01a7\7\65\2\2\u01a7\u01a8")
        buf.write(u"\5\22\n\2\u01a8\u01ab\3\2\2\2\u01a9\u01ab\5F$\2\u01aa")
        buf.write(u"\u01a4\3\2\2\2\u01aa\u01a9\3\2\2\2\u01abI\3\2\2\2\u01ac")
        buf.write(u"\u01ad\7\25\2\2\u01ad\u01ae\5J&\2\u01ae\u01af\7\65\2")
        buf.write(u"\2\u01af\u01b0\5\24\13\2\u01b0\u01b8\3\2\2\2\u01b1\u01b2")
        buf.write(u"\7\27\2\2\u01b2\u01b3\5J&\2\u01b3\u01b4\7\65\2\2\u01b4")
        buf.write(u"\u01b5\5 \21\2\u01b5\u01b8\3\2\2\2\u01b6\u01b8\5H%\2")
        buf.write(u"\u01b7\u01ac\3\2\2\2\u01b7\u01b1\3\2\2\2\u01b7\u01b6")
        buf.write(u"\3\2\2\2\u01b8K\3\2\2\2\u01b9\u01ba\7/\2\2\u01baM\3\2")
        buf.write(u"\2\2\u01bb\u01bc\7\22\2\2\u01bc\u01bd\5.\30\2\u01bd\u01be")
        buf.write(u"\7\65\2\2\u01be\u01bf\5\34\17\2\u01bf\u01ce\3\2\2\2\u01c0")
        buf.write(u"\u01c1\7\26\2\2\u01c1\u01c2\5N(\2\u01c2\u01c3\7\65\2")
        buf.write(u"\2\u01c3\u01c4\5\16\b\2\u01c4\u01ce\3\2\2\2\u01c5\u01c6")
        buf.write(u"\7\27\2\2\u01c6\u01c7\5N(\2\u01c7\u01c8\7\65\2\2\u01c8")
        buf.write(u"\u01c9\5\34\17\2\u01c9\u01ce\3\2\2\2\u01ca\u01cb\7\32")
        buf.write(u"\2\2\u01cb\u01ce\5h\65\2\u01cc\u01ce\5L\'\2\u01cd\u01bb")
        buf.write(u"\3\2\2\2\u01cd\u01c0\3\2\2\2\u01cd\u01c5\3\2\2\2\u01cd")
        buf.write(u"\u01ca\3\2\2\2\u01cd\u01cc\3\2\2\2\u01ceO\3\2\2\2\u01cf")
        buf.write(u"\u01d0\7\f\2\2\u01d0\u01e0\5\66\34\2\u01d1\u01d2\7\26")
        buf.write(u"\2\2\u01d2\u01d3\5P)\2\u01d3\u01d4\7\65\2\2\u01d4\u01d5")
        buf.write(u"\5\20\t\2\u01d5\u01e0\3\2\2\2\u01d6\u01d7\7\27\2\2\u01d7")
        buf.write(u"\u01d8\5P)\2\u01d8\u01d9\7\65\2\2\u01d9\u01da\5\34\17")
        buf.write(u"\2\u01da\u01e0\3\2\2\2\u01db\u01dc\5p9\2\u01dc\u01dd")
        buf.write(u"\5j\66\2\u01dd\u01e0\3\2\2\2\u01de\u01e0\5N(\2\u01df")
        buf.write(u"\u01cf\3\2\2\2\u01df\u01d1\3\2\2\2\u01df\u01d6\3\2\2")
        buf.write(u"\2\u01df\u01db\3\2\2\2\u01df\u01de\3\2\2\2\u01e0Q\3\2")
        buf.write(u"\2\2\u01e1\u01e2\7\25\2\2\u01e2\u01e3\5R*\2\u01e3\u01e4")
        buf.write(u"\7\65\2\2\u01e4\u01e5\5\22\n\2\u01e5\u01e8\3\2\2\2\u01e6")
        buf.write(u"\u01e8\5P)\2\u01e7\u01e1\3\2\2\2\u01e7\u01e6\3\2\2\2")
        buf.write(u"\u01e8S\3\2\2\2\u01e9\u01ea\7\25\2\2\u01ea\u01eb\5T+")
        buf.write(u"\2\u01eb\u01ec\7\65\2\2\u01ec\u01ed\5\24\13\2\u01ed\u01f5")
        buf.write(u"\3\2\2\2\u01ee\u01ef\7\27\2\2\u01ef\u01f0\5T+\2\u01f0")
        buf.write(u"\u01f1\7\65\2\2\u01f1\u01f2\5\34\17\2\u01f2\u01f5\3\2")
        buf.write(u"\2\2\u01f3\u01f5\5R*\2\u01f4\u01e9\3\2\2\2\u01f4\u01ee")
        buf.write(u"\3\2\2\2\u01f4\u01f3\3\2\2\2\u01f5U\3\2\2\2\u01f6\u01f7")
        buf.write(u"\7\30\2\2\u01f7\u01f8\5^\60\2\u01f8\u01f9\7\65\2\2\u01f9")
        buf.write(u"\u01fa\5@!\2\u01faW\3\2\2\2\u01fb\u01fc\7 \2\2\u01fc")
        buf.write(u"\u01fd\5> \2\u01fd\u01fe\7\65\2\2\u01fe\u01ff\5> \2\u01ff")
        buf.write(u"\u020d\3\2\2\2\u0200\u0201\7%\2\2\u0201\u0202\5 \21\2")
        buf.write(u"\u0202\u0203\7\65\2\2\u0203\u0204\5 \21\2\u0204\u0205")
        buf.write(u"\7\65\2\2\u0205\u0206\5X-\2\u0206\u020d\3\2\2\2\u0207")
        buf.write(u"\u0208\7\30\2\2\u0208\u0209\5^\60\2\u0209\u020a\7\65")
        buf.write(u"\2\2\u020a\u020b\5B\"\2\u020b\u020d\3\2\2\2\u020c\u01fb")
        buf.write(u"\3\2\2\2\u020c\u0200\3\2\2\2\u020c\u0207\3\2\2\2\u020d")
        buf.write(u"Y\3\2\2\2\u020e\u020f\7\30\2\2\u020f\u0210\5^\60\2\u0210")
        buf.write(u"\u0211\7\65\2\2\u0211\u0212\5D#\2\u0212\u0215\3\2\2\2")
        buf.write(u"\u0213\u0215\5X-\2\u0214\u020e\3\2\2\2\u0214\u0213\3")
        buf.write(u"\2\2\2\u0215[\3\2\2\2\u0216\u0217\7\26\2\2\u0217\u0218")
        buf.write(u"\5\\/\2\u0218\u0219\7\65\2\2\u0219\u021a\5\20\t\2\u021a")
        buf.write(u"\u021d\3\2\2\2\u021b\u021d\5Z.\2\u021c\u0216\3\2\2\2")
        buf.write(u"\u021c\u021b\3\2\2\2\u021d]\3\2\2\2\u021e\u021f\7#\2")
        buf.write(u"\2\u021f\u0220\5> \2\u0220\u0221\7\65\2\2\u0221\u0222")
        buf.write(u"\5> \2\u0222\u022a\3\2\2\2\u0223\u0224\7\25\2\2\u0224")
        buf.write(u"\u0225\5^\60\2\u0225\u0226\7\65\2\2\u0226\u0227\5\22")
        buf.write(u"\n\2\u0227\u022a\3\2\2\2\u0228\u022a\5\\/\2\u0229\u021e")
        buf.write(u"\3\2\2\2\u0229\u0223\3\2\2\2\u0229\u0228\3\2\2\2\u022a")
        buf.write(u"_\3\2\2\2\u022b\u022c\7\"\2\2\u022c\u022d\5\34\17\2\u022d")
        buf.write(u"\u022e\7\65\2\2\u022e\u022f\5 \21\2\u022f\u0236\3\2\2")
        buf.write(u"\2\u0230\u0231\7\30\2\2\u0231\u0232\5d\63\2\u0232\u0233")
        buf.write(u"\7\65\2\2\u0233\u0234\5L\'\2\u0234\u0236\3\2\2\2\u0235")
        buf.write(u"\u022b\3\2\2\2\u0235\u0230\3\2\2\2\u0236a\3\2\2\2\u0237")
        buf.write(u"\u0238\7\30\2\2\u0238\u0239\5d\63\2\u0239\u023a\7\65")
        buf.write(u"\2\2\u023a\u023b\5N(\2\u023b\u023e\3\2\2\2\u023c\u023e")
        buf.write(u"\5`\61\2\u023d\u0237\3\2\2\2\u023d\u023c\3\2\2\2\u023e")
        buf.write(u"c\3\2\2\2\u023f\u0240\7$\2\2\u0240\u0241\5\34\17\2\u0241")
        buf.write(u"\u0242\7\65\2\2\u0242\u0243\5> \2\u0243\u024a\3\2\2\2")
        buf.write(u"\u0244\u0245\7\25\2\2\u0245\u0246\5d\63\2\u0246\u0247")
        buf.write(u"\7\65\2\2\u0247\u0248\5\22\n\2\u0248\u024a\3\2\2\2\u0249")
        buf.write(u"\u023f\3\2\2\2\u0249\u0244\3\2\2\2\u024ae\3\2\2\2\u024b")
        buf.write(u"\u024c\7!\2\2\u024c\u024d\5\34\17\2\u024d\u024e\7\65")
        buf.write(u"\2\2\u024e\u024f\5\34\17\2\u024f\u0256\3\2\2\2\u0250")
        buf.write(u"\u0251\7\30\2\2\u0251\u0252\5l\67\2\u0252\u0253\7\65")
        buf.write(u"\2\2\u0253\u0254\5L\'\2\u0254\u0256\3\2\2\2\u0255\u024b")
        buf.write(u"\3\2\2\2\u0255\u0250\3\2\2\2\u0256g\3\2\2\2\u0257\u0258")
        buf.write(u"\7\30\2\2\u0258\u0259\5l\67\2\u0259\u025a\7\65\2\2\u025a")
        buf.write(u"\u025b\5N(\2\u025b\u025e\3\2\2\2\u025c\u025e\5f\64\2")
        buf.write(u"\u025d\u0257\3\2\2\2\u025d\u025c\3\2\2\2\u025ei\3\2\2")
        buf.write(u"\2\u025f\u0260\7\26\2\2\u0260\u0261\5j\66\2\u0261\u0262")
        buf.write(u"\7\65\2\2\u0262\u0263\5\20\t\2\u0263\u0266\3\2\2\2\u0264")
        buf.write(u"\u0266\5h\65\2\u0265\u025f\3\2\2\2\u0265\u0264\3\2\2")
        buf.write(u"\2\u0266k\3\2\2\2\u0267\u0268\7\25\2\2\u0268\u0269\5")
        buf.write(u"l\67\2\u0269\u026a\7\65\2\2\u026a\u026b\5\22\n\2\u026b")
        buf.write(u"\u026f\3\2\2\2\u026c\u026f\5n8\2\u026d\u026f\5j\66\2")
        buf.write(u"\u026e\u0267\3\2\2\2\u026e\u026c\3\2\2\2\u026e\u026d")
        buf.write(u"\3\2\2\2\u026fm\3\2\2\2\u0270\u0271\7&\2\2\u0271\u0272")
        buf.write(u"\5\34\17\2\u0272\u0273\7\65\2\2\u0273\u0274\5\34\17\2")
        buf.write(u"\u0274\u0275\7\65\2\2\u0275\u0276\5D#\2\u0276\u027d\3")
        buf.write(u"\2\2\2\u0277\u0278\7\25\2\2\u0278\u0279\5n8\2\u0279\u027a")
        buf.write(u"\7\65\2\2\u027a\u027b\7\61\2\2\u027b\u027d\3\2\2\2\u027c")
        buf.write(u"\u0270\3\2\2\2\u027c\u0277\3\2\2\2\u027do\3\2\2\2\u027e")
        buf.write(u"\u027f\t\2\2\2\u027fq\3\2\2\2\60u{\u0082\u0088\u008f")
        buf.write(u"\u00a0\u00aa\u00b8\u00bf\u00c4\u00cc\u00d4\u00e6\u00f2")
        buf.write(u"\u0104\u010e\u0117\u011c\u0121\u0126\u0131\u013f\u0149")
        buf.write(u"\u0158\u016b\u0181\u0192\u01a2\u01aa\u01b7\u01cd\u01df")
        buf.write(u"\u01e7\u01f4\u020c\u0214\u021c\u0229\u0235\u023d\u0249")
        buf.write(u"\u0255\u025d\u0265\u026e\u027c")
        return buf.getvalue()


class TransformationAlgebraParser ( Parser ):

    grammarFileName = "TransformationAlgebra.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'avg '", u"'min '", u"'max '", u"'sum '", 
                     u"'count '", u"'reify '", u"'deify '", u"'get '", u"'invert '", 
                     u"'revert '", u"'merge '", u"'fcont '", u"'ocont '", 
                     u"'size '", u"'ratio '", u"'interpol '", u"'pi1 '", 
                     u"'pi2 '", u"'sigmae '", u"'sigmale '", u"'bowtie '", 
                     u"'bowtie* '", u"'bowtie_ratio '", u"'groupby_avg '", 
                     u"'groupby_sum '", u"'groupby_min '", u"'groupby_max '", 
                     u"'groupby_size '", u"'groupby_count '", u"'odist '", 
                     u"'ldist '", u"'lodist '", u"'otopo '", u"'lotopo '", 
                     u"'ndist '", u"'lvis '", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"'in'", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"' '" ]

    symbolicNames = [ u"<INVALID>", u"AVG", u"MIN", u"MAX", u"SUM", u"COUNT", 
                      u"REIFY", u"DEIFY", u"GET", u"INVERT", u"REVERT", 
                      u"MERGE", u"FCONT", u"OCONT", u"SIZE", u"RATIO", u"INTERPOL", 
                      u"PI1", u"PI2", u"SIGMAE", u"SIGMASE", u"BOWTIE", 
                      u"BOWTIESTAR", u"BOWTIERATIO", u"GROUPBYAVG", u"GROUPBYSUM", 
                      u"GROUPBYMIN", u"GROUPBYMAX", u"GROUPBYSIZE", u"GROUPBYCOUNT", 
                      u"ODIST", u"LDIST", u"LODIST", u"OTOPO", u"LOTOPO", 
                      u"NDIST", u"LVIS", u"DATAPM", u"DATAAMOUNT", u"DATACONTOUR", 
                      u"DATAOBJQ", u"DATAOBJS", u"DATAOBJV", u"DATACONTOURLINE", 
                      u"DATAOBJCOUNT", u"DATAFIELD", u"TOPOV", u"BOOLV", 
                      u"NOMV", u"ORDV", u"DATAV", u"WHITESPACE", u"KEYWORD", 
                      u"WS" ]

    RULE_start = 0
    RULE_r = 1
    RULE_rr = 2
    RULE_v = 3
    RULE_countv = 4
    RULE_ratiov = 5
    RULE_intv = 6
    RULE_ordv = 7
    RULE_nomv = 8
    RULE_qv = 9
    RULE_sv = 10
    RULE_lv = 11
    RULE_ov = 12
    RULE_l = 13
    RULE_s = 14
    RULE_o = 15
    RULE_count = 16
    RULE_ratio = 17
    RULE_intt = 18
    RULE_ordinal = 19
    RULE_nom = 20
    RULE_q = 21
    RULE_sint = 22
    RULE_snom = 23
    RULE_sord = 24
    RULE_sq = 25
    RULE_ords = 26
    RULE_ints = 27
    RULE_noms = 28
    RULE_qs = 29
    RULE_os = 30
    RULE_ocount = 31
    RULE_oratio = 32
    RULE_oint = 33
    RULE_oord = 34
    RULE_onom = 35
    RULE_oq = 36
    RULE_lratio = 37
    RULE_lint = 38
    RULE_lord = 39
    RULE_lnom = 40
    RULE_lq = 41
    RULE_ocounto = 42
    RULE_oratioo = 43
    RULE_ointo = 44
    RULE_oordo = 45
    RULE_onomo = 46
    RULE_lratioo = 47
    RULE_linto = 48
    RULE_lnomo = 49
    RULE_lratiol = 50
    RULE_lintl = 51
    RULE_lordl = 52
    RULE_lnoml = 53
    RULE_lbooll = 54
    RULE_groupbyaggord = 55

    ruleNames =  [ u"start", u"r", u"rr", u"v", u"countv", u"ratiov", u"intv", 
                   u"ordv", u"nomv", u"qv", u"sv", u"lv", u"ov", u"l", u"s", 
                   u"o", u"count", u"ratio", u"intt", u"ordinal", u"nom", 
                   u"q", u"sint", u"snom", u"sord", u"sq", u"ords", u"ints", 
                   u"noms", u"qs", u"os", u"ocount", u"oratio", u"oint", 
                   u"oord", u"onom", u"oq", u"lratio", u"lint", u"lord", 
                   u"lnom", u"lq", u"ocounto", u"oratioo", u"ointo", u"oordo", 
                   u"onomo", u"lratioo", u"linto", u"lnomo", u"lratiol", 
                   u"lintl", u"lordl", u"lnoml", u"lbooll", u"groupbyaggord" ]

    EOF = Token.EOF
    AVG=1
    MIN=2
    MAX=3
    SUM=4
    COUNT=5
    REIFY=6
    DEIFY=7
    GET=8
    INVERT=9
    REVERT=10
    MERGE=11
    FCONT=12
    OCONT=13
    SIZE=14
    RATIO=15
    INTERPOL=16
    PI1=17
    PI2=18
    SIGMAE=19
    SIGMASE=20
    BOWTIE=21
    BOWTIESTAR=22
    BOWTIERATIO=23
    GROUPBYAVG=24
    GROUPBYSUM=25
    GROUPBYMIN=26
    GROUPBYMAX=27
    GROUPBYSIZE=28
    GROUPBYCOUNT=29
    ODIST=30
    LDIST=31
    LODIST=32
    OTOPO=33
    LOTOPO=34
    NDIST=35
    LVIS=36
    DATAPM=37
    DATAAMOUNT=38
    DATACONTOUR=39
    DATAOBJQ=40
    DATAOBJS=41
    DATAOBJV=42
    DATACONTOURLINE=43
    DATAOBJCOUNT=44
    DATAFIELD=45
    TOPOV=46
    BOOLV=47
    NOMV=48
    ORDV=49
    DATAV=50
    WHITESPACE=51
    KEYWORD=52
    WS=53

    def __init__(self, input, output=sys.stdout):
        super(TransformationAlgebraParser, self).__init__(input, output=output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.StartContext, self).__init__(parent, invokingState)
            self.parser = parser

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RrContext,0)


        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.VContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_start

        def enterRule(self, listener):
            if hasattr(listener, "enterStart"):
                listener.enterStart(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStart"):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DEIFY, TransformationAlgebraParser.PI1, TransformationAlgebraParser.PI2]:
                self.state = 112
                self.r()
                pass
            elif token in [TransformationAlgebraParser.INVERT, TransformationAlgebraParser.REVERT, TransformationAlgebraParser.INTERPOL, TransformationAlgebraParser.SIGMAE, TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.BOWTIERATIO, TransformationAlgebraParser.GROUPBYAVG, TransformationAlgebraParser.GROUPBYSUM, TransformationAlgebraParser.GROUPBYMIN, TransformationAlgebraParser.GROUPBYMAX, TransformationAlgebraParser.GROUPBYSIZE, TransformationAlgebraParser.GROUPBYCOUNT, TransformationAlgebraParser.DATAPM, TransformationAlgebraParser.DATAAMOUNT, TransformationAlgebraParser.DATACONTOUR, TransformationAlgebraParser.DATAOBJQ, TransformationAlgebraParser.DATAOBJS, TransformationAlgebraParser.DATAOBJCOUNT, TransformationAlgebraParser.DATAFIELD]:
                self.state = 113
                self.rr()
                pass
            elif token in [TransformationAlgebraParser.AVG, TransformationAlgebraParser.MIN, TransformationAlgebraParser.MAX, TransformationAlgebraParser.COUNT, TransformationAlgebraParser.REIFY, TransformationAlgebraParser.GET, TransformationAlgebraParser.MERGE, TransformationAlgebraParser.FCONT, TransformationAlgebraParser.OCONT, TransformationAlgebraParser.SIZE, TransformationAlgebraParser.RATIO, TransformationAlgebraParser.DATAOBJV, TransformationAlgebraParser.TOPOV, TransformationAlgebraParser.NOMV, TransformationAlgebraParser.ORDV, TransformationAlgebraParser.DATAV]:
                self.state = 114
                self.v()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RContext, self).__init__(parent, invokingState)
            self.parser = parser

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_r

        def enterRule(self, listener):
            if hasattr(listener, "enterR"):
                listener.enterR(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitR"):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_r)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 117
                self.l()
                pass

            elif la_ == 2:
                self.state = 118
                self.s()
                pass

            elif la_ == 3:
                self.state = 119
                self.q()
                pass

            elif la_ == 4:
                self.state = 120
                self.o()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RrContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def sq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SqContext,0)


        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_rr

        def enterRule(self, listener):
            if hasattr(listener, "enterRr"):
                listener.enterRr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRr"):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 123
                self.lq()
                pass

            elif la_ == 2:
                self.state = 124
                self.sq()
                pass

            elif la_ == 3:
                self.state = 125
                self.qs()
                pass

            elif la_ == 4:
                self.state = 126
                self.oq()
                pass

            elif la_ == 5:
                self.state = 127
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.VContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def lv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LvContext,0)


        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_v

        def enterRule(self, listener):
            if hasattr(listener, "enterV"):
                listener.enterV(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitV"):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_v)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 130
                self.ov()
                pass

            elif la_ == 2:
                self.state = 131
                self.lv()
                pass

            elif la_ == 3:
                self.state = 132
                self.sv()
                pass

            elif la_ == 4:
                self.state = 133
                self.qv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(TransformationAlgebraParser.COUNT, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_countv

        def enterRule(self, listener):
            if hasattr(listener, "enterCountv"):
                listener.enterCountv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCountv"):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_countv)
        try:
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.COUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.match(TransformationAlgebraParser.COUNT)
                self.state = 137
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 138
                self.match(TransformationAlgebraParser.GET)
                self.state = 139
                self.count()
                pass
            elif token in [TransformationAlgebraParser.DATAV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 140
                self.match(TransformationAlgebraParser.DATAV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatiovContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatiovContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FCONT(self):
            return self.getToken(TransformationAlgebraParser.FCONT, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def SIZE(self):
            return self.getToken(TransformationAlgebraParser.SIZE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def RATIO(self):
            return self.getToken(TransformationAlgebraParser.RATIO, 0)

        def ratiov(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.RatiovContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountvContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratiov

        def enterRule(self, listener):
            if hasattr(listener, "enterRatiov"):
                listener.enterRatiov(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatiov"):
                listener.exitRatiov(self)




    def ratiov(self):

        localctx = TransformationAlgebraParser.RatiovContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ratiov)
        try:
            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 144
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 145
                self.match(TransformationAlgebraParser.SIZE)
                self.state = 146
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 147
                self.match(TransformationAlgebraParser.RATIO)
                self.state = 148
                self.ratiov()
                self.state = 149
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 150
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 152
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 153
                self.oratio()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 154
                self.match(TransformationAlgebraParser.GET)
                self.state = 155
                self.ratio()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 156
                self.countv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 157
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def ratiov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intv

        def enterRule(self, listener):
            if hasattr(listener, "enterIntv"):
                listener.enterIntv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntv"):
                listener.exitIntv(self)




    def intv(self):

        localctx = TransformationAlgebraParser.IntvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_intv)
        try:
            self.state = 168
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 160
                self.match(TransformationAlgebraParser.AVG)
                self.state = 161
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.match(TransformationAlgebraParser.AVG)
                self.state = 163
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 164
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 165
                self.match(TransformationAlgebraParser.GET)
                self.state = 166
                self.intt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 167
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MAX(self):
            return self.getToken(TransformationAlgebraParser.MAX, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def MIN(self):
            return self.getToken(TransformationAlgebraParser.MIN, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def ORDV(self):
            return self.getToken(TransformationAlgebraParser.ORDV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordv

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdv"):
                listener.enterOrdv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdv"):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ordv)
        try:
            self.state = 182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.match(TransformationAlgebraParser.MAX)
                self.state = 171
                self.lord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 172
                self.match(TransformationAlgebraParser.MIN)
                self.state = 173
                self.lord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 174
                self.match(TransformationAlgebraParser.MAX)
                self.state = 175
                self.oord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 176
                self.match(TransformationAlgebraParser.MIN)
                self.state = 177
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 178
                self.match(TransformationAlgebraParser.GET)
                self.state = 179
                self.ordinal()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 180
                self.intv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 181
                self.match(TransformationAlgebraParser.ORDV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def TOPOV(self):
            return self.getToken(TransformationAlgebraParser.TOPOV, 0)

        def NOMV(self):
            return self.getToken(TransformationAlgebraParser.NOMV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nomv

        def enterRule(self, listener):
            if hasattr(listener, "enterNomv"):
                listener.enterNomv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNomv"):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nomv)
        try:
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 185
                self.match(TransformationAlgebraParser.GET)
                self.state = 186
                self.nom()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 187
                self.match(TransformationAlgebraParser.TOPOV)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 188
                self.match(TransformationAlgebraParser.NOMV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qv

        def enterRule(self, listener):
            if hasattr(listener, "enterQv"):
                listener.enterQv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQv"):
                listener.exitQv(self)




    def qv(self):

        localctx = TransformationAlgebraParser.QvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_qv)
        try:
            self.state = 194
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                self.match(TransformationAlgebraParser.GET)
                self.state = 192
                self.q()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 193
                self.nomv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REIFY(self):
            return self.getToken(TransformationAlgebraParser.REIFY, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def MERGE(self):
            return self.getToken(TransformationAlgebraParser.MERGE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sv

        def enterRule(self, listener):
            if hasattr(listener, "enterSv"):
                listener.enterSv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSv"):
                listener.exitSv(self)




    def sv(self):

        localctx = TransformationAlgebraParser.SvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sv)
        try:
            self.state = 202
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.REIFY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 196
                self.match(TransformationAlgebraParser.REIFY)
                self.state = 197
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 198
                self.match(TransformationAlgebraParser.GET)
                self.state = 199
                self.s()
                pass
            elif token in [TransformationAlgebraParser.MERGE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 200
                self.match(TransformationAlgebraParser.MERGE)
                self.state = 201
                self.s()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lv

        def enterRule(self, listener):
            if hasattr(listener, "enterLv"):
                listener.enterLv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLv"):
                listener.exitLv(self)




    def lv(self):

        localctx = TransformationAlgebraParser.LvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_lv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(TransformationAlgebraParser.GET)
            self.state = 205
            self.l()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJV(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ov

        def enterRule(self, listener):
            if hasattr(listener, "enterOv"):
                listener.enterOv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOv"):
                listener.exitOv(self)




    def ov(self):

        localctx = TransformationAlgebraParser.OvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ov)
        try:
            self.state = 210
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 207
                self.match(TransformationAlgebraParser.GET)
                self.state = 208
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 209
                self.match(TransformationAlgebraParser.DATAOBJV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DEIFY(self):
            return self.getToken(TransformationAlgebraParser.DEIFY, 0)

        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def linto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintoContext,0)


        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_l

        def enterRule(self, listener):
            if hasattr(listener, "enterL"):
                listener.enterL(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitL"):
                listener.exitL(self)




    def l(self):

        localctx = TransformationAlgebraParser.LContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_l)
        try:
            self.state = 228
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 212
                self.match(TransformationAlgebraParser.DEIFY)
                self.state = 213
                self.sv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 214
                self.match(TransformationAlgebraParser.PI1)
                self.state = 215
                self.lint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 216
                self.match(TransformationAlgebraParser.PI1)
                self.state = 217
                self.lord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 218
                self.match(TransformationAlgebraParser.PI1)
                self.state = 219
                self.lnom()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 220
                self.match(TransformationAlgebraParser.PI1)
                self.state = 221
                self.lq()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 222
                self.match(TransformationAlgebraParser.PI1)
                self.state = 223
                self.lratio()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 224
                self.match(TransformationAlgebraParser.PI1)
                self.state = 225
                self.linto()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 226
                self.match(TransformationAlgebraParser.PI1)
                self.state = 227
                self.lnomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def sord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SordContext,0)


        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_s

        def enterRule(self, listener):
            if hasattr(listener, "enterS"):
                listener.enterS(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitS"):
                listener.exitS(self)




    def s(self):

        localctx = TransformationAlgebraParser.SContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_s)
        try:
            self.state = 240
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 230
                self.match(TransformationAlgebraParser.PI1)
                self.state = 231
                self.sint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 232
                self.match(TransformationAlgebraParser.PI1)
                self.state = 233
                self.sord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 234
                self.match(TransformationAlgebraParser.PI1)
                self.state = 235
                self.snom()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 236
                self.match(TransformationAlgebraParser.PI1)
                self.state = 237
                self.lq()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 238
                self.match(TransformationAlgebraParser.PI2)
                self.state = 239
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_o

        def enterRule(self, listener):
            if hasattr(listener, "enterO"):
                listener.enterO(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitO"):
                listener.exitO(self)




    def o(self):

        localctx = TransformationAlgebraParser.OContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_o)
        try:
            self.state = 258
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 242
                self.match(TransformationAlgebraParser.PI1)
                self.state = 243
                self.os()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 244
                self.match(TransformationAlgebraParser.PI1)
                self.state = 245
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 246
                self.match(TransformationAlgebraParser.PI1)
                self.state = 247
                self.oint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 248
                self.match(TransformationAlgebraParser.PI1)
                self.state = 249
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 250
                self.match(TransformationAlgebraParser.PI1)
                self.state = 251
                self.onom()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 252
                self.match(TransformationAlgebraParser.PI1)
                self.state = 253
                self.oq()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 254
                self.match(TransformationAlgebraParser.PI1)
                self.state = 255
                self.onomo()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 256
                self.match(TransformationAlgebraParser.PI2)
                self.state = 257
                self.onomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_count

        def enterRule(self, listener):
            if hasattr(listener, "enterCount"):
                listener.enterCount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCount"):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            self.match(TransformationAlgebraParser.PI2)
            self.state = 261
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratio

        def enterRule(self, listener):
            if hasattr(listener, "enterRatio"):
                listener.enterRatio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatio"):
                listener.exitRatio(self)




    def ratio(self):

        localctx = TransformationAlgebraParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ratio)
        try:
            self.state = 268
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 263
                self.match(TransformationAlgebraParser.PI2)
                self.state = 264
                self.oratio()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 265
                self.match(TransformationAlgebraParser.PI2)
                self.state = 266
                self.lratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 267
                self.count()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InttContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.InttContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ints(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntsContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intt

        def enterRule(self, listener):
            if hasattr(listener, "enterIntt"):
                listener.enterIntt(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntt"):
                listener.exitIntt(self)




    def intt(self):

        localctx = TransformationAlgebraParser.InttContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_intt)
        try:
            self.state = 277
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 270
                self.match(TransformationAlgebraParser.PI1)
                self.state = 271
                self.ints()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 272
                self.match(TransformationAlgebraParser.PI2)
                self.state = 273
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 274
                self.match(TransformationAlgebraParser.PI2)
                self.state = 275
                self.lint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 276
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdinalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdinalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordinal

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdinal"):
                listener.enterOrdinal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdinal"):
                listener.exitOrdinal(self)




    def ordinal(self):

        localctx = TransformationAlgebraParser.OrdinalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordinal)
        try:
            self.state = 282
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 279
                self.match(TransformationAlgebraParser.PI1)
                self.state = 280
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 281
                self.intt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nom

        def enterRule(self, listener):
            if hasattr(listener, "enterNom"):
                listener.enterNom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNom"):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_nom)
        try:
            self.state = 287
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 284
                self.match(TransformationAlgebraParser.PI1)
                self.state = 285
                self.noms()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 286
                self.ordinal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_q

        def enterRule(self, listener):
            if hasattr(listener, "enterQ"):
                listener.enterQ(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQ"):
                listener.exitQ(self)




    def q(self):

        localctx = TransformationAlgebraParser.QContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_q)
        try:
            self.state = 292
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 289
                self.match(TransformationAlgebraParser.PI1)
                self.state = 290
                self.qs()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 291
                self.nom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAPM(self):
            return self.getToken(TransformationAlgebraParser.DATAPM, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sint

        def enterRule(self, listener):
            if hasattr(listener, "enterSint"):
                listener.enterSint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSint"):
                listener.exitSint(self)




    def sint(self):

        localctx = TransformationAlgebraParser.SintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(TransformationAlgebraParser.DATAPM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAAMOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAAMOUNT, 0)

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_snom

        def enterRule(self, listener):
            if hasattr(listener, "enterSnom"):
                listener.enterSnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSnom"):
                listener.exitSnom(self)




    def snom(self):

        localctx = TransformationAlgebraParser.SnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_snom)
        try:
            self.state = 303
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DATAAMOUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 296
                self.match(TransformationAlgebraParser.DATAAMOUNT)
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 297
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 298
                self.snom()
                self.state = 299
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 300
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.DATAPM]:
                self.enterOuterAlt(localctx, 3)
                self.state = 302
                self.sint()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sord

        def enterRule(self, listener):
            if hasattr(listener, "enterSord"):
                listener.enterSord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSord"):
                listener.exitSord(self)




    def sord(self):

        localctx = TransformationAlgebraParser.SordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_sord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.sint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sq

        def enterRule(self, listener):
            if hasattr(listener, "enterSq"):
                listener.enterSq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSq"):
                listener.exitSq(self)




    def sq(self):

        localctx = TransformationAlgebraParser.SqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self.snom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INVERT(self):
            return self.getToken(TransformationAlgebraParser.INVERT, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def DATACONTOUR(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOUR, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ords

        def enterRule(self, listener):
            if hasattr(listener, "enterOrds"):
                listener.enterOrds(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrds"):
                listener.exitOrds(self)




    def ords(self):

        localctx = TransformationAlgebraParser.OrdsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_ords)
        try:
            self.state = 317
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INVERT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 309
                self.match(TransformationAlgebraParser.INVERT)
                self.state = 310
                self.lord()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 311
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 312
                self.ords()
                self.state = 313
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 314
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.DATACONTOUR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 316
                self.match(TransformationAlgebraParser.DATACONTOUR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOURLINE(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOURLINE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ints

        def enterRule(self, listener):
            if hasattr(listener, "enterInts"):
                listener.enterInts(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInts"):
                listener.exitInts(self)




    def ints(self):

        localctx = TransformationAlgebraParser.IntsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.match(TransformationAlgebraParser.DATACONTOURLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_noms

        def enterRule(self, listener):
            if hasattr(listener, "enterNoms"):
                listener.enterNoms(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNoms"):
                listener.exitNoms(self)




    def noms(self):

        localctx = TransformationAlgebraParser.NomsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_noms)
        try:
            self.state = 327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 321
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 322
                self.noms()
                self.state = 323
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 324
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.INVERT, TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.DATACONTOUR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 326
                self.ords()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qs

        def enterRule(self, listener):
            if hasattr(listener, "enterQs"):
                listener.enterQs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQs"):
                listener.exitQs(self)




    def qs(self):

        localctx = TransformationAlgebraParser.QsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_qs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self.noms()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJS(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJS, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_os

        def enterRule(self, listener):
            if hasattr(listener, "enterOs"):
                listener.enterOs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOs"):
                listener.exitOs(self)




    def os(self):

        localctx = TransformationAlgebraParser.OsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_os)
        try:
            self.state = 342
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 331
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 332
                self.os()
                self.state = 333
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 334
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 336
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 337
                self.os()
                self.state = 338
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 339
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 341
                self.match(TransformationAlgebraParser.DATAOBJS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYCOUNT(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYCOUNT, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def ocounto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountoContext,0)


        def GROUPBYSUM(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSUM, 0)

        def DATAOBJCOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJCOUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocount

        def enterRule(self, listener):
            if hasattr(listener, "enterOcount"):
                listener.enterOcount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcount"):
                listener.exitOcount(self)




    def ocount(self):

        localctx = TransformationAlgebraParser.OcountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_ocount)
        try:
            self.state = 361
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 344
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 345
                self.ocount()
                self.state = 346
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 347
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 349
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 350
                self.ocount()
                self.state = 351
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 352
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYCOUNT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 354
                self.match(TransformationAlgebraParser.GROUPBYCOUNT)
                self.state = 355
                self.onomo()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYAVG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 356
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 357
                self.ocounto()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYSUM]:
                self.enterOuterAlt(localctx, 5)
                self.state = 358
                self.match(TransformationAlgebraParser.GROUPBYSUM)
                self.state = 359
                self.ocounto()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJCOUNT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 360
                self.match(TransformationAlgebraParser.DATAOBJCOUNT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def oratio(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OratioContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def BOWTIERATIO(self):
            return self.getToken(TransformationAlgebraParser.BOWTIERATIO, 0)

        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def GROUPBYSUM(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSUM, 0)

        def lratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiooContext,0)


        def GROUPBYSIZE(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSIZE, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def DATAOBJQ(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJQ, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratio

        def enterRule(self, listener):
            if hasattr(listener, "enterOratio"):
                listener.enterOratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratio"):
                listener.exitOratio(self)




    def oratio(self):

        localctx = TransformationAlgebraParser.OratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_oratio)
        try:
            self.state = 383
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 363
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 364
                self.oratio()
                self.state = 365
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 366
                self.o()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 368
                self.match(TransformationAlgebraParser.BOWTIERATIO)
                self.state = 369
                self.oratio()
                self.state = 370
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 371
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 373
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 374
                self.oratioo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 375
                self.match(TransformationAlgebraParser.GROUPBYSUM)
                self.state = 376
                self.oratioo()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 377
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 378
                self.lratioo()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 379
                self.match(TransformationAlgebraParser.GROUPBYSIZE)
                self.state = 380
                self.lnomo()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 381
                self.match(TransformationAlgebraParser.DATAOBJQ)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 382
                self.ocount()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def linto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oint

        def enterRule(self, listener):
            if hasattr(listener, "enterOint"):
                listener.enterOint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOint"):
                listener.exitOint(self)




    def oint(self):

        localctx = TransformationAlgebraParser.OintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_oint)
        try:
            self.state = 400
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 385
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 386
                self.oint()
                self.state = 387
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 388
                self.intv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 390
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 391
                self.oint()
                self.state = 392
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 393
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 395
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 396
                self.ointo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 397
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 398
                self.linto()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 399
                self.oratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oord

        def enterRule(self, listener):
            if hasattr(listener, "enterOord"):
                listener.enterOord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOord"):
                listener.exitOord(self)




    def oord(self):

        localctx = TransformationAlgebraParser.OordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_oord)
        try:
            self.state = 416
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 402
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 403
                self.oord()
                self.state = 404
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 405
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 407
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 408
                self.oord()
                self.state = 409
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 410
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 412
                self.groupbyaggord()
                self.state = 413
                self.oordo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 415
                self.oint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onom

        def enterRule(self, listener):
            if hasattr(listener, "enterOnom"):
                listener.enterOnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnom"):
                listener.exitOnom(self)




    def onom(self):

        localctx = TransformationAlgebraParser.OnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_onom)
        try:
            self.state = 424
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 418
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 419
                self.onom()
                self.state = 420
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 421
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 423
                self.oord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oq

        def enterRule(self, listener):
            if hasattr(listener, "enterOq"):
                listener.enterOq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOq"):
                listener.exitOq(self)




    def oq(self):

        localctx = TransformationAlgebraParser.OqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_oq)
        try:
            self.state = 437
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 426
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 427
                self.oq()
                self.state = 428
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 429
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 431
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 432
                self.oq()
                self.state = 433
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 434
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 436
                self.onom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAFIELD(self):
            return self.getToken(TransformationAlgebraParser.DATAFIELD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratio

        def enterRule(self, listener):
            if hasattr(listener, "enterLratio"):
                listener.enterLratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratio"):
                listener.exitLratio(self)




    def lratio(self):

        localctx = TransformationAlgebraParser.LratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_lratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            self.match(TransformationAlgebraParser.DATAFIELD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTERPOL(self):
            return self.getToken(TransformationAlgebraParser.INTERPOL, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lint

        def enterRule(self, listener):
            if hasattr(listener, "enterLint"):
                listener.enterLint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLint"):
                listener.exitLint(self)




    def lint(self):

        localctx = TransformationAlgebraParser.LintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_lint)
        try:
            self.state = 459
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INTERPOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 441
                self.match(TransformationAlgebraParser.INTERPOL)
                self.state = 442
                self.sint()
                self.state = 443
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 444
                self.l()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 446
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 447
                self.lint()
                self.state = 448
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 449
                self.intv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 451
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 452
                self.lint()
                self.state = 453
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 454
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYAVG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 456
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 457
                self.lintl()
                pass
            elif token in [TransformationAlgebraParser.DATAFIELD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 458
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REVERT(self):
            return self.getToken(TransformationAlgebraParser.REVERT, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lord

        def enterRule(self, listener):
            if hasattr(listener, "enterLord"):
                listener.enterLord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLord"):
                listener.exitLord(self)




    def lord(self):

        localctx = TransformationAlgebraParser.LordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_lord)
        try:
            self.state = 477
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 461
                self.match(TransformationAlgebraParser.REVERT)
                self.state = 462
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 463
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 464
                self.lord()
                self.state = 465
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 466
                self.ordv()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 468
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 469
                self.lord()
                self.state = 470
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 471
                self.l()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 473
                self.groupbyaggord()
                self.state = 474
                self.lordl()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 476
                self.lint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnom

        def enterRule(self, listener):
            if hasattr(listener, "enterLnom"):
                listener.enterLnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnom"):
                listener.exitLnom(self)




    def lnom(self):

        localctx = TransformationAlgebraParser.LnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_lnom)
        try:
            self.state = 485
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 479
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 480
                self.lnom()
                self.state = 481
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 482
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.REVERT, TransformationAlgebraParser.INTERPOL, TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.GROUPBYAVG, TransformationAlgebraParser.GROUPBYMIN, TransformationAlgebraParser.GROUPBYMAX, TransformationAlgebraParser.DATAFIELD]:
                self.enterOuterAlt(localctx, 2)
                self.state = 484
                self.lord()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lq

        def enterRule(self, listener):
            if hasattr(listener, "enterLq"):
                listener.enterLq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLq"):
                listener.exitLq(self)




    def lq(self):

        localctx = TransformationAlgebraParser.LqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_lq)
        try:
            self.state = 498
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 487
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 488
                self.lq()
                self.state = 489
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 490
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 492
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 493
                self.lq()
                self.state = 494
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 495
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 497
                self.lnom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocounto

        def enterRule(self, listener):
            if hasattr(listener, "enterOcounto"):
                listener.enterOcounto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcounto"):
                listener.exitOcounto(self)




    def ocounto(self):

        localctx = TransformationAlgebraParser.OcountoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_ocounto)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 500
            self.match(TransformationAlgebraParser.BOWTIESTAR)
            self.state = 501
            self.onomo()
            self.state = 502
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 503
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ODIST(self):
            return self.getToken(TransformationAlgebraParser.ODIST, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def NDIST(self):
            return self.getToken(TransformationAlgebraParser.NDIST, 0)

        def o(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OContext,i)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterOratioo"):
                listener.enterOratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratioo"):
                listener.exitOratioo(self)




    def oratioo(self):

        localctx = TransformationAlgebraParser.OratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_oratioo)
        try:
            self.state = 522
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.ODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 505
                self.match(TransformationAlgebraParser.ODIST)
                self.state = 506
                self.os()
                self.state = 507
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 508
                self.os()
                pass
            elif token in [TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 510
                self.match(TransformationAlgebraParser.NDIST)
                self.state = 511
                self.o()
                self.state = 512
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 513
                self.o()
                self.state = 514
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 515
                self.oratioo()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 517
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 518
                self.onomo()
                self.state = 519
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 520
                self.oratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ointo

        def enterRule(self, listener):
            if hasattr(listener, "enterOinto"):
                listener.enterOinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOinto"):
                listener.exitOinto(self)




    def ointo(self):

        localctx = TransformationAlgebraParser.OintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_ointo)
        try:
            self.state = 530
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 524
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 525
                self.onomo()
                self.state = 526
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 527
                self.oint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 529
                self.oratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oordo

        def enterRule(self, listener):
            if hasattr(listener, "enterOordo"):
                listener.enterOordo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOordo"):
                listener.exitOordo(self)




    def oordo(self):

        localctx = TransformationAlgebraParser.OordoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_oordo)
        try:
            self.state = 538
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 532
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 533
                self.oordo()
                self.state = 534
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 535
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 537
                self.ointo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OTOPO(self):
            return self.getToken(TransformationAlgebraParser.OTOPO, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onomo

        def enterRule(self, listener):
            if hasattr(listener, "enterOnomo"):
                listener.enterOnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnomo"):
                listener.exitOnomo(self)




    def onomo(self):

        localctx = TransformationAlgebraParser.OnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_onomo)
        try:
            self.state = 551
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 540
                self.match(TransformationAlgebraParser.OTOPO)
                self.state = 541
                self.os()
                self.state = 542
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 543
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 545
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 546
                self.onomo()
                self.state = 547
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 548
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 550
                self.oordo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LODIST(self):
            return self.getToken(TransformationAlgebraParser.LODIST, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterLratioo"):
                listener.enterLratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratioo"):
                listener.exitLratioo(self)




    def lratioo(self):

        localctx = TransformationAlgebraParser.LratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_lratioo)
        try:
            self.state = 563
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 553
                self.match(TransformationAlgebraParser.LODIST)
                self.state = 554
                self.l()
                self.state = 555
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 556
                self.o()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 558
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 559
                self.lnomo()
                self.state = 560
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 561
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_linto

        def enterRule(self, listener):
            if hasattr(listener, "enterLinto"):
                listener.enterLinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinto"):
                listener.exitLinto(self)




    def linto(self):

        localctx = TransformationAlgebraParser.LintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_linto)
        try:
            self.state = 571
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 565
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 566
                self.lnomo()
                self.state = 567
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 568
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 570
                self.lratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LOTOPO(self):
            return self.getToken(TransformationAlgebraParser.LOTOPO, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnomo

        def enterRule(self, listener):
            if hasattr(listener, "enterLnomo"):
                listener.enterLnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnomo"):
                listener.exitLnomo(self)




    def lnomo(self):

        localctx = TransformationAlgebraParser.LnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_lnomo)
        try:
            self.state = 583
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LOTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 573
                self.match(TransformationAlgebraParser.LOTOPO)
                self.state = 574
                self.l()
                self.state = 575
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 576
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 578
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 579
                self.lnomo()
                self.state = 580
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 581
                self.nomv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiolContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiolContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LDIST(self):
            return self.getToken(TransformationAlgebraParser.LDIST, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratiol

        def enterRule(self, listener):
            if hasattr(listener, "enterLratiol"):
                listener.enterLratiol(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratiol"):
                listener.exitLratiol(self)




    def lratiol(self):

        localctx = TransformationAlgebraParser.LratiolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_lratiol)
        try:
            self.state = 595
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 585
                self.match(TransformationAlgebraParser.LDIST)
                self.state = 586
                self.l()
                self.state = 587
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 588
                self.l()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 590
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 591
                self.lnoml()
                self.state = 592
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 593
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratiol(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiolContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lintl

        def enterRule(self, listener):
            if hasattr(listener, "enterLintl"):
                listener.enterLintl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLintl"):
                listener.exitLintl(self)




    def lintl(self):

        localctx = TransformationAlgebraParser.LintlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_lintl)
        try:
            self.state = 603
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 597
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 598
                self.lnoml()
                self.state = 599
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 600
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 602
                self.lratiol()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lordl

        def enterRule(self, listener):
            if hasattr(listener, "enterLordl"):
                listener.enterLordl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLordl"):
                listener.exitLordl(self)




    def lordl(self):

        localctx = TransformationAlgebraParser.LordlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_lordl)
        try:
            self.state = 611
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 605
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 606
                self.lordl()
                self.state = 607
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 608
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 610
                self.lintl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnoml

        def enterRule(self, listener):
            if hasattr(listener, "enterLnoml"):
                listener.enterLnoml(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnoml"):
                listener.exitLnoml(self)




    def lnoml(self):

        localctx = TransformationAlgebraParser.LnomlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_lnoml)
        try:
            self.state = 620
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 613
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 614
                self.lnoml()
                self.state = 615
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 616
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 618
                self.lbooll()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 619
                self.lordl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LboollContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LboollContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LVIS(self):
            return self.getToken(TransformationAlgebraParser.LVIS, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def BOOLV(self):
            return self.getToken(TransformationAlgebraParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lbooll

        def enterRule(self, listener):
            if hasattr(listener, "enterLbooll"):
                listener.enterLbooll(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLbooll"):
                listener.exitLbooll(self)




    def lbooll(self):

        localctx = TransformationAlgebraParser.LboollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_lbooll)
        try:
            self.state = 634
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LVIS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 622
                self.match(TransformationAlgebraParser.LVIS)
                self.state = 623
                self.l()
                self.state = 624
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 625
                self.l()
                self.state = 626
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 627
                self.oint()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 629
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 630
                self.lbooll()
                self.state = 631
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 632
                self.match(TransformationAlgebraParser.BOOLV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupbyaggordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.GroupbyaggordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GROUPBYMIN(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMIN, 0)

        def GROUPBYMAX(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMAX, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_groupbyaggord

        def enterRule(self, listener):
            if hasattr(listener, "enterGroupbyaggord"):
                listener.enterGroupbyaggord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGroupbyaggord"):
                listener.exitGroupbyaggord(self)




    def groupbyaggord(self):

        localctx = TransformationAlgebraParser.GroupbyaggordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_groupbyaggord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 636
            _la = self._input.LA(1)
            if not(_la==TransformationAlgebraParser.GROUPBYMIN or _la==TransformationAlgebraParser.GROUPBYMAX):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





