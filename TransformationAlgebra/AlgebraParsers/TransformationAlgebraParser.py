# Generated from TransformationAlgebra.g4 by ANTLR 4.8
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"9\u0289\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t")
        buf.write(u"\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$")
        buf.write(u"\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t")
        buf.write(u",\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63")
        buf.write(u"\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\4")
        buf.write(u"9\t9\3\2\3\2\3\2\5\2v\n\2\3\3\3\3\3\3\3\3\5\3|\n\3\3")
        buf.write(u"\4\3\4\3\4\3\4\3\4\5\4\u0083\n\4\3\5\3\5\3\5\3\5\5\5")
        buf.write(u"\u0089\n\5\3\6\3\6\3\6\3\6\3\6\5\6\u0090\n\6\3\7\3\7")
        buf.write(u"\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write(u"\5\7\u00a1\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00ab")
        buf.write(u"\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write(u"\5\t\u00b9\n\t\3\n\3\n\3\n\3\n\3\n\5\n\u00c0\n\n\3\13")
        buf.write(u"\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u00c9\n\13\3\f\3")
        buf.write(u"\f\3\f\3\f\3\f\3\f\5\f\u00d1\n\f\3\r\3\r\3\r\3\16\3\16")
        buf.write(u"\3\16\5\16\u00d9\n\16\3\17\3\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17")
        buf.write(u"\u00eb\n\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3")
        buf.write(u"\20\3\20\5\20\u00f7\n\20\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write(u"\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\5")
        buf.write(u"\21\u0109\n\21\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23")
        buf.write(u"\5\23\u0113\n\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\5")
        buf.write(u"\24\u011c\n\24\3\25\3\25\3\25\5\25\u0121\n\25\3\26\3")
        buf.write(u"\26\3\26\5\26\u0126\n\26\3\27\3\27\3\27\5\27\u012b\n")
        buf.write(u"\27\3\30\3\30\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31")
        buf.write(u"\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\5")
        buf.write(u"\31\u0141\n\31\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write(u"\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u0153\n")
        buf.write(u"\32\3\33\3\33\3\33\3\33\3\33\3\33\3\33\3\33\5\33\u015d")
        buf.write(u"\n\33\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3")
        buf.write(u"\34\3\34\5\34\u016a\n\34\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write(u"\3\35\3\35\5\35\u0174\n\35\3\36\3\36\3\37\3\37\3\37\3")
        buf.write(u"\37\3\37\3\37\5\37\u017e\n\37\3 \3 \3!\3!\3\"\3\"\3#")
        buf.write(u"\3#\3#\3#\3#\3#\3#\3#\3#\5#\u018f\n#\3$\3$\3%\3%\3%\3")
        buf.write(u"%\3%\3%\3%\3%\3%\3%\3%\5%\u019e\n%\3&\3&\3&\3&\3&\3&")
        buf.write(u"\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\3&\5&\u01b1\n&\3\'\3\'")
        buf.write(u"\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'")
        buf.write(u"\3\'\3\'\3\'\3\'\3\'\5\'\u01c7\n\'\3(\3(\3(\3(\3(\3(")
        buf.write(u"\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u01d8\n(\3)\3)\3)\3)\3")
        buf.write(u")\3)\3)\3)\3)\3)\3)\3)\3)\3)\5)\u01e8\n)\3*\3*\3*\3*")
        buf.write(u"\3*\3*\5*\u01f0\n*\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\5")
        buf.write(u"+\u01fd\n+\3,\3,\3,\3,\3,\3-\3-\3-\3-\3-\3-\3-\3-\3-")
        buf.write(u"\3-\3-\3-\3-\3-\3-\3-\3-\5-\u0215\n-\3.\3.\3.\3.\3.\3")
        buf.write(u".\5.\u021d\n.\3/\3/\3/\3/\3/\3/\5/\u0225\n/\3\60\3\60")
        buf.write(u"\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u0232")
        buf.write(u"\n\60\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3\61\3")
        buf.write(u"\61\5\61\u023e\n\61\3\62\3\62\3\62\3\62\3\62\3\62\5\62")
        buf.write(u"\u0246\n\62\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3")
        buf.write(u"\63\3\63\5\63\u0252\n\63\3\64\3\64\3\64\3\64\3\64\3\64")
        buf.write(u"\3\64\3\64\3\64\3\64\5\64\u025e\n\64\3\65\3\65\3\65\3")
        buf.write(u"\65\3\65\3\65\5\65\u0266\n\65\3\66\3\66\3\66\3\66\3\66")
        buf.write(u"\3\66\5\66\u026e\n\66\3\67\3\67\3\67\3\67\3\67\3\67\3")
        buf.write(u"\67\5\67\u0277\n\67\38\38\38\38\38\38\38\38\38\38\38")
        buf.write(u"\38\58\u0285\n8\39\39\39\2\2:\2\4\6\b\n\f\16\20\22\24")
        buf.write(u"\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTV")
        buf.write(u"XZ\\^`bdfhjlnp\2\3\3\2\32\33\2\u02cc\2u\3\2\2\2\4{\3")
        buf.write(u"\2\2\2\6\u0082\3\2\2\2\b\u0088\3\2\2\2\n\u008f\3\2\2")
        buf.write(u"\2\f\u00a0\3\2\2\2\16\u00aa\3\2\2\2\20\u00b8\3\2\2\2")
        buf.write(u"\22\u00bf\3\2\2\2\24\u00c8\3\2\2\2\26\u00d0\3\2\2\2\30")
        buf.write(u"\u00d2\3\2\2\2\32\u00d8\3\2\2\2\34\u00ea\3\2\2\2\36\u00f6")
        buf.write(u"\3\2\2\2 \u0108\3\2\2\2\"\u010a\3\2\2\2$\u0112\3\2\2")
        buf.write(u"\2&\u011b\3\2\2\2(\u0120\3\2\2\2*\u0125\3\2\2\2,\u012a")
        buf.write(u"\3\2\2\2.\u012c\3\2\2\2\60\u0140\3\2\2\2\62\u0152\3\2")
        buf.write(u"\2\2\64\u015c\3\2\2\2\66\u0169\3\2\2\28\u0173\3\2\2\2")
        buf.write(u":\u0175\3\2\2\2<\u017d\3\2\2\2>\u017f\3\2\2\2@\u0181")
        buf.write(u"\3\2\2\2B\u0183\3\2\2\2D\u018e\3\2\2\2F\u0190\3\2\2\2")
        buf.write(u"H\u019d\3\2\2\2J\u01b0\3\2\2\2L\u01c6\3\2\2\2N\u01d7")
        buf.write(u"\3\2\2\2P\u01e7\3\2\2\2R\u01ef\3\2\2\2T\u01fc\3\2\2\2")
        buf.write(u"V\u01fe\3\2\2\2X\u0214\3\2\2\2Z\u021c\3\2\2\2\\\u0224")
        buf.write(u"\3\2\2\2^\u0231\3\2\2\2`\u023d\3\2\2\2b\u0245\3\2\2\2")
        buf.write(u"d\u0251\3\2\2\2f\u025d\3\2\2\2h\u0265\3\2\2\2j\u026d")
        buf.write(u"\3\2\2\2l\u0276\3\2\2\2n\u0284\3\2\2\2p\u0286\3\2\2\2")
        buf.write(u"rv\5\4\3\2sv\5\6\4\2tv\5\b\5\2ur\3\2\2\2us\3\2\2\2ut")
        buf.write(u"\3\2\2\2v\3\3\2\2\2w|\5\34\17\2x|\5\36\20\2y|\5,\27\2")
        buf.write(u"z|\5 \21\2{w\3\2\2\2{x\3\2\2\2{y\3\2\2\2{z\3\2\2\2|\5")
        buf.write(u"\3\2\2\2}\u0083\5\66\34\2~\u0083\5F$\2\177\u0083\5> ")
        buf.write(u"\2\u0080\u0083\5T+\2\u0081\u0083\5H%\2\u0082}\3\2\2\2")
        buf.write(u"\u0082~\3\2\2\2\u0082\177\3\2\2\2\u0082\u0080\3\2\2\2")
        buf.write(u"\u0082\u0081\3\2\2\2\u0083\7\3\2\2\2\u0084\u0089\5\32")
        buf.write(u"\16\2\u0085\u0089\5\30\r\2\u0086\u0089\5\26\f\2\u0087")
        buf.write(u"\u0089\5\24\13\2\u0088\u0084\3\2\2\2\u0088\u0085\3\2")
        buf.write(u"\2\2\u0088\u0086\3\2\2\2\u0088\u0087\3\2\2\2\u0089\t")
        buf.write(u"\3\2\2\2\u008a\u008b\7\7\2\2\u008b\u0090\5 \21\2\u008c")
        buf.write(u"\u008d\7\f\2\2\u008d\u0090\5\"\22\2\u008e\u0090\7\60")
        buf.write(u"\2\2\u008f\u008a\3\2\2\2\u008f\u008c\3\2\2\2\u008f\u008e")
        buf.write(u"\3\2\2\2\u0090\13\3\2\2\2\u0091\u0092\7\17\2\2\u0092")
        buf.write(u"\u00a1\5\60\31\2\u0093\u0094\7\b\2\2\u0094\u00a1\5\34")
        buf.write(u"\17\2\u0095\u0096\7\3\2\2\u0096\u0097\5\f\7\2\u0097\u0098")
        buf.write(u"\7\67\2\2\u0098\u0099\5\f\7\2\u0099\u00a1\3\2\2\2\u009a")
        buf.write(u"\u009b\7\20\2\2\u009b\u00a1\5L\'\2\u009c\u009d\7\f\2")
        buf.write(u"\2\u009d\u00a1\5$\23\2\u009e\u00a1\5\n\6\2\u009f\u00a1")
        buf.write(u"\7\61\2\2\u00a0\u0091\3\2\2\2\u00a0\u0093\3\2\2\2\u00a0")
        buf.write(u"\u0095\3\2\2\2\u00a0\u009a\3\2\2\2\u00a0\u009c\3\2\2")
        buf.write(u"\2\u00a0\u009e\3\2\2\2\u00a0\u009f\3\2\2\2\u00a1\r\3")
        buf.write(u"\2\2\2\u00a2\u00a3\7\4\2\2\u00a3\u00ab\5\60\31\2\u00a4")
        buf.write(u"\u00a5\7\4\2\2\u00a5\u00ab\5N(\2\u00a6\u00ab\5\f\7\2")
        buf.write(u"\u00a7\u00a8\7\f\2\2\u00a8\u00ab\5&\24\2\u00a9\u00ab")
        buf.write(u"\7\62\2\2\u00aa\u00a2\3\2\2\2\u00aa\u00a4\3\2\2\2\u00aa")
        buf.write(u"\u00a6\3\2\2\2\u00aa\u00a7\3\2\2\2\u00aa\u00a9\3\2\2")
        buf.write(u"\2\u00ab\17\3\2\2\2\u00ac\u00ad\7\6\2\2\u00ad\u00b9\5")
        buf.write(u"\62\32\2\u00ae\u00af\7\5\2\2\u00af\u00b9\5\62\32\2\u00b0")
        buf.write(u"\u00b1\7\6\2\2\u00b1\u00b9\5P)\2\u00b2\u00b3\7\5\2\2")
        buf.write(u"\u00b3\u00b9\5P)\2\u00b4\u00b5\7\f\2\2\u00b5\u00b9\5")
        buf.write(u"(\25\2\u00b6\u00b9\5\16\b\2\u00b7\u00b9\7\63\2\2\u00b8")
        buf.write(u"\u00ac\3\2\2\2\u00b8\u00ae\3\2\2\2\u00b8\u00b0\3\2\2")
        buf.write(u"\2\u00b8\u00b2\3\2\2\2\u00b8\u00b4\3\2\2\2\u00b8\u00b6")
        buf.write(u"\3\2\2\2\u00b8\u00b7\3\2\2\2\u00b9\21\3\2\2\2\u00ba\u00c0")
        buf.write(u"\5\20\t\2\u00bb\u00bc\7\f\2\2\u00bc\u00c0\5*\26\2\u00bd")
        buf.write(u"\u00c0\7/\2\2\u00be\u00c0\7\65\2\2\u00bf\u00ba\3\2\2")
        buf.write(u"\2\u00bf\u00bb\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf\u00be")
        buf.write(u"\3\2\2\2\u00c0\23\3\2\2\2\u00c1\u00c2\7\f\2\2\u00c2\u00c9")
        buf.write(u"\5,\27\2\u00c3\u00c9\5\22\n\2\u00c4\u00c9\5\20\t\2\u00c5")
        buf.write(u"\u00c9\5\16\b\2\u00c6\u00c9\5\f\7\2\u00c7\u00c9\5\n\6")
        buf.write(u"\2\u00c8\u00c1\3\2\2\2\u00c8\u00c3\3\2\2\2\u00c8\u00c4")
        buf.write(u"\3\2\2\2\u00c8\u00c5\3\2\2\2\u00c8\u00c6\3\2\2\2\u00c8")
        buf.write(u"\u00c7\3\2\2\2\u00c9\25\3\2\2\2\u00ca\u00cb\7\n\2\2\u00cb")
        buf.write(u"\u00d1\5\34\17\2\u00cc\u00cd\7\f\2\2\u00cd\u00d1\5\36")
        buf.write(u"\20\2\u00ce\u00cf\7\t\2\2\u00cf\u00d1\5\36\20\2\u00d0")
        buf.write(u"\u00ca\3\2\2\2\u00d0\u00cc\3\2\2\2\u00d0\u00ce\3\2\2")
        buf.write(u"\2\u00d1\27\3\2\2\2\u00d2\u00d3\7\f\2\2\u00d3\u00d4\5")
        buf.write(u"\34\17\2\u00d4\31\3\2\2\2\u00d5\u00d6\7\f\2\2\u00d6\u00d9")
        buf.write(u"\5 \21\2\u00d7\u00d9\7+\2\2\u00d8\u00d5\3\2\2\2\u00d8")
        buf.write(u"\u00d7\3\2\2\2\u00d9\33\3\2\2\2\u00da\u00db\7\13\2\2")
        buf.write(u"\u00db\u00eb\5\26\f\2\u00dc\u00dd\7\21\2\2\u00dd\u00eb")
        buf.write(u"\5\60\31\2\u00de\u00df\7\21\2\2\u00df\u00eb\5\62\32\2")
        buf.write(u"\u00e0\u00e1\7\21\2\2\u00e1\u00eb\5\64\33\2\u00e2\u00e3")
        buf.write(u"\7\21\2\2\u00e3\u00eb\5\66\34\2\u00e4\u00e5\7\21\2\2")
        buf.write(u"\u00e5\u00eb\5.\30\2\u00e6\u00e7\7\21\2\2\u00e7\u00eb")
        buf.write(u"\5b\62\2\u00e8\u00e9\7\21\2\2\u00e9\u00eb\5d\63\2\u00ea")
        buf.write(u"\u00da\3\2\2\2\u00ea\u00dc\3\2\2\2\u00ea\u00de\3\2\2")
        buf.write(u"\2\u00ea\u00e0\3\2\2\2\u00ea\u00e2\3\2\2\2\u00ea\u00e4")
        buf.write(u"\3\2\2\2\u00ea\u00e6\3\2\2\2\u00ea\u00e8\3\2\2\2\u00eb")
        buf.write(u"\35\3\2\2\2\u00ec\u00ed\7\21\2\2\u00ed\u00f7\5@!\2\u00ee")
        buf.write(u"\u00ef\7\21\2\2\u00ef\u00f7\5B\"\2\u00f0\u00f1\7\21\2")
        buf.write(u"\2\u00f1\u00f7\5D#\2\u00f2\u00f3\7\21\2\2\u00f3\u00f7")
        buf.write(u"\5\66\34\2\u00f4\u00f5\7\22\2\2\u00f5\u00f7\5H%\2\u00f6")
        buf.write(u"\u00ec\3\2\2\2\u00f6\u00ee\3\2\2\2\u00f6\u00f0\3\2\2")
        buf.write(u"\2\u00f6\u00f2\3\2\2\2\u00f6\u00f4\3\2\2\2\u00f7\37\3")
        buf.write(u"\2\2\2\u00f8\u00f9\7\21\2\2\u00f9\u0109\5H%\2\u00fa\u00fb")
        buf.write(u"\7\21\2\2\u00fb\u0109\5L\'\2\u00fc\u00fd\7\21\2\2\u00fd")
        buf.write(u"\u0109\5N(\2\u00fe\u00ff\7\21\2\2\u00ff\u0109\5P)\2\u0100")
        buf.write(u"\u0101\7\21\2\2\u0101\u0109\5R*\2\u0102\u0103\7\21\2")
        buf.write(u"\2\u0103\u0109\5T+\2\u0104\u0105\7\21\2\2\u0105\u0109")
        buf.write(u"\5^\60\2\u0106\u0107\7\22\2\2\u0107\u0109\5^\60\2\u0108")
        buf.write(u"\u00f8\3\2\2\2\u0108\u00fa\3\2\2\2\u0108\u00fc\3\2\2")
        buf.write(u"\2\u0108\u00fe\3\2\2\2\u0108\u0100\3\2\2\2\u0108\u0102")
        buf.write(u"\3\2\2\2\u0108\u0104\3\2\2\2\u0108\u0106\3\2\2\2\u0109")
        buf.write(u"!\3\2\2\2\u010a\u010b\7\22\2\2\u010b\u010c\5J&\2\u010c")
        buf.write(u"#\3\2\2\2\u010d\u010e\7\22\2\2\u010e\u0113\5L\'\2\u010f")
        buf.write(u"\u0110\7\22\2\2\u0110\u0113\5.\30\2\u0111\u0113\5\"\22")
        buf.write(u"\2\u0112\u010d\3\2\2\2\u0112\u010f\3\2\2\2\u0112\u0111")
        buf.write(u"\3\2\2\2\u0113%\3\2\2\2\u0114\u0115\7\21\2\2\u0115\u011c")
        buf.write(u"\5:\36\2\u0116\u0117\7\22\2\2\u0117\u011c\5N(\2\u0118")
        buf.write(u"\u0119\7\22\2\2\u0119\u011c\5\60\31\2\u011a\u011c\5$")
        buf.write(u"\23\2\u011b\u0114\3\2\2\2\u011b\u0116\3\2\2\2\u011b\u0118")
        buf.write(u"\3\2\2\2\u011b\u011a\3\2\2\2\u011c\'\3\2\2\2\u011d\u011e")
        buf.write(u"\7\21\2\2\u011e\u0121\58\35\2\u011f\u0121\5&\24\2\u0120")
        buf.write(u"\u011d\3\2\2\2\u0120\u011f\3\2\2\2\u0121)\3\2\2\2\u0122")
        buf.write(u"\u0123\7\21\2\2\u0123\u0126\5<\37\2\u0124\u0126\5(\25")
        buf.write(u"\2\u0125\u0122\3\2\2\2\u0125\u0124\3\2\2\2\u0126+\3\2")
        buf.write(u"\2\2\u0127\u0128\7\21\2\2\u0128\u012b\5> \2\u0129\u012b")
        buf.write(u"\5*\26\2\u012a\u0127\3\2\2\2\u012a\u0129\3\2\2\2\u012b")
        buf.write(u"-\3\2\2\2\u012c\u012d\7.\2\2\u012d/\3\2\2\2\u012e\u012f")
        buf.write(u"\7\36\2\2\u012f\u0130\5@!\2\u0130\u0131\7\67\2\2\u0131")
        buf.write(u"\u0132\5\34\17\2\u0132\u0141\3\2\2\2\u0133\u0134\7\24")
        buf.write(u"\2\2\u0134\u0135\5\60\31\2\u0135\u0136\7\67\2\2\u0136")
        buf.write(u"\u0137\5\16\b\2\u0137\u0141\3\2\2\2\u0138\u0139\7\25")
        buf.write(u"\2\2\u0139\u013a\5\60\31\2\u013a\u013b\7\67\2\2\u013b")
        buf.write(u"\u013c\5\34\17\2\u013c\u0141\3\2\2\2\u013d\u013e\7\30")
        buf.write(u"\2\2\u013e\u0141\5h\65\2\u013f\u0141\5.\30\2\u0140\u012e")
        buf.write(u"\3\2\2\2\u0140\u0133\3\2\2\2\u0140\u0138\3\2\2\2\u0140")
        buf.write(u"\u013d\3\2\2\2\u0140\u013f\3\2\2\2\u0141\61\3\2\2\2\u0142")
        buf.write(u"\u0143\7\16\2\2\u0143\u0153\58\35\2\u0144\u0145\7\24")
        buf.write(u"\2\2\u0145\u0146\5\62\32\2\u0146\u0147\7\67\2\2\u0147")
        buf.write(u"\u0148\5\20\t\2\u0148\u0153\3\2\2\2\u0149\u014a\7\25")
        buf.write(u"\2\2\u014a\u014b\5\62\32\2\u014b\u014c\7\67\2\2\u014c")
        buf.write(u"\u014d\5\34\17\2\u014d\u0153\3\2\2\2\u014e\u014f\5p9")
        buf.write(u"\2\u014f\u0150\5j\66\2\u0150\u0153\3\2\2\2\u0151\u0153")
        buf.write(u"\5\60\31\2\u0152\u0142\3\2\2\2\u0152\u0144\3\2\2\2\u0152")
        buf.write(u"\u0149\3\2\2\2\u0152\u014e\3\2\2\2\u0152\u0151\3\2\2")
        buf.write(u"\2\u0153\63\3\2\2\2\u0154\u0155\7\16\2\2\u0155\u015d")
        buf.write(u"\5D#\2\u0156\u0157\7\23\2\2\u0157\u0158\5\64\33\2\u0158")
        buf.write(u"\u0159\7\67\2\2\u0159\u015a\5\22\n\2\u015a\u015d\3\2")
        buf.write(u"\2\2\u015b\u015d\5\62\32\2\u015c\u0154\3\2\2\2\u015c")
        buf.write(u"\u0156\3\2\2\2\u015c\u015b\3\2\2\2\u015d\65\3\2\2\2\u015e")
        buf.write(u"\u015f\7\23\2\2\u015f\u0160\5\66\34\2\u0160\u0161\7\67")
        buf.write(u"\2\2\u0161\u0162\5\24\13\2\u0162\u016a\3\2\2\2\u0163")
        buf.write(u"\u0164\7\25\2\2\u0164\u0165\5\66\34\2\u0165\u0166\7\67")
        buf.write(u"\2\2\u0166\u0167\5\34\17\2\u0167\u016a\3\2\2\2\u0168")
        buf.write(u"\u016a\5\64\33\2\u0169\u015e\3\2\2\2\u0169\u0163\3\2")
        buf.write(u"\2\2\u0169\u0168\3\2\2\2\u016a\67\3\2\2\2\u016b\u016c")
        buf.write(u"\7\r\2\2\u016c\u0174\5\62\32\2\u016d\u016e\7\24\2\2\u016e")
        buf.write(u"\u016f\58\35\2\u016f\u0170\7\67\2\2\u0170\u0171\5\20")
        buf.write(u"\t\2\u0171\u0174\3\2\2\2\u0172\u0174\7(\2\2\u0173\u016b")
        buf.write(u"\3\2\2\2\u0173\u016d\3\2\2\2\u0173\u0172\3\2\2\2\u0174")
        buf.write(u"9\3\2\2\2\u0175\u0176\7,\2\2\u0176;\3\2\2\2\u0177\u0178")
        buf.write(u"\7\23\2\2\u0178\u0179\5<\37\2\u0179\u017a\7\67\2\2\u017a")
        buf.write(u"\u017b\5\22\n\2\u017b\u017e\3\2\2\2\u017c\u017e\58\35")
        buf.write(u"\2\u017d\u0177\3\2\2\2\u017d\u017c\3\2\2\2\u017e=\3\2")
        buf.write(u"\2\2\u017f\u0180\5<\37\2\u0180?\3\2\2\2\u0181\u0182\7")
        buf.write(u"&\2\2\u0182A\3\2\2\2\u0183\u0184\5@!\2\u0184C\3\2\2\2")
        buf.write(u"\u0185\u018f\7\'\2\2\u0186\u0187\7\r\2\2\u0187\u018f")
        buf.write(u"\5\64\33\2\u0188\u0189\7\23\2\2\u0189\u018a\5D#\2\u018a")
        buf.write(u"\u018b\7\67\2\2\u018b\u018c\5\22\n\2\u018c\u018f\3\2")
        buf.write(u"\2\2\u018d\u018f\5B\"\2\u018e\u0185\3\2\2\2\u018e\u0186")
        buf.write(u"\3\2\2\2\u018e\u0188\3\2\2\2\u018e\u018d\3\2\2\2\u018f")
        buf.write(u"E\3\2\2\2\u0190\u0191\5D#\2\u0191G\3\2\2\2\u0192\u0193")
        buf.write(u"\7\23\2\2\u0193\u0194\5H%\2\u0194\u0195\7\67\2\2\u0195")
        buf.write(u"\u0196\5\32\16\2\u0196\u019e\3\2\2\2\u0197\u0198\7\25")
        buf.write(u"\2\2\u0198\u0199\5H%\2\u0199\u019a\7\67\2\2\u019a\u019b")
        buf.write(u"\5 \21\2\u019b\u019e\3\2\2\2\u019c\u019e\7*\2\2\u019d")
        buf.write(u"\u0192\3\2\2\2\u019d\u0197\3\2\2\2\u019d\u019c\3\2\2")
        buf.write(u"\2\u019eI\3\2\2\2\u019f\u01a0\7\23\2\2\u01a0\u01a1\5")
        buf.write(u"J&\2\u01a1\u01a2\7\67\2\2\u01a2\u01a3\5\32\16\2\u01a3")
        buf.write(u"\u01b1\3\2\2\2\u01a4\u01a5\7\25\2\2\u01a5\u01a6\5J&\2")
        buf.write(u"\u01a6\u01a7\7\67\2\2\u01a7\u01a8\5 \21\2\u01a8\u01b1")
        buf.write(u"\3\2\2\2\u01a9\u01aa\7\35\2\2\u01aa\u01b1\5^\60\2\u01ab")
        buf.write(u"\u01ac\7\30\2\2\u01ac\u01b1\5V,\2\u01ad\u01ae\7\31\2")
        buf.write(u"\2\u01ae\u01b1\5V,\2\u01af\u01b1\7-\2\2\u01b0\u019f\3")
        buf.write(u"\2\2\2\u01b0\u01a4\3\2\2\2\u01b0\u01a9\3\2\2\2\u01b0")
        buf.write(u"\u01ab\3\2\2\2\u01b0\u01ad\3\2\2\2\u01b0\u01af\3\2\2")
        buf.write(u"\2\u01b1K\3\2\2\2\u01b2\u01b3\7\25\2\2\u01b3\u01b4\5")
        buf.write(u"L\'\2\u01b4\u01b5\7\67\2\2\u01b5\u01b6\5 \21\2\u01b6")
        buf.write(u"\u01c7\3\2\2\2\u01b7\u01b8\7\27\2\2\u01b8\u01b9\5L\'")
        buf.write(u"\2\u01b9\u01ba\7\67\2\2\u01ba\u01bb\5L\'\2\u01bb\u01c7")
        buf.write(u"\3\2\2\2\u01bc\u01bd\7\30\2\2\u01bd\u01c7\5X-\2\u01be")
        buf.write(u"\u01bf\7\31\2\2\u01bf\u01c7\5X-\2\u01c0\u01c1\7\30\2")
        buf.write(u"\2\u01c1\u01c7\5`\61\2\u01c2\u01c3\7\34\2\2\u01c3\u01c7")
        buf.write(u"\5d\63\2\u01c4\u01c7\7)\2\2\u01c5\u01c7\5J&\2\u01c6\u01b2")
        buf.write(u"\3\2\2\2\u01c6\u01b7\3\2\2\2\u01c6\u01bc\3\2\2\2\u01c6")
        buf.write(u"\u01be\3\2\2\2\u01c6\u01c0\3\2\2\2\u01c6\u01c2\3\2\2")
        buf.write(u"\2\u01c6\u01c4\3\2\2\2\u01c6\u01c5\3\2\2\2\u01c7M\3\2")
        buf.write(u"\2\2\u01c8\u01c9\7\24\2\2\u01c9\u01ca\5N(\2\u01ca\u01cb")
        buf.write(u"\7\67\2\2\u01cb\u01cc\5\16\b\2\u01cc\u01d8\3\2\2\2\u01cd")
        buf.write(u"\u01ce\7\25\2\2\u01ce\u01cf\5N(\2\u01cf\u01d0\7\67\2")
        buf.write(u"\2\u01d0\u01d1\5 \21\2\u01d1\u01d8\3\2\2\2\u01d2\u01d3")
        buf.write(u"\7\30\2\2\u01d3\u01d8\5Z.\2\u01d4\u01d5\7\30\2\2\u01d5")
        buf.write(u"\u01d8\5b\62\2\u01d6\u01d8\5L\'\2\u01d7\u01c8\3\2\2\2")
        buf.write(u"\u01d7\u01cd\3\2\2\2\u01d7\u01d2\3\2\2\2\u01d7\u01d4")
        buf.write(u"\3\2\2\2\u01d7\u01d6\3\2\2\2\u01d8O\3\2\2\2\u01d9\u01da")
        buf.write(u"\7\24\2\2\u01da\u01db\5P)\2\u01db\u01dc\7\67\2\2\u01dc")
        buf.write(u"\u01dd\5\20\t\2\u01dd\u01e8\3\2\2\2\u01de\u01df\7\25")
        buf.write(u"\2\2\u01df\u01e0\5P)\2\u01e0\u01e1\7\67\2\2\u01e1\u01e2")
        buf.write(u"\5 \21\2\u01e2\u01e8\3\2\2\2\u01e3\u01e4\5p9\2\u01e4")
        buf.write(u"\u01e5\5\\/\2\u01e5\u01e8\3\2\2\2\u01e6\u01e8\5N(\2\u01e7")
        buf.write(u"\u01d9\3\2\2\2\u01e7\u01de\3\2\2\2\u01e7\u01e3\3\2\2")
        buf.write(u"\2\u01e7\u01e6\3\2\2\2\u01e8Q\3\2\2\2\u01e9\u01ea\7\23")
        buf.write(u"\2\2\u01ea\u01eb\5R*\2\u01eb\u01ec\7\67\2\2\u01ec\u01ed")
        buf.write(u"\5\22\n\2\u01ed\u01f0\3\2\2\2\u01ee\u01f0\5P)\2\u01ef")
        buf.write(u"\u01e9\3\2\2\2\u01ef\u01ee\3\2\2\2\u01f0S\3\2\2\2\u01f1")
        buf.write(u"\u01f2\7\23\2\2\u01f2\u01f3\5T+\2\u01f3\u01f4\7\67\2")
        buf.write(u"\2\u01f4\u01f5\5\24\13\2\u01f5\u01fd\3\2\2\2\u01f6\u01f7")
        buf.write(u"\7\25\2\2\u01f7\u01f8\5T+\2\u01f8\u01f9\7\67\2\2\u01f9")
        buf.write(u"\u01fa\5 \21\2\u01fa\u01fd\3\2\2\2\u01fb\u01fd\5R*\2")
        buf.write(u"\u01fc\u01f1\3\2\2\2\u01fc\u01f6\3\2\2\2\u01fc\u01fb")
        buf.write(u"\3\2\2\2\u01fdU\3\2\2\2\u01fe\u01ff\7\26\2\2\u01ff\u0200")
        buf.write(u"\5^\60\2\u0200\u0201\7\67\2\2\u0201\u0202\5J&\2\u0202")
        buf.write(u"W\3\2\2\2\u0203\u0204\7\37\2\2\u0204\u0205\5H%\2\u0205")
        buf.write(u"\u0206\7\67\2\2\u0206\u0207\5H%\2\u0207\u0215\3\2\2\2")
        buf.write(u"\u0208\u0209\7$\2\2\u0209\u020a\5 \21\2\u020a\u020b\7")
        buf.write(u"\67\2\2\u020b\u020c\5 \21\2\u020c\u020d\7\67\2\2\u020d")
        buf.write(u"\u020e\5X-\2\u020e\u0215\3\2\2\2\u020f\u0210\7\26\2\2")
        buf.write(u"\u0210\u0211\5^\60\2\u0211\u0212\7\67\2\2\u0212\u0213")
        buf.write(u"\5L\'\2\u0213\u0215\3\2\2\2\u0214\u0203\3\2\2\2\u0214")
        buf.write(u"\u0208\3\2\2\2\u0214\u020f\3\2\2\2\u0215Y\3\2\2\2\u0216")
        buf.write(u"\u0217\7\26\2\2\u0217\u0218\5^\60\2\u0218\u0219\7\67")
        buf.write(u"\2\2\u0219\u021a\5N(\2\u021a\u021d\3\2\2\2\u021b\u021d")
        buf.write(u"\5X-\2\u021c\u0216\3\2\2\2\u021c\u021b\3\2\2\2\u021d")
        buf.write(u"[\3\2\2\2\u021e\u021f\7\24\2\2\u021f\u0220\5\\/\2\u0220")
        buf.write(u"\u0221\7\67\2\2\u0221\u0222\5\20\t\2\u0222\u0225\3\2")
        buf.write(u"\2\2\u0223\u0225\5Z.\2\u0224\u021e\3\2\2\2\u0224\u0223")
        buf.write(u"\3\2\2\2\u0225]\3\2\2\2\u0226\u0227\7\"\2\2\u0227\u0228")
        buf.write(u"\5H%\2\u0228\u0229\7\67\2\2\u0229\u022a\5H%\2\u022a\u0232")
        buf.write(u"\3\2\2\2\u022b\u022c\7\23\2\2\u022c\u022d\5^\60\2\u022d")
        buf.write(u"\u022e\7\67\2\2\u022e\u022f\5\22\n\2\u022f\u0232\3\2")
        buf.write(u"\2\2\u0230\u0232\5\\/\2\u0231\u0226\3\2\2\2\u0231\u022b")
        buf.write(u"\3\2\2\2\u0231\u0230\3\2\2\2\u0232_\3\2\2\2\u0233\u0234")
        buf.write(u"\7!\2\2\u0234\u0235\5\34\17\2\u0235\u0236\7\67\2\2\u0236")
        buf.write(u"\u0237\5 \21\2\u0237\u023e\3\2\2\2\u0238\u0239\7\26\2")
        buf.write(u"\2\u0239\u023a\5d\63\2\u023a\u023b\7\67\2\2\u023b\u023c")
        buf.write(u"\5.\30\2\u023c\u023e\3\2\2\2\u023d\u0233\3\2\2\2\u023d")
        buf.write(u"\u0238\3\2\2\2\u023ea\3\2\2\2\u023f\u0240\7\26\2\2\u0240")
        buf.write(u"\u0241\5d\63\2\u0241\u0242\7\67\2\2\u0242\u0243\5\60")
        buf.write(u"\31\2\u0243\u0246\3\2\2\2\u0244\u0246\5`\61\2\u0245\u023f")
        buf.write(u"\3\2\2\2\u0245\u0244\3\2\2\2\u0246c\3\2\2\2\u0247\u0248")
        buf.write(u"\7#\2\2\u0248\u0249\5\34\17\2\u0249\u024a\7\67\2\2\u024a")
        buf.write(u"\u024b\5H%\2\u024b\u0252\3\2\2\2\u024c\u024d\7\23\2\2")
        buf.write(u"\u024d\u024e\5d\63\2\u024e\u024f\7\67\2\2\u024f\u0250")
        buf.write(u"\5\22\n\2\u0250\u0252\3\2\2\2\u0251\u0247\3\2\2\2\u0251")
        buf.write(u"\u024c\3\2\2\2\u0252e\3\2\2\2\u0253\u0254\7 \2\2\u0254")
        buf.write(u"\u0255\5\34\17\2\u0255\u0256\7\67\2\2\u0256\u0257\5\34")
        buf.write(u"\17\2\u0257\u025e\3\2\2\2\u0258\u0259\7\26\2\2\u0259")
        buf.write(u"\u025a\5l\67\2\u025a\u025b\7\67\2\2\u025b\u025c\5.\30")
        buf.write(u"\2\u025c\u025e\3\2\2\2\u025d\u0253\3\2\2\2\u025d\u0258")
        buf.write(u"\3\2\2\2\u025eg\3\2\2\2\u025f\u0260\7\26\2\2\u0260\u0261")
        buf.write(u"\5l\67\2\u0261\u0262\7\67\2\2\u0262\u0263\5\60\31\2\u0263")
        buf.write(u"\u0266\3\2\2\2\u0264\u0266\5f\64\2\u0265\u025f\3\2\2")
        buf.write(u"\2\u0265\u0264\3\2\2\2\u0266i\3\2\2\2\u0267\u0268\7\24")
        buf.write(u"\2\2\u0268\u0269\5j\66\2\u0269\u026a\7\67\2\2\u026a\u026b")
        buf.write(u"\5\20\t\2\u026b\u026e\3\2\2\2\u026c\u026e\5h\65\2\u026d")
        buf.write(u"\u0267\3\2\2\2\u026d\u026c\3\2\2\2\u026ek\3\2\2\2\u026f")
        buf.write(u"\u0270\7\23\2\2\u0270\u0271\5l\67\2\u0271\u0272\7\67")
        buf.write(u"\2\2\u0272\u0273\5\22\n\2\u0273\u0277\3\2\2\2\u0274\u0277")
        buf.write(u"\5n8\2\u0275\u0277\5j\66\2\u0276\u026f\3\2\2\2\u0276")
        buf.write(u"\u0274\3\2\2\2\u0276\u0275\3\2\2\2\u0277m\3\2\2\2\u0278")
        buf.write(u"\u0279\7%\2\2\u0279\u027a\5\34\17\2\u027a\u027b\7\67")
        buf.write(u"\2\2\u027b\u027c\5\34\17\2\u027c\u027d\7\67\2\2\u027d")
        buf.write(u"\u027e\5N(\2\u027e\u0285\3\2\2\2\u027f\u0280\7\23\2\2")
        buf.write(u"\u0280\u0281\5n8\2\u0281\u0282\7\67\2\2\u0282\u0283\7")
        buf.write(u"\64\2\2\u0283\u0285\3\2\2\2\u0284\u0278\3\2\2\2\u0284")
        buf.write(u"\u027f\3\2\2\2\u0285o\3\2\2\2\u0286\u0287\t\2\2\2\u0287")
        buf.write(u"q\3\2\2\2\60u{\u0082\u0088\u008f\u00a0\u00aa\u00b8\u00bf")
        buf.write(u"\u00c8\u00d0\u00d8\u00ea\u00f6\u0108\u0112\u011b\u0120")
        buf.write(u"\u0125\u012a\u0140\u0152\u015c\u0169\u0173\u017d\u018e")
        buf.write(u"\u019d\u01b0\u01c6\u01d7\u01e7\u01ef\u01fc\u0214\u021c")
        buf.write(u"\u0224\u0231\u023d\u0245\u0251\u025d\u0265\u026d\u0276")
        buf.write(u"\u0284")
        return buf.getvalue()


class TransformationAlgebraParser ( Parser ):

    grammarFileName = "TransformationAlgebra.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'ratio '", u"'avg '", u"'min '", u"'max '", 
                     u"'count '", u"'size '", u"'merge '", u"'reify '", 
                     u"'deify '", u"'get '", u"'invert '", u"'revert '", 
                     u"'fcont '", u"'ocont '", u"'pi1 '", u"'pi2 '", u"'sigmae '", 
                     u"'sigmale '", u"'bowtie '", u"'bowtie* '", u"'bowtie_ratio '", 
                     u"'groupby_avg '", u"'groupby_sum '", u"'groupby_min '", 
                     u"'groupby_max '", u"'groupby_size '", u"'groupby_count '", 
                     u"'interpol '", u"'odist '", u"'ldist '", u"'lodist '", 
                     u"'otopo '", u"'lotopo '", u"'ndist '", u"'lvis '", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"'in'", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"' '" ]

    symbolicNames = [ u"<INVALID>", u"RATIO", u"AVG", u"MIN", u"MAX", u"COUNT", 
                      u"SIZE", u"MERGE", u"REIFY", u"DEIFY", u"GET", u"INVERT", 
                      u"REVERT", u"FCONT", u"OCONT", u"PI1", u"PI2", u"SIGMAE", 
                      u"SIGMASE", u"BOWTIE", u"BOWTIESTAR", u"BOWTIERATIO", 
                      u"GROUPBYAVG", u"GROUPBYSUM", u"GROUPBYMIN", u"GROUPBYMAX", 
                      u"GROUPBYSIZE", u"GROUPBYCOUNT", u"INTERPOL", u"ODIST", 
                      u"LDIST", u"LODIST", u"OTOPO", u"LOTOPO", u"NDIST", 
                      u"LVIS", u"DATAPM", u"DATAAMOUNT", u"DATACONTOUR", 
                      u"DATAOBJQ", u"DATAOBJS", u"DATAOBJV", u"DATACONTOURLINE", 
                      u"DATAOBJCOUNT", u"DATAFIELD", u"TOPOV", u"COUNTV", 
                      u"RATIOV", u"INTV", u"ORDV", u"BOOLV", u"NOMV", u"DATAV", 
                      u"WHITESPACE", u"KEYWORD", u"WS" ]

    RULE_start = 0
    RULE_r = 1
    RULE_rr = 2
    RULE_v = 3
    RULE_countv = 4
    RULE_ratiov = 5
    RULE_intv = 6
    RULE_ordv = 7
    RULE_nomv = 8
    RULE_qv = 9
    RULE_sv = 10
    RULE_lv = 11
    RULE_ov = 12
    RULE_l = 13
    RULE_s = 14
    RULE_o = 15
    RULE_count = 16
    RULE_ratio = 17
    RULE_intt = 18
    RULE_ordinal = 19
    RULE_nom = 20
    RULE_q = 21
    RULE_lratio = 22
    RULE_lint = 23
    RULE_lord = 24
    RULE_lnom = 25
    RULE_lq = 26
    RULE_ords = 27
    RULE_ints = 28
    RULE_noms = 29
    RULE_qs = 30
    RULE_sint = 31
    RULE_sord = 32
    RULE_snom = 33
    RULE_sq = 34
    RULE_os = 35
    RULE_ocount = 36
    RULE_oratio = 37
    RULE_oint = 38
    RULE_oord = 39
    RULE_onom = 40
    RULE_oq = 41
    RULE_ocounto = 42
    RULE_oratioo = 43
    RULE_ointo = 44
    RULE_oordo = 45
    RULE_onomo = 46
    RULE_lratioo = 47
    RULE_linto = 48
    RULE_lnomo = 49
    RULE_lratiol = 50
    RULE_lintl = 51
    RULE_lordl = 52
    RULE_lnoml = 53
    RULE_lbooll = 54
    RULE_groupbyaggord = 55

    ruleNames =  [ u"start", u"r", u"rr", u"v", u"countv", u"ratiov", u"intv", 
                   u"ordv", u"nomv", u"qv", u"sv", u"lv", u"ov", u"l", u"s", 
                   u"o", u"count", u"ratio", u"intt", u"ordinal", u"nom", 
                   u"q", u"lratio", u"lint", u"lord", u"lnom", u"lq", u"ords", 
                   u"ints", u"noms", u"qs", u"sint", u"sord", u"snom", u"sq", 
                   u"os", u"ocount", u"oratio", u"oint", u"oord", u"onom", 
                   u"oq", u"ocounto", u"oratioo", u"ointo", u"oordo", u"onomo", 
                   u"lratioo", u"linto", u"lnomo", u"lratiol", u"lintl", 
                   u"lordl", u"lnoml", u"lbooll", u"groupbyaggord" ]

    EOF = Token.EOF
    RATIO=1
    AVG=2
    MIN=3
    MAX=4
    COUNT=5
    SIZE=6
    MERGE=7
    REIFY=8
    DEIFY=9
    GET=10
    INVERT=11
    REVERT=12
    FCONT=13
    OCONT=14
    PI1=15
    PI2=16
    SIGMAE=17
    SIGMASE=18
    BOWTIE=19
    BOWTIESTAR=20
    BOWTIERATIO=21
    GROUPBYAVG=22
    GROUPBYSUM=23
    GROUPBYMIN=24
    GROUPBYMAX=25
    GROUPBYSIZE=26
    GROUPBYCOUNT=27
    INTERPOL=28
    ODIST=29
    LDIST=30
    LODIST=31
    OTOPO=32
    LOTOPO=33
    NDIST=34
    LVIS=35
    DATAPM=36
    DATAAMOUNT=37
    DATACONTOUR=38
    DATAOBJQ=39
    DATAOBJS=40
    DATAOBJV=41
    DATACONTOURLINE=42
    DATAOBJCOUNT=43
    DATAFIELD=44
    TOPOV=45
    COUNTV=46
    RATIOV=47
    INTV=48
    ORDV=49
    BOOLV=50
    NOMV=51
    DATAV=52
    WHITESPACE=53
    KEYWORD=54
    WS=55

    def __init__(self, input, output=sys.stdout):
        super(TransformationAlgebraParser, self).__init__(input, output=output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.StartContext, self).__init__(parent, invokingState)
            self.parser = parser

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RrContext,0)


        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.VContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_start

        def enterRule(self, listener):
            if hasattr(listener, "enterStart"):
                listener.enterStart(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStart"):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DEIFY, TransformationAlgebraParser.PI1, TransformationAlgebraParser.PI2]:
                self.state = 112
                self.r()
                pass
            elif token in [TransformationAlgebraParser.INVERT, TransformationAlgebraParser.REVERT, TransformationAlgebraParser.SIGMAE, TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.BOWTIERATIO, TransformationAlgebraParser.GROUPBYAVG, TransformationAlgebraParser.GROUPBYSUM, TransformationAlgebraParser.GROUPBYMIN, TransformationAlgebraParser.GROUPBYMAX, TransformationAlgebraParser.GROUPBYSIZE, TransformationAlgebraParser.GROUPBYCOUNT, TransformationAlgebraParser.INTERPOL, TransformationAlgebraParser.DATAPM, TransformationAlgebraParser.DATAAMOUNT, TransformationAlgebraParser.DATACONTOUR, TransformationAlgebraParser.DATAOBJQ, TransformationAlgebraParser.DATAOBJS, TransformationAlgebraParser.DATAOBJCOUNT, TransformationAlgebraParser.DATAFIELD]:
                self.state = 113
                self.rr()
                pass
            elif token in [TransformationAlgebraParser.RATIO, TransformationAlgebraParser.AVG, TransformationAlgebraParser.MIN, TransformationAlgebraParser.MAX, TransformationAlgebraParser.COUNT, TransformationAlgebraParser.SIZE, TransformationAlgebraParser.MERGE, TransformationAlgebraParser.REIFY, TransformationAlgebraParser.GET, TransformationAlgebraParser.FCONT, TransformationAlgebraParser.OCONT, TransformationAlgebraParser.DATAOBJV, TransformationAlgebraParser.TOPOV, TransformationAlgebraParser.COUNTV, TransformationAlgebraParser.RATIOV, TransformationAlgebraParser.INTV, TransformationAlgebraParser.ORDV, TransformationAlgebraParser.NOMV]:
                self.state = 114
                self.v()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RContext, self).__init__(parent, invokingState)
            self.parser = parser

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_r

        def enterRule(self, listener):
            if hasattr(listener, "enterR"):
                listener.enterR(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitR"):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_r)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 117
                self.l()
                pass

            elif la_ == 2:
                self.state = 118
                self.s()
                pass

            elif la_ == 3:
                self.state = 119
                self.q()
                pass

            elif la_ == 4:
                self.state = 120
                self.o()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RrContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def sq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SqContext,0)


        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_rr

        def enterRule(self, listener):
            if hasattr(listener, "enterRr"):
                listener.enterRr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRr"):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 123
                self.lq()
                pass

            elif la_ == 2:
                self.state = 124
                self.sq()
                pass

            elif la_ == 3:
                self.state = 125
                self.qs()
                pass

            elif la_ == 4:
                self.state = 126
                self.oq()
                pass

            elif la_ == 5:
                self.state = 127
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.VContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def lv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LvContext,0)


        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_v

        def enterRule(self, listener):
            if hasattr(listener, "enterV"):
                listener.enterV(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitV"):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_v)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 130
                self.ov()
                pass

            elif la_ == 2:
                self.state = 131
                self.lv()
                pass

            elif la_ == 3:
                self.state = 132
                self.sv()
                pass

            elif la_ == 4:
                self.state = 133
                self.qv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(TransformationAlgebraParser.COUNT, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def COUNTV(self):
            return self.getToken(TransformationAlgebraParser.COUNTV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_countv

        def enterRule(self, listener):
            if hasattr(listener, "enterCountv"):
                listener.enterCountv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCountv"):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_countv)
        try:
            self.state = 141
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.COUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 136
                self.match(TransformationAlgebraParser.COUNT)
                self.state = 137
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 138
                self.match(TransformationAlgebraParser.GET)
                self.state = 139
                self.count()
                pass
            elif token in [TransformationAlgebraParser.COUNTV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 140
                self.match(TransformationAlgebraParser.COUNTV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatiovContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatiovContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FCONT(self):
            return self.getToken(TransformationAlgebraParser.FCONT, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def SIZE(self):
            return self.getToken(TransformationAlgebraParser.SIZE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def RATIO(self):
            return self.getToken(TransformationAlgebraParser.RATIO, 0)

        def ratiov(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.RatiovContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountvContext,0)


        def RATIOV(self):
            return self.getToken(TransformationAlgebraParser.RATIOV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratiov

        def enterRule(self, listener):
            if hasattr(listener, "enterRatiov"):
                listener.enterRatiov(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatiov"):
                listener.exitRatiov(self)




    def ratiov(self):

        localctx = TransformationAlgebraParser.RatiovContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ratiov)
        try:
            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 143
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 144
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 145
                self.match(TransformationAlgebraParser.SIZE)
                self.state = 146
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 147
                self.match(TransformationAlgebraParser.RATIO)
                self.state = 148
                self.ratiov()
                self.state = 149
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 150
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 152
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 153
                self.oratio()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 154
                self.match(TransformationAlgebraParser.GET)
                self.state = 155
                self.ratio()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 156
                self.countv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 157
                self.match(TransformationAlgebraParser.RATIOV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def ratiov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def INTV(self):
            return self.getToken(TransformationAlgebraParser.INTV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intv

        def enterRule(self, listener):
            if hasattr(listener, "enterIntv"):
                listener.enterIntv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntv"):
                listener.exitIntv(self)




    def intv(self):

        localctx = TransformationAlgebraParser.IntvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_intv)
        try:
            self.state = 168
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 160
                self.match(TransformationAlgebraParser.AVG)
                self.state = 161
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 162
                self.match(TransformationAlgebraParser.AVG)
                self.state = 163
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 164
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 165
                self.match(TransformationAlgebraParser.GET)
                self.state = 166
                self.intt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 167
                self.match(TransformationAlgebraParser.INTV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MAX(self):
            return self.getToken(TransformationAlgebraParser.MAX, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def MIN(self):
            return self.getToken(TransformationAlgebraParser.MIN, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def ORDV(self):
            return self.getToken(TransformationAlgebraParser.ORDV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordv

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdv"):
                listener.enterOrdv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdv"):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ordv)
        try:
            self.state = 182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 170
                self.match(TransformationAlgebraParser.MAX)
                self.state = 171
                self.lord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 172
                self.match(TransformationAlgebraParser.MIN)
                self.state = 173
                self.lord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 174
                self.match(TransformationAlgebraParser.MAX)
                self.state = 175
                self.oord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 176
                self.match(TransformationAlgebraParser.MIN)
                self.state = 177
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 178
                self.match(TransformationAlgebraParser.GET)
                self.state = 179
                self.ordinal()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 180
                self.intv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 181
                self.match(TransformationAlgebraParser.ORDV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def TOPOV(self):
            return self.getToken(TransformationAlgebraParser.TOPOV, 0)

        def NOMV(self):
            return self.getToken(TransformationAlgebraParser.NOMV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nomv

        def enterRule(self, listener):
            if hasattr(listener, "enterNomv"):
                listener.enterNomv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNomv"):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nomv)
        try:
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 185
                self.match(TransformationAlgebraParser.GET)
                self.state = 186
                self.nom()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 187
                self.match(TransformationAlgebraParser.TOPOV)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 188
                self.match(TransformationAlgebraParser.NOMV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def ratiov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qv

        def enterRule(self, listener):
            if hasattr(listener, "enterQv"):
                listener.enterQv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQv"):
                listener.exitQv(self)




    def qv(self):

        localctx = TransformationAlgebraParser.QvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_qv)
        try:
            self.state = 198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                self.match(TransformationAlgebraParser.GET)
                self.state = 192
                self.q()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 193
                self.nomv()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 194
                self.ordv()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 195
                self.intv()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 196
                self.ratiov()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 197
                self.countv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REIFY(self):
            return self.getToken(TransformationAlgebraParser.REIFY, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def MERGE(self):
            return self.getToken(TransformationAlgebraParser.MERGE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sv

        def enterRule(self, listener):
            if hasattr(listener, "enterSv"):
                listener.enterSv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSv"):
                listener.exitSv(self)




    def sv(self):

        localctx = TransformationAlgebraParser.SvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sv)
        try:
            self.state = 206
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.REIFY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 200
                self.match(TransformationAlgebraParser.REIFY)
                self.state = 201
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 202
                self.match(TransformationAlgebraParser.GET)
                self.state = 203
                self.s()
                pass
            elif token in [TransformationAlgebraParser.MERGE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 204
                self.match(TransformationAlgebraParser.MERGE)
                self.state = 205
                self.s()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lv

        def enterRule(self, listener):
            if hasattr(listener, "enterLv"):
                listener.enterLv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLv"):
                listener.exitLv(self)




    def lv(self):

        localctx = TransformationAlgebraParser.LvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_lv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(TransformationAlgebraParser.GET)
            self.state = 209
            self.l()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJV(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ov

        def enterRule(self, listener):
            if hasattr(listener, "enterOv"):
                listener.enterOv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOv"):
                listener.exitOv(self)




    def ov(self):

        localctx = TransformationAlgebraParser.OvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ov)
        try:
            self.state = 214
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 211
                self.match(TransformationAlgebraParser.GET)
                self.state = 212
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 213
                self.match(TransformationAlgebraParser.DATAOBJV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DEIFY(self):
            return self.getToken(TransformationAlgebraParser.DEIFY, 0)

        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def linto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintoContext,0)


        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_l

        def enterRule(self, listener):
            if hasattr(listener, "enterL"):
                listener.enterL(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitL"):
                listener.exitL(self)




    def l(self):

        localctx = TransformationAlgebraParser.LContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_l)
        try:
            self.state = 232
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 216
                self.match(TransformationAlgebraParser.DEIFY)
                self.state = 217
                self.sv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 218
                self.match(TransformationAlgebraParser.PI1)
                self.state = 219
                self.lint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 220
                self.match(TransformationAlgebraParser.PI1)
                self.state = 221
                self.lord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 222
                self.match(TransformationAlgebraParser.PI1)
                self.state = 223
                self.lnom()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 224
                self.match(TransformationAlgebraParser.PI1)
                self.state = 225
                self.lq()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 226
                self.match(TransformationAlgebraParser.PI1)
                self.state = 227
                self.lratio()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 228
                self.match(TransformationAlgebraParser.PI1)
                self.state = 229
                self.linto()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 230
                self.match(TransformationAlgebraParser.PI1)
                self.state = 231
                self.lnomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def sord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SordContext,0)


        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_s

        def enterRule(self, listener):
            if hasattr(listener, "enterS"):
                listener.enterS(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitS"):
                listener.exitS(self)




    def s(self):

        localctx = TransformationAlgebraParser.SContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_s)
        try:
            self.state = 244
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 234
                self.match(TransformationAlgebraParser.PI1)
                self.state = 235
                self.sint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 236
                self.match(TransformationAlgebraParser.PI1)
                self.state = 237
                self.sord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 238
                self.match(TransformationAlgebraParser.PI1)
                self.state = 239
                self.snom()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 240
                self.match(TransformationAlgebraParser.PI1)
                self.state = 241
                self.lq()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 242
                self.match(TransformationAlgebraParser.PI2)
                self.state = 243
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_o

        def enterRule(self, listener):
            if hasattr(listener, "enterO"):
                listener.enterO(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitO"):
                listener.exitO(self)




    def o(self):

        localctx = TransformationAlgebraParser.OContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_o)
        try:
            self.state = 262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 246
                self.match(TransformationAlgebraParser.PI1)
                self.state = 247
                self.os()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 248
                self.match(TransformationAlgebraParser.PI1)
                self.state = 249
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 250
                self.match(TransformationAlgebraParser.PI1)
                self.state = 251
                self.oint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 252
                self.match(TransformationAlgebraParser.PI1)
                self.state = 253
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 254
                self.match(TransformationAlgebraParser.PI1)
                self.state = 255
                self.onom()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 256
                self.match(TransformationAlgebraParser.PI1)
                self.state = 257
                self.oq()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 258
                self.match(TransformationAlgebraParser.PI1)
                self.state = 259
                self.onomo()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 260
                self.match(TransformationAlgebraParser.PI2)
                self.state = 261
                self.onomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_count

        def enterRule(self, listener):
            if hasattr(listener, "enterCount"):
                listener.enterCount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCount"):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(TransformationAlgebraParser.PI2)
            self.state = 265
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratio

        def enterRule(self, listener):
            if hasattr(listener, "enterRatio"):
                listener.enterRatio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatio"):
                listener.exitRatio(self)




    def ratio(self):

        localctx = TransformationAlgebraParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ratio)
        try:
            self.state = 272
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 267
                self.match(TransformationAlgebraParser.PI2)
                self.state = 268
                self.oratio()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 269
                self.match(TransformationAlgebraParser.PI2)
                self.state = 270
                self.lratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 271
                self.count()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InttContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.InttContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ints(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntsContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intt

        def enterRule(self, listener):
            if hasattr(listener, "enterIntt"):
                listener.enterIntt(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntt"):
                listener.exitIntt(self)




    def intt(self):

        localctx = TransformationAlgebraParser.InttContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_intt)
        try:
            self.state = 281
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 274
                self.match(TransformationAlgebraParser.PI1)
                self.state = 275
                self.ints()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 276
                self.match(TransformationAlgebraParser.PI2)
                self.state = 277
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 278
                self.match(TransformationAlgebraParser.PI2)
                self.state = 279
                self.lint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 280
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdinalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdinalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordinal

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdinal"):
                listener.enterOrdinal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdinal"):
                listener.exitOrdinal(self)




    def ordinal(self):

        localctx = TransformationAlgebraParser.OrdinalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordinal)
        try:
            self.state = 286
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 283
                self.match(TransformationAlgebraParser.PI1)
                self.state = 284
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 285
                self.intt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nom

        def enterRule(self, listener):
            if hasattr(listener, "enterNom"):
                listener.enterNom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNom"):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_nom)
        try:
            self.state = 291
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 288
                self.match(TransformationAlgebraParser.PI1)
                self.state = 289
                self.noms()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 290
                self.ordinal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_q

        def enterRule(self, listener):
            if hasattr(listener, "enterQ"):
                listener.enterQ(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQ"):
                listener.exitQ(self)




    def q(self):

        localctx = TransformationAlgebraParser.QContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_q)
        try:
            self.state = 296
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 293
                self.match(TransformationAlgebraParser.PI1)
                self.state = 294
                self.qs()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.nom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAFIELD(self):
            return self.getToken(TransformationAlgebraParser.DATAFIELD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratio

        def enterRule(self, listener):
            if hasattr(listener, "enterLratio"):
                listener.enterLratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratio"):
                listener.exitLratio(self)




    def lratio(self):

        localctx = TransformationAlgebraParser.LratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_lratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.match(TransformationAlgebraParser.DATAFIELD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTERPOL(self):
            return self.getToken(TransformationAlgebraParser.INTERPOL, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lint

        def enterRule(self, listener):
            if hasattr(listener, "enterLint"):
                listener.enterLint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLint"):
                listener.exitLint(self)




    def lint(self):

        localctx = TransformationAlgebraParser.LintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_lint)
        try:
            self.state = 318
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INTERPOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 300
                self.match(TransformationAlgebraParser.INTERPOL)
                self.state = 301
                self.sint()
                self.state = 302
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 303
                self.l()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 305
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 306
                self.lint()
                self.state = 307
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 308
                self.intv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 310
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 311
                self.lint()
                self.state = 312
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 313
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYAVG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 315
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 316
                self.lintl()
                pass
            elif token in [TransformationAlgebraParser.DATAFIELD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 317
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REVERT(self):
            return self.getToken(TransformationAlgebraParser.REVERT, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lord

        def enterRule(self, listener):
            if hasattr(listener, "enterLord"):
                listener.enterLord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLord"):
                listener.exitLord(self)




    def lord(self):

        localctx = TransformationAlgebraParser.LordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_lord)
        try:
            self.state = 336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.match(TransformationAlgebraParser.REVERT)
                self.state = 321
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 322
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 323
                self.lord()
                self.state = 324
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 325
                self.ordv()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 327
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 328
                self.lord()
                self.state = 329
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 330
                self.l()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 332
                self.groupbyaggord()
                self.state = 333
                self.lordl()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 335
                self.lint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REVERT(self):
            return self.getToken(TransformationAlgebraParser.REVERT, 0)

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnom

        def enterRule(self, listener):
            if hasattr(listener, "enterLnom"):
                listener.enterLnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnom"):
                listener.exitLnom(self)




    def lnom(self):

        localctx = TransformationAlgebraParser.LnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_lnom)
        try:
            self.state = 346
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.match(TransformationAlgebraParser.REVERT)
                self.state = 339
                self.snom()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 340
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 341
                self.lnom()
                self.state = 342
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 343
                self.nomv()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 345
                self.lord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lq

        def enterRule(self, listener):
            if hasattr(listener, "enterLq"):
                listener.enterLq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLq"):
                listener.exitLq(self)




    def lq(self):

        localctx = TransformationAlgebraParser.LqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_lq)
        try:
            self.state = 359
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 348
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 349
                self.lq()
                self.state = 350
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 351
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 353
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 354
                self.lq()
                self.state = 355
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 356
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 358
                self.lnom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INVERT(self):
            return self.getToken(TransformationAlgebraParser.INVERT, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def DATACONTOUR(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOUR, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ords

        def enterRule(self, listener):
            if hasattr(listener, "enterOrds"):
                listener.enterOrds(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrds"):
                listener.exitOrds(self)




    def ords(self):

        localctx = TransformationAlgebraParser.OrdsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ords)
        try:
            self.state = 369
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INVERT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 361
                self.match(TransformationAlgebraParser.INVERT)
                self.state = 362
                self.lord()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 363
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 364
                self.ords()
                self.state = 365
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 366
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.DATACONTOUR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 368
                self.match(TransformationAlgebraParser.DATACONTOUR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOURLINE(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOURLINE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ints

        def enterRule(self, listener):
            if hasattr(listener, "enterInts"):
                listener.enterInts(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInts"):
                listener.exitInts(self)




    def ints(self):

        localctx = TransformationAlgebraParser.IntsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_ints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 371
            self.match(TransformationAlgebraParser.DATACONTOURLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_noms

        def enterRule(self, listener):
            if hasattr(listener, "enterNoms"):
                listener.enterNoms(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNoms"):
                listener.exitNoms(self)




    def noms(self):

        localctx = TransformationAlgebraParser.NomsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_noms)
        try:
            self.state = 379
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 373
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 374
                self.noms()
                self.state = 375
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 376
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.INVERT, TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.DATACONTOUR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 378
                self.ords()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qs

        def enterRule(self, listener):
            if hasattr(listener, "enterQs"):
                listener.enterQs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQs"):
                listener.exitQs(self)




    def qs(self):

        localctx = TransformationAlgebraParser.QsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_qs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.noms()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAPM(self):
            return self.getToken(TransformationAlgebraParser.DATAPM, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sint

        def enterRule(self, listener):
            if hasattr(listener, "enterSint"):
                listener.enterSint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSint"):
                listener.exitSint(self)




    def sint(self):

        localctx = TransformationAlgebraParser.SintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_sint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(TransformationAlgebraParser.DATAPM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sord

        def enterRule(self, listener):
            if hasattr(listener, "enterSord"):
                listener.enterSord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSord"):
                listener.exitSord(self)




    def sord(self):

        localctx = TransformationAlgebraParser.SordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_sord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.sint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAAMOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAAMOUNT, 0)

        def INVERT(self):
            return self.getToken(TransformationAlgebraParser.INVERT, 0)

        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def sord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_snom

        def enterRule(self, listener):
            if hasattr(listener, "enterSnom"):
                listener.enterSnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSnom"):
                listener.exitSnom(self)




    def snom(self):

        localctx = TransformationAlgebraParser.SnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_snom)
        try:
            self.state = 396
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DATAAMOUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 387
                self.match(TransformationAlgebraParser.DATAAMOUNT)
                pass
            elif token in [TransformationAlgebraParser.INVERT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 388
                self.match(TransformationAlgebraParser.INVERT)
                self.state = 389
                self.lnom()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 390
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 391
                self.snom()
                self.state = 392
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 393
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.DATAPM]:
                self.enterOuterAlt(localctx, 4)
                self.state = 395
                self.sord()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sq

        def enterRule(self, listener):
            if hasattr(listener, "enterSq"):
                listener.enterSq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSq"):
                listener.exitSq(self)




    def sq(self):

        localctx = TransformationAlgebraParser.SqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_sq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.snom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJS(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJS, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_os

        def enterRule(self, listener):
            if hasattr(listener, "enterOs"):
                listener.enterOs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOs"):
                listener.exitOs(self)




    def os(self):

        localctx = TransformationAlgebraParser.OsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_os)
        try:
            self.state = 411
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 400
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 401
                self.os()
                self.state = 402
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 403
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 405
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 406
                self.os()
                self.state = 407
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 408
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 410
                self.match(TransformationAlgebraParser.DATAOBJS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYCOUNT(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYCOUNT, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def ocounto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountoContext,0)


        def GROUPBYSUM(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSUM, 0)

        def DATAOBJCOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJCOUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocount

        def enterRule(self, listener):
            if hasattr(listener, "enterOcount"):
                listener.enterOcount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcount"):
                listener.exitOcount(self)




    def ocount(self):

        localctx = TransformationAlgebraParser.OcountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_ocount)
        try:
            self.state = 430
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 413
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 414
                self.ocount()
                self.state = 415
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 416
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 418
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 419
                self.ocount()
                self.state = 420
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 421
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYCOUNT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 423
                self.match(TransformationAlgebraParser.GROUPBYCOUNT)
                self.state = 424
                self.onomo()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYAVG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 425
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 426
                self.ocounto()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYSUM]:
                self.enterOuterAlt(localctx, 5)
                self.state = 427
                self.match(TransformationAlgebraParser.GROUPBYSUM)
                self.state = 428
                self.ocounto()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJCOUNT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 429
                self.match(TransformationAlgebraParser.DATAOBJCOUNT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def oratio(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OratioContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def BOWTIERATIO(self):
            return self.getToken(TransformationAlgebraParser.BOWTIERATIO, 0)

        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def GROUPBYSUM(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSUM, 0)

        def lratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiooContext,0)


        def GROUPBYSIZE(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSIZE, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def DATAOBJQ(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJQ, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratio

        def enterRule(self, listener):
            if hasattr(listener, "enterOratio"):
                listener.enterOratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratio"):
                listener.exitOratio(self)




    def oratio(self):

        localctx = TransformationAlgebraParser.OratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_oratio)
        try:
            self.state = 452
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 432
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 433
                self.oratio()
                self.state = 434
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 435
                self.o()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 437
                self.match(TransformationAlgebraParser.BOWTIERATIO)
                self.state = 438
                self.oratio()
                self.state = 439
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 440
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 442
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 443
                self.oratioo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 444
                self.match(TransformationAlgebraParser.GROUPBYSUM)
                self.state = 445
                self.oratioo()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 446
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 447
                self.lratioo()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 448
                self.match(TransformationAlgebraParser.GROUPBYSIZE)
                self.state = 449
                self.lnomo()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 450
                self.match(TransformationAlgebraParser.DATAOBJQ)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 451
                self.ocount()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def linto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oint

        def enterRule(self, listener):
            if hasattr(listener, "enterOint"):
                listener.enterOint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOint"):
                listener.exitOint(self)




    def oint(self):

        localctx = TransformationAlgebraParser.OintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_oint)
        try:
            self.state = 469
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 454
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 455
                self.oint()
                self.state = 456
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 457
                self.intv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 459
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 460
                self.oint()
                self.state = 461
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 462
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 464
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 465
                self.ointo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 466
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 467
                self.linto()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 468
                self.oratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oord

        def enterRule(self, listener):
            if hasattr(listener, "enterOord"):
                listener.enterOord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOord"):
                listener.exitOord(self)




    def oord(self):

        localctx = TransformationAlgebraParser.OordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_oord)
        try:
            self.state = 485
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 471
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 472
                self.oord()
                self.state = 473
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 474
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 476
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 477
                self.oord()
                self.state = 478
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 479
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 481
                self.groupbyaggord()
                self.state = 482
                self.oordo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 484
                self.oint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onom

        def enterRule(self, listener):
            if hasattr(listener, "enterOnom"):
                listener.enterOnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnom"):
                listener.exitOnom(self)




    def onom(self):

        localctx = TransformationAlgebraParser.OnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_onom)
        try:
            self.state = 493
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 487
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 488
                self.onom()
                self.state = 489
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 490
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 492
                self.oord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oq

        def enterRule(self, listener):
            if hasattr(listener, "enterOq"):
                listener.enterOq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOq"):
                listener.exitOq(self)




    def oq(self):

        localctx = TransformationAlgebraParser.OqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_oq)
        try:
            self.state = 506
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 495
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 496
                self.oq()
                self.state = 497
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 498
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 500
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 501
                self.oq()
                self.state = 502
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 503
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 505
                self.onom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocounto

        def enterRule(self, listener):
            if hasattr(listener, "enterOcounto"):
                listener.enterOcounto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcounto"):
                listener.exitOcounto(self)




    def ocounto(self):

        localctx = TransformationAlgebraParser.OcountoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_ocounto)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self.match(TransformationAlgebraParser.BOWTIESTAR)
            self.state = 509
            self.onomo()
            self.state = 510
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 511
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ODIST(self):
            return self.getToken(TransformationAlgebraParser.ODIST, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def NDIST(self):
            return self.getToken(TransformationAlgebraParser.NDIST, 0)

        def o(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OContext,i)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterOratioo"):
                listener.enterOratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratioo"):
                listener.exitOratioo(self)




    def oratioo(self):

        localctx = TransformationAlgebraParser.OratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_oratioo)
        try:
            self.state = 530
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.ODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 513
                self.match(TransformationAlgebraParser.ODIST)
                self.state = 514
                self.os()
                self.state = 515
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 516
                self.os()
                pass
            elif token in [TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 518
                self.match(TransformationAlgebraParser.NDIST)
                self.state = 519
                self.o()
                self.state = 520
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 521
                self.o()
                self.state = 522
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 523
                self.oratioo()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 525
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 526
                self.onomo()
                self.state = 527
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 528
                self.oratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ointo

        def enterRule(self, listener):
            if hasattr(listener, "enterOinto"):
                listener.enterOinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOinto"):
                listener.exitOinto(self)




    def ointo(self):

        localctx = TransformationAlgebraParser.OintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_ointo)
        try:
            self.state = 538
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 532
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 533
                self.onomo()
                self.state = 534
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 535
                self.oint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 537
                self.oratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oordo

        def enterRule(self, listener):
            if hasattr(listener, "enterOordo"):
                listener.enterOordo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOordo"):
                listener.exitOordo(self)




    def oordo(self):

        localctx = TransformationAlgebraParser.OordoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_oordo)
        try:
            self.state = 546
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 540
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 541
                self.oordo()
                self.state = 542
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 543
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 545
                self.ointo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OTOPO(self):
            return self.getToken(TransformationAlgebraParser.OTOPO, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onomo

        def enterRule(self, listener):
            if hasattr(listener, "enterOnomo"):
                listener.enterOnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnomo"):
                listener.exitOnomo(self)




    def onomo(self):

        localctx = TransformationAlgebraParser.OnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_onomo)
        try:
            self.state = 559
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 548
                self.match(TransformationAlgebraParser.OTOPO)
                self.state = 549
                self.os()
                self.state = 550
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 551
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 553
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 554
                self.onomo()
                self.state = 555
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 556
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE, TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 558
                self.oordo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LODIST(self):
            return self.getToken(TransformationAlgebraParser.LODIST, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterLratioo"):
                listener.enterLratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratioo"):
                listener.exitLratioo(self)




    def lratioo(self):

        localctx = TransformationAlgebraParser.LratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_lratioo)
        try:
            self.state = 571
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 561
                self.match(TransformationAlgebraParser.LODIST)
                self.state = 562
                self.l()
                self.state = 563
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 564
                self.o()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 566
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 567
                self.lnomo()
                self.state = 568
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 569
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_linto

        def enterRule(self, listener):
            if hasattr(listener, "enterLinto"):
                listener.enterLinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLinto"):
                listener.exitLinto(self)




    def linto(self):

        localctx = TransformationAlgebraParser.LintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_linto)
        try:
            self.state = 579
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 573
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 574
                self.lnomo()
                self.state = 575
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 576
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 578
                self.lratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LOTOPO(self):
            return self.getToken(TransformationAlgebraParser.LOTOPO, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lnomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnomo

        def enterRule(self, listener):
            if hasattr(listener, "enterLnomo"):
                listener.enterLnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnomo"):
                listener.exitLnomo(self)




    def lnomo(self):

        localctx = TransformationAlgebraParser.LnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_lnomo)
        try:
            self.state = 591
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LOTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 581
                self.match(TransformationAlgebraParser.LOTOPO)
                self.state = 582
                self.l()
                self.state = 583
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 584
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 586
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 587
                self.lnomo()
                self.state = 588
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 589
                self.nomv()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiolContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiolContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LDIST(self):
            return self.getToken(TransformationAlgebraParser.LDIST, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratiol

        def enterRule(self, listener):
            if hasattr(listener, "enterLratiol"):
                listener.enterLratiol(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratiol"):
                listener.exitLratiol(self)




    def lratiol(self):

        localctx = TransformationAlgebraParser.LratiolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_lratiol)
        try:
            self.state = 603
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 593
                self.match(TransformationAlgebraParser.LDIST)
                self.state = 594
                self.l()
                self.state = 595
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 596
                self.l()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 598
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 599
                self.lnoml()
                self.state = 600
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 601
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratiol(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiolContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lintl

        def enterRule(self, listener):
            if hasattr(listener, "enterLintl"):
                listener.enterLintl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLintl"):
                listener.exitLintl(self)




    def lintl(self):

        localctx = TransformationAlgebraParser.LintlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_lintl)
        try:
            self.state = 611
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 605
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 606
                self.lnoml()
                self.state = 607
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 608
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 610
                self.lratiol()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE, 0)

        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lordl

        def enterRule(self, listener):
            if hasattr(listener, "enterLordl"):
                listener.enterLordl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLordl"):
                listener.exitLordl(self)




    def lordl(self):

        localctx = TransformationAlgebraParser.LordlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_lordl)
        try:
            self.state = 619
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 613
                self.match(TransformationAlgebraParser.SIGMASE)
                self.state = 614
                self.lordl()
                self.state = 615
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 616
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 618
                self.lintl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnoml

        def enterRule(self, listener):
            if hasattr(listener, "enterLnoml"):
                listener.enterLnoml(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnoml"):
                listener.exitLnoml(self)




    def lnoml(self):

        localctx = TransformationAlgebraParser.LnomlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_lnoml)
        try:
            self.state = 628
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 621
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 622
                self.lnoml()
                self.state = 623
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 624
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 626
                self.lbooll()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 627
                self.lordl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LboollContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LboollContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LVIS(self):
            return self.getToken(TransformationAlgebraParser.LVIS, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def SIGMAE(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE, 0)

        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def BOOLV(self):
            return self.getToken(TransformationAlgebraParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lbooll

        def enterRule(self, listener):
            if hasattr(listener, "enterLbooll"):
                listener.enterLbooll(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLbooll"):
                listener.exitLbooll(self)




    def lbooll(self):

        localctx = TransformationAlgebraParser.LboollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_lbooll)
        try:
            self.state = 642
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LVIS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 630
                self.match(TransformationAlgebraParser.LVIS)
                self.state = 631
                self.l()
                self.state = 632
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 633
                self.l()
                self.state = 634
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 635
                self.oint()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 637
                self.match(TransformationAlgebraParser.SIGMAE)
                self.state = 638
                self.lbooll()
                self.state = 639
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 640
                self.match(TransformationAlgebraParser.BOOLV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupbyaggordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.GroupbyaggordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GROUPBYMIN(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMIN, 0)

        def GROUPBYMAX(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMAX, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_groupbyaggord

        def enterRule(self, listener):
            if hasattr(listener, "enterGroupbyaggord"):
                listener.enterGroupbyaggord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGroupbyaggord"):
                listener.exitGroupbyaggord(self)




    def groupbyaggord(self):

        localctx = TransformationAlgebraParser.GroupbyaggordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_groupbyaggord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 644
            _la = self._input.LA(1)
            if not(_la==TransformationAlgebraParser.GROUPBYMIN or _la==TransformationAlgebraParser.GROUPBYMAX):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





