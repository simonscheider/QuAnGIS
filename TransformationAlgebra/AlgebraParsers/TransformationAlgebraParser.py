# Generated from TransformationAlgebra.g4 by ANTLR 4.8
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u",\u022d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t")
        buf.write(u"\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$")
        buf.write(u"\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t")
        buf.write(u",\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63")
        buf.write(u"\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\3")
        buf.write(u"\2\3\2\3\2\5\2t\n\2\3\3\3\3\3\3\3\3\5\3z\n\3\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\5\4\u0081\n\4\3\5\3\5\3\5\3\5\5\5\u0087")
        buf.write(u"\n\5\3\6\3\6\3\6\3\6\3\6\5\6\u008e\n\6\3\7\3\7\3\7\3")
        buf.write(u"\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7\u009f")
        buf.write(u"\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00a9\n\b\3")
        buf.write(u"\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t\u00b6")
        buf.write(u"\n\t\3\n\3\n\3\n\3\n\5\n\u00bc\n\n\3\13\3\13\3\13\5\13")
        buf.write(u"\u00c1\n\13\3\f\3\f\3\f\3\f\5\f\u00c7\n\f\3\r\3\r\3\r")
        buf.write(u"\3\16\3\16\3\16\5\16\u00cf\n\16\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\5\17\u00db\n\17\3\20\3\20")
        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u00e7\n")
        buf.write(u"\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write(u"\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u00f9\n\21\3\22\3")
        buf.write(u"\22\3\22\3\23\3\23\3\23\3\23\3\23\5\23\u0103\n\23\3\24")
        buf.write(u"\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u010c\n\24\3\25\3")
        buf.write(u"\25\3\25\5\25\u0111\n\25\3\26\3\26\3\26\5\26\u0116\n")
        buf.write(u"\26\3\27\3\27\3\27\5\27\u011b\n\27\3\30\3\30\3\31\3\31")
        buf.write(u"\5\31\u0121\n\31\3\32\3\32\3\33\3\33\3\33\3\33\3\33\3")
        buf.write(u"\33\3\33\3\33\3\33\3\33\3\33\5\33\u0130\n\33\3\34\3\34")
        buf.write(u"\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3")
        buf.write(u"\35\3\35\3\35\5\35\u0141\n\35\3\36\3\36\3\37\3\37\3 ")
        buf.write(u"\3 \3!\3!\3!\3!\3!\3!\3!\3!\3!\5!\u0152\n!\3\"\3\"\3")
        buf.write(u"\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\5\"\u0161")
        buf.write(u"\n\"\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\5#\u0171")
        buf.write(u"\n#\3$\3$\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\5%\u0180\n")
        buf.write(u"%\3&\3&\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3")
        buf.write(u"\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u0196\n\'\3(\3(\3(\3(")
        buf.write(u"\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u01a6\n(\3)\3)\3)\3")
        buf.write(u")\3)\3)\3)\3)\3)\3)\3)\5)\u01b3\n)\3*\3*\3+\3+\3,\3,")
        buf.write(u"\3,\3,\3,\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3")
        buf.write(u"-\3-\3-\5-\u01cf\n-\3.\3.\3.\3.\3.\3.\3.\3.\3.\3.\5.")
        buf.write(u"\u01db\n.\3/\3/\3/\3/\3/\3\60\3\60\3\60\3\60\3\60\3\60")
        buf.write(u"\3\60\3\60\3\60\3\60\3\60\5\60\u01ed\n\60\3\61\3\61\3")
        buf.write(u"\61\3\61\3\61\3\62\3\62\3\62\3\62\3\62\3\62\5\62\u01fa")
        buf.write(u"\n\62\3\63\3\63\3\63\3\63\3\63\3\63\5\63\u0202\n\63\3")
        buf.write(u"\64\3\64\3\64\3\64\3\64\3\64\3\64\5\64\u020b\n\64\3\65")
        buf.write(u"\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3")
        buf.write(u"\65\5\65\u0219\n\65\3\66\3\66\3\66\3\66\3\66\3\66\5\66")
        buf.write(u"\u0221\n\66\3\67\3\67\3\67\3\67\3\67\3\67\5\67\u0229")
        buf.write(u"\n\67\38\38\38\2\29\2\4\6\b\n\f\16\20\22\24\26\30\32")
        buf.write(u"\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdf")
        buf.write(u"hjln\2\3\3\2\26\27\2\u0254\2s\3\2\2\2\4y\3\2\2\2\6\u0080")
        buf.write(u"\3\2\2\2\b\u0086\3\2\2\2\n\u008d\3\2\2\2\f\u009e\3\2")
        buf.write(u"\2\2\16\u00a8\3\2\2\2\20\u00b5\3\2\2\2\22\u00bb\3\2\2")
        buf.write(u"\2\24\u00c0\3\2\2\2\26\u00c6\3\2\2\2\30\u00c8\3\2\2\2")
        buf.write(u"\32\u00ce\3\2\2\2\34\u00da\3\2\2\2\36\u00e6\3\2\2\2 ")
        buf.write(u"\u00f8\3\2\2\2\"\u00fa\3\2\2\2$\u0102\3\2\2\2&\u010b")
        buf.write(u"\3\2\2\2(\u0110\3\2\2\2*\u0115\3\2\2\2,\u011a\3\2\2\2")
        buf.write(u".\u011c\3\2\2\2\60\u0120\3\2\2\2\62\u0122\3\2\2\2\64")
        buf.write(u"\u012f\3\2\2\2\66\u0131\3\2\2\28\u0140\3\2\2\2:\u0142")
        buf.write(u"\3\2\2\2<\u0144\3\2\2\2>\u0146\3\2\2\2@\u0151\3\2\2\2")
        buf.write(u"B\u0160\3\2\2\2D\u0170\3\2\2\2F\u0172\3\2\2\2H\u017f")
        buf.write(u"\3\2\2\2J\u0181\3\2\2\2L\u0195\3\2\2\2N\u01a5\3\2\2\2")
        buf.write(u"P\u01b2\3\2\2\2R\u01b4\3\2\2\2T\u01b6\3\2\2\2V\u01b8")
        buf.write(u"\3\2\2\2X\u01ce\3\2\2\2Z\u01da\3\2\2\2\\\u01dc\3\2\2")
        buf.write(u"\2^\u01ec\3\2\2\2`\u01ee\3\2\2\2b\u01f9\3\2\2\2d\u0201")
        buf.write(u"\3\2\2\2f\u020a\3\2\2\2h\u0218\3\2\2\2j\u0220\3\2\2\2")
        buf.write(u"l\u0228\3\2\2\2n\u022a\3\2\2\2pt\5\4\3\2qt\5\6\4\2rt")
        buf.write(u"\5\b\5\2sp\3\2\2\2sq\3\2\2\2sr\3\2\2\2t\3\3\2\2\2uz\5")
        buf.write(u"\34\17\2vz\5\36\20\2wz\5,\27\2xz\5 \21\2yu\3\2\2\2yv")
        buf.write(u"\3\2\2\2yw\3\2\2\2yx\3\2\2\2z\5\3\2\2\2{\u0081\5P)\2")
        buf.write(u"|\u0081\5T+\2}\u0081\5> \2~\u0081\5H%\2\177\u0081\5\64")
        buf.write(u"\33\2\u0080{\3\2\2\2\u0080|\3\2\2\2\u0080}\3\2\2\2\u0080")
        buf.write(u"~\3\2\2\2\u0080\177\3\2\2\2\u0081\7\3\2\2\2\u0082\u0087")
        buf.write(u"\5\32\16\2\u0083\u0087\5\30\r\2\u0084\u0087\5\26\f\2")
        buf.write(u"\u0085\u0087\5\24\13\2\u0086\u0082\3\2\2\2\u0086\u0083")
        buf.write(u"\3\2\2\2\u0086\u0084\3\2\2\2\u0086\u0085\3\2\2\2\u0087")
        buf.write(u"\t\3\2\2\2\u0088\u0089\7\13\2\2\u0089\u008e\5 \21\2\u008a")
        buf.write(u"\u008b\7\t\2\2\u008b\u008e\5\"\22\2\u008c\u008e\7)\2")
        buf.write(u"\2\u008d\u0088\3\2\2\2\u008d\u008a\3\2\2\2\u008d\u008c")
        buf.write(u"\3\2\2\2\u008e\13\3\2\2\2\u008f\u0090\7\n\2\2\u0090\u009f")
        buf.write(u"\5L\'\2\u0091\u0092\7\n\2\2\u0092\u009f\5\34\17\2\u0093")
        buf.write(u"\u0094\7\f\2\2\u0094\u0095\5\f\7\2\u0095\u0096\7*\2\2")
        buf.write(u"\u0096\u0097\5\f\7\2\u0097\u009f\3\2\2\2\u0098\u0099")
        buf.write(u"\7\13\2\2\u0099\u009f\5@!\2\u009a\u009b\7\t\2\2\u009b")
        buf.write(u"\u009f\5$\23\2\u009c\u009f\5\n\6\2\u009d\u009f\7)\2\2")
        buf.write(u"\u009e\u008f\3\2\2\2\u009e\u0091\3\2\2\2\u009e\u0093")
        buf.write(u"\3\2\2\2\u009e\u0098\3\2\2\2\u009e\u009a\3\2\2\2\u009e")
        buf.write(u"\u009c\3\2\2\2\u009e\u009d\3\2\2\2\u009f\r\3\2\2\2\u00a0")
        buf.write(u"\u00a1\7\3\2\2\u00a1\u00a9\5L\'\2\u00a2\u00a3\7\3\2\2")
        buf.write(u"\u00a3\u00a9\5B\"\2\u00a4\u00a9\5\f\7\2\u00a5\u00a6\7")
        buf.write(u"\t\2\2\u00a6\u00a9\5&\24\2\u00a7\u00a9\7)\2\2\u00a8\u00a0")
        buf.write(u"\3\2\2\2\u00a8\u00a2\3\2\2\2\u00a8\u00a4\3\2\2\2\u00a8")
        buf.write(u"\u00a5\3\2\2\2\u00a8\u00a7\3\2\2\2\u00a9\17\3\2\2\2\u00aa")
        buf.write(u"\u00ab\7\5\2\2\u00ab\u00b6\5N(\2\u00ac\u00ad\7\4\2\2")
        buf.write(u"\u00ad\u00b6\5N(\2\u00ae\u00af\7\5\2\2\u00af\u00b6\5")
        buf.write(u"D#\2\u00b0\u00b1\7\4\2\2\u00b1\u00b6\5D#\2\u00b2\u00b3")
        buf.write(u"\7\t\2\2\u00b3\u00b6\5(\25\2\u00b4\u00b6\5\16\b\2\u00b5")
        buf.write(u"\u00aa\3\2\2\2\u00b5\u00ac\3\2\2\2\u00b5\u00ae\3\2\2")
        buf.write(u"\2\u00b5\u00b0\3\2\2\2\u00b5\u00b2\3\2\2\2\u00b5\u00b4")
        buf.write(u"\3\2\2\2\u00b6\21\3\2\2\2\u00b7\u00bc\5\20\t\2\u00b8")
        buf.write(u"\u00b9\7\t\2\2\u00b9\u00bc\5*\26\2\u00ba\u00bc\7\'\2")
        buf.write(u"\2\u00bb\u00b7\3\2\2\2\u00bb\u00b8\3\2\2\2\u00bb\u00ba")
        buf.write(u"\3\2\2\2\u00bc\23\3\2\2\2\u00bd\u00be\7\t\2\2\u00be\u00c1")
        buf.write(u"\5,\27\2\u00bf\u00c1\5\22\n\2\u00c0\u00bd\3\2\2\2\u00c0")
        buf.write(u"\u00bf\3\2\2\2\u00c1\25\3\2\2\2\u00c2\u00c3\7\7\2\2\u00c3")
        buf.write(u"\u00c7\5\34\17\2\u00c4\u00c5\7\t\2\2\u00c5\u00c7\5\36")
        buf.write(u"\20\2\u00c6\u00c2\3\2\2\2\u00c6\u00c4\3\2\2\2\u00c7\27")
        buf.write(u"\3\2\2\2\u00c8\u00c9\7\t\2\2\u00c9\u00ca\5\34\17\2\u00ca")
        buf.write(u"\31\3\2\2\2\u00cb\u00cc\7\t\2\2\u00cc\u00cf\5 \21\2\u00cd")
        buf.write(u"\u00cf\7+\2\2\u00ce\u00cb\3\2\2\2\u00ce\u00cd\3\2\2\2")
        buf.write(u"\u00cf\33\3\2\2\2\u00d0\u00d1\7\b\2\2\u00d1\u00db\5\26")
        buf.write(u"\f\2\u00d2\u00d3\7\16\2\2\u00d3\u00db\5L\'\2\u00d4\u00d5")
        buf.write(u"\7\16\2\2\u00d5\u00db\5N(\2\u00d6\u00d7\7\16\2\2\u00d7")
        buf.write(u"\u00db\5J&\2\u00d8\u00d9\7\16\2\2\u00d9\u00db\5P)\2\u00da")
        buf.write(u"\u00d0\3\2\2\2\u00da\u00d2\3\2\2\2\u00da\u00d4\3\2\2")
        buf.write(u"\2\u00da\u00d6\3\2\2\2\u00da\u00d8\3\2\2\2\u00db\35\3")
        buf.write(u"\2\2\2\u00dc\u00dd\7\16\2\2\u00dd\u00e7\5.\30\2\u00de")
        buf.write(u"\u00df\7\16\2\2\u00df\u00e7\5R*\2\u00e0\u00e1\7\16\2")
        buf.write(u"\2\u00e1\u00e7\5\60\31\2\u00e2\u00e3\7\16\2\2\u00e3\u00e7")
        buf.write(u"\5P)\2\u00e4\u00e5\7\17\2\2\u00e5\u00e7\5\64\33\2\u00e6")
        buf.write(u"\u00dc\3\2\2\2\u00e6\u00de\3\2\2\2\u00e6\u00e0\3\2\2")
        buf.write(u"\2\u00e6\u00e2\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e7\37\3")
        buf.write(u"\2\2\2\u00e8\u00e9\7\16\2\2\u00e9\u00f9\5\64\33\2\u00ea")
        buf.write(u"\u00eb\7\16\2\2\u00eb\u00f9\5@!\2\u00ec\u00ed\7\16\2")
        buf.write(u"\2\u00ed\u00f9\5B\"\2\u00ee\u00ef\7\16\2\2\u00ef\u00f9")
        buf.write(u"\5D#\2\u00f0\u00f1\7\16\2\2\u00f1\u00f9\5F$\2\u00f2\u00f3")
        buf.write(u"\7\16\2\2\u00f3\u00f9\5H%\2\u00f4\u00f5\7\16\2\2\u00f5")
        buf.write(u"\u00f9\5^\60\2\u00f6\u00f7\7\17\2\2\u00f7\u00f9\5^\60")
        buf.write(u"\2\u00f8\u00e8\3\2\2\2\u00f8\u00ea\3\2\2\2\u00f8\u00ec")
        buf.write(u"\3\2\2\2\u00f8\u00ee\3\2\2\2\u00f8\u00f0\3\2\2\2\u00f8")
        buf.write(u"\u00f2\3\2\2\2\u00f8\u00f4\3\2\2\2\u00f8\u00f6\3\2\2")
        buf.write(u"\2\u00f9!\3\2\2\2\u00fa\u00fb\7\17\2\2\u00fb\u00fc\5")
        buf.write(u"8\35\2\u00fc#\3\2\2\2\u00fd\u00fe\7\17\2\2\u00fe\u0103")
        buf.write(u"\5@!\2\u00ff\u0100\7\17\2\2\u0100\u0103\5:\36\2\u0101")
        buf.write(u"\u0103\5\"\22\2\u0102\u00fd\3\2\2\2\u0102\u00ff\3\2\2")
        buf.write(u"\2\u0102\u0101\3\2\2\2\u0103%\3\2\2\2\u0104\u0105\7\16")
        buf.write(u"\2\2\u0105\u010c\5\66\34\2\u0106\u0107\7\17\2\2\u0107")
        buf.write(u"\u010c\5B\"\2\u0108\u0109\7\17\2\2\u0109\u010c\5L\'\2")
        buf.write(u"\u010a\u010c\5$\23\2\u010b\u0104\3\2\2\2\u010b\u0106")
        buf.write(u"\3\2\2\2\u010b\u0108\3\2\2\2\u010b\u010a\3\2\2\2\u010c")
        buf.write(u"\'\3\2\2\2\u010d\u010e\7\16\2\2\u010e\u0111\5\62\32\2")
        buf.write(u"\u010f\u0111\5&\24\2\u0110\u010d\3\2\2\2\u0110\u010f")
        buf.write(u"\3\2\2\2\u0111)\3\2\2\2\u0112\u0113\7\16\2\2\u0113\u0116")
        buf.write(u"\5<\37\2\u0114\u0116\5(\25\2\u0115\u0112\3\2\2\2\u0115")
        buf.write(u"\u0114\3\2\2\2\u0116+\3\2\2\2\u0117\u0118\7\16\2\2\u0118")
        buf.write(u"\u011b\5> \2\u0119\u011b\5*\26\2\u011a\u0117\3\2\2\2")
        buf.write(u"\u011a\u0119\3\2\2\2\u011b-\3\2\2\2\u011c\u011d\7\37")
        buf.write(u"\2\2\u011d/\3\2\2\2\u011e\u0121\7 \2\2\u011f\u0121\5")
        buf.write(u".\30\2\u0120\u011e\3\2\2\2\u0120\u011f\3\2\2\2\u0121")
        buf.write(u"\61\3\2\2\2\u0122\u0123\7!\2\2\u0123\63\3\2\2\2\u0124")
        buf.write(u"\u0125\7\20\2\2\u0125\u0126\5\64\33\2\u0126\u0127\7*")
        buf.write(u"\2\2\u0127\u0128\5\32\16\2\u0128\u0130\3\2\2\2\u0129")
        buf.write(u"\u012a\7\22\2\2\u012a\u012b\5\64\33\2\u012b\u012c\7*")
        buf.write(u"\2\2\u012c\u012d\5 \21\2\u012d\u0130\3\2\2\2\u012e\u0130")
        buf.write(u"\7#\2\2\u012f\u0124\3\2\2\2\u012f\u0129\3\2\2\2\u012f")
        buf.write(u"\u012e\3\2\2\2\u0130\65\3\2\2\2\u0131\u0132\7$\2\2\u0132")
        buf.write(u"\67\3\2\2\2\u0133\u0134\7\20\2\2\u0134\u0135\58\35\2")
        buf.write(u"\u0135\u0136\7*\2\2\u0136\u0137\5\32\16\2\u0137\u0141")
        buf.write(u"\3\2\2\2\u0138\u0139\7\22\2\2\u0139\u013a\58\35\2\u013a")
        buf.write(u"\u013b\7*\2\2\u013b\u013c\5 \21\2\u013c\u0141\3\2\2\2")
        buf.write(u"\u013d\u013e\7\25\2\2\u013e\u0141\5V,\2\u013f\u0141\7")
        buf.write(u"%\2\2\u0140\u0133\3\2\2\2\u0140\u0138\3\2\2\2\u0140\u013d")
        buf.write(u"\3\2\2\2\u0140\u013f\3\2\2\2\u01419\3\2\2\2\u0142\u0143")
        buf.write(u"\7&\2\2\u0143;\3\2\2\2\u0144\u0145\5\62\32\2\u0145=\3")
        buf.write(u"\2\2\2\u0146\u0147\5<\37\2\u0147?\3\2\2\2\u0148\u0149")
        buf.write(u"\7\22\2\2\u0149\u014a\5@!\2\u014a\u014b\7*\2\2\u014b")
        buf.write(u"\u014c\5 \21\2\u014c\u0152\3\2\2\2\u014d\u014e\7\24\2")
        buf.write(u"\2\u014e\u0152\5X-\2\u014f\u0152\7\"\2\2\u0150\u0152")
        buf.write(u"\58\35\2\u0151\u0148\3\2\2\2\u0151\u014d\3\2\2\2\u0151")
        buf.write(u"\u014f\3\2\2\2\u0151\u0150\3\2\2\2\u0152A\3\2\2\2\u0153")
        buf.write(u"\u0154\7\21\2\2\u0154\u0155\5B\"\2\u0155\u0156\7*\2\2")
        buf.write(u"\u0156\u0157\5\16\b\2\u0157\u0161\3\2\2\2\u0158\u0159")
        buf.write(u"\7\22\2\2\u0159\u015a\5B\"\2\u015a\u015b\7*\2\2\u015b")
        buf.write(u"\u015c\5 \21\2\u015c\u0161\3\2\2\2\u015d\u015e\7\24\2")
        buf.write(u"\2\u015e\u0161\5l\67\2\u015f\u0161\5@!\2\u0160\u0153")
        buf.write(u"\3\2\2\2\u0160\u0158\3\2\2\2\u0160\u015d\3\2\2\2\u0160")
        buf.write(u"\u015f\3\2\2\2\u0161C\3\2\2\2\u0162\u0163\7\21\2\2\u0163")
        buf.write(u"\u0164\5D#\2\u0164\u0165\7*\2\2\u0165\u0166\5\20\t\2")
        buf.write(u"\u0166\u0171\3\2\2\2\u0167\u0168\7\22\2\2\u0168\u0169")
        buf.write(u"\5D#\2\u0169\u016a\7*\2\2\u016a\u016b\5 \21\2\u016b\u0171")
        buf.write(u"\3\2\2\2\u016c\u016d\5n8\2\u016d\u016e\5j\66\2\u016e")
        buf.write(u"\u0171\3\2\2\2\u016f\u0171\5B\"\2\u0170\u0162\3\2\2\2")
        buf.write(u"\u0170\u0167\3\2\2\2\u0170\u016c\3\2\2\2\u0170\u016f")
        buf.write(u"\3\2\2\2\u0171E\3\2\2\2\u0172\u0173\5D#\2\u0173G\3\2")
        buf.write(u"\2\2\u0174\u0175\7\20\2\2\u0175\u0176\5H%\2\u0176\u0177")
        buf.write(u"\7*\2\2\u0177\u0178\5\24\13\2\u0178\u0180\3\2\2\2\u0179")
        buf.write(u"\u017a\7\22\2\2\u017a\u017b\5H%\2\u017b\u017c\7*\2\2")
        buf.write(u"\u017c\u017d\5 \21\2\u017d\u0180\3\2\2\2\u017e\u0180")
        buf.write(u"\5F$\2\u017f\u0174\3\2\2\2\u017f\u0179\3\2\2\2\u017f")
        buf.write(u"\u017e\3\2\2\2\u0180I\3\2\2\2\u0181\u0182\5N(\2\u0182")
        buf.write(u"K\3\2\2\2\u0183\u0184\7\r\2\2\u0184\u0185\5.\30\2\u0185")
        buf.write(u"\u0186\7*\2\2\u0186\u0187\5\34\17\2\u0187\u0196\3\2\2")
        buf.write(u"\2\u0188\u0189\7\21\2\2\u0189\u018a\5L\'\2\u018a\u018b")
        buf.write(u"\7*\2\2\u018b\u018c\5\16\b\2\u018c\u0196\3\2\2\2\u018d")
        buf.write(u"\u018e\7\22\2\2\u018e\u018f\5L\'\2\u018f\u0190\7*\2\2")
        buf.write(u"\u0190\u0191\5\34\17\2\u0191\u0196\3\2\2\2\u0192\u0193")
        buf.write(u"\7\24\2\2\u0193\u0196\5b\62\2\u0194\u0196\5:\36\2\u0195")
        buf.write(u"\u0183\3\2\2\2\u0195\u0188\3\2\2\2\u0195\u018d\3\2\2")
        buf.write(u"\2\u0195\u0192\3\2\2\2\u0195\u0194\3\2\2\2\u0196M\3\2")
        buf.write(u"\2\2\u0197\u0198\7\21\2\2\u0198\u0199\5N(\2\u0199\u019a")
        buf.write(u"\7*\2\2\u019a\u019b\5\20\t\2\u019b\u01a6\3\2\2\2\u019c")
        buf.write(u"\u019d\7\22\2\2\u019d\u019e\5N(\2\u019e\u019f\7*\2\2")
        buf.write(u"\u019f\u01a0\5\34\17\2\u01a0\u01a6\3\2\2\2\u01a1\u01a2")
        buf.write(u"\5n8\2\u01a2\u01a3\5d\63\2\u01a3\u01a6\3\2\2\2\u01a4")
        buf.write(u"\u01a6\5L\'\2\u01a5\u0197\3\2\2\2\u01a5\u019c\3\2\2\2")
        buf.write(u"\u01a5\u01a1\3\2\2\2\u01a5\u01a4\3\2\2\2\u01a6O\3\2\2")
        buf.write(u"\2\u01a7\u01a8\7\20\2\2\u01a8\u01a9\5P)\2\u01a9\u01aa")
        buf.write(u"\7*\2\2\u01aa\u01ab\5\24\13\2\u01ab\u01b3\3\2\2\2\u01ac")
        buf.write(u"\u01ad\7\22\2\2\u01ad\u01ae\5P)\2\u01ae\u01af\7*\2\2")
        buf.write(u"\u01af\u01b0\5\34\17\2\u01b0\u01b3\3\2\2\2\u01b1\u01b3")
        buf.write(u"\5J&\2\u01b2\u01a7\3\2\2\2\u01b2\u01ac\3\2\2\2\u01b2")
        buf.write(u"\u01b1\3\2\2\2\u01b3Q\3\2\2\2\u01b4\u01b5\5.\30\2\u01b5")
        buf.write(u"S\3\2\2\2\u01b6\u01b7\5\60\31\2\u01b7U\3\2\2\2\u01b8")
        buf.write(u"\u01b9\7\23\2\2\u01b9\u01ba\5^\60\2\u01ba\u01bb\7*\2")
        buf.write(u"\2\u01bb\u01bc\58\35\2\u01bcW\3\2\2\2\u01bd\u01be\7\30")
        buf.write(u"\2\2\u01be\u01bf\5\64\33\2\u01bf\u01c0\7*\2\2\u01c0\u01c1")
        buf.write(u"\5\64\33\2\u01c1\u01cf\3\2\2\2\u01c2\u01c3\7\35\2\2\u01c3")
        buf.write(u"\u01c4\5 \21\2\u01c4\u01c5\7*\2\2\u01c5\u01c6\5 \21\2")
        buf.write(u"\u01c6\u01c7\7*\2\2\u01c7\u01c8\5X-\2\u01c8\u01cf\3\2")
        buf.write(u"\2\2\u01c9\u01ca\7\23\2\2\u01ca\u01cb\5^\60\2\u01cb\u01cc")
        buf.write(u"\7*\2\2\u01cc\u01cd\5@!\2\u01cd\u01cf\3\2\2\2\u01ce\u01bd")
        buf.write(u"\3\2\2\2\u01ce\u01c2\3\2\2\2\u01ce\u01c9\3\2\2\2\u01cf")
        buf.write(u"Y\3\2\2\2\u01d0\u01d1\7\31\2\2\u01d1\u01d2\5\34\17\2")
        buf.write(u"\u01d2\u01d3\7*\2\2\u01d3\u01d4\5\34\17\2\u01d4\u01db")
        buf.write(u"\3\2\2\2\u01d5\u01d6\7\23\2\2\u01d6\u01d7\5f\64\2\u01d7")
        buf.write(u"\u01d8\7*\2\2\u01d8\u01d9\5:\36\2\u01d9\u01db\3\2\2\2")
        buf.write(u"\u01da\u01d0\3\2\2\2\u01da\u01d5\3\2\2\2\u01db[\3\2\2")
        buf.write(u"\2\u01dc\u01dd\7\32\2\2\u01dd\u01de\5\34\17\2\u01de\u01df")
        buf.write(u"\7*\2\2\u01df\u01e0\5 \21\2\u01e0]\3\2\2\2\u01e1\u01e2")
        buf.write(u"\7\33\2\2\u01e2\u01e3\5\64\33\2\u01e3\u01e4\7*\2\2\u01e4")
        buf.write(u"\u01e5\5\64\33\2\u01e5\u01ed\3\2\2\2\u01e6\u01e7\7\20")
        buf.write(u"\2\2\u01e7\u01e8\5^\60\2\u01e8\u01e9\7*\2\2\u01e9\u01ea")
        buf.write(u"\5\22\n\2\u01ea\u01ed\3\2\2\2\u01eb\u01ed\5j\66\2\u01ec")
        buf.write(u"\u01e1\3\2\2\2\u01ec\u01e6\3\2\2\2\u01ec\u01eb\3\2\2")
        buf.write(u"\2\u01ed_\3\2\2\2\u01ee\u01ef\7\34\2\2\u01ef\u01f0\5")
        buf.write(u"\34\17\2\u01f0\u01f1\7*\2\2\u01f1\u01f2\5\64\33\2\u01f2")
        buf.write(u"a\3\2\2\2\u01f3\u01f4\7\23\2\2\u01f4\u01f5\5f\64\2\u01f5")
        buf.write(u"\u01f6\7*\2\2\u01f6\u01f7\5L\'\2\u01f7\u01fa\3\2\2\2")
        buf.write(u"\u01f8\u01fa\5Z.\2\u01f9\u01f3\3\2\2\2\u01f9\u01f8\3")
        buf.write(u"\2\2\2\u01fac\3\2\2\2\u01fb\u01fc\7\21\2\2\u01fc\u01fd")
        buf.write(u"\5d\63\2\u01fd\u01fe\7*\2\2\u01fe\u01ff\5\20\t\2\u01ff")
        buf.write(u"\u0202\3\2\2\2\u0200\u0202\5b\62\2\u0201\u01fb\3\2\2")
        buf.write(u"\2\u0201\u0200\3\2\2\2\u0202e\3\2\2\2\u0203\u0204\7\20")
        buf.write(u"\2\2\u0204\u0205\5f\64\2\u0205\u0206\7*\2\2\u0206\u0207")
        buf.write(u"\5\22\n\2\u0207\u020b\3\2\2\2\u0208\u020b\5h\65\2\u0209")
        buf.write(u"\u020b\5d\63\2\u020a\u0203\3\2\2\2\u020a\u0208\3\2\2")
        buf.write(u"\2\u020a\u0209\3\2\2\2\u020bg\3\2\2\2\u020c\u020d\7\36")
        buf.write(u"\2\2\u020d\u020e\5\34\17\2\u020e\u020f\7*\2\2\u020f\u0210")
        buf.write(u"\5\34\17\2\u0210\u0211\7*\2\2\u0211\u0212\5B\"\2\u0212")
        buf.write(u"\u0219\3\2\2\2\u0213\u0214\7\20\2\2\u0214\u0215\5h\65")
        buf.write(u"\2\u0215\u0216\7*\2\2\u0216\u0217\7(\2\2\u0217\u0219")
        buf.write(u"\3\2\2\2\u0218\u020c\3\2\2\2\u0218\u0213\3\2\2\2\u0219")
        buf.write(u"i\3\2\2\2\u021a\u021b\7\21\2\2\u021b\u021c\5j\66\2\u021c")
        buf.write(u"\u021d\7*\2\2\u021d\u021e\5\20\t\2\u021e\u0221\3\2\2")
        buf.write(u"\2\u021f\u0221\5l\67\2\u0220\u021a\3\2\2\2\u0220\u021f")
        buf.write(u"\3\2\2\2\u0221k\3\2\2\2\u0222\u0223\7\23\2\2\u0223\u0224")
        buf.write(u"\5^\60\2\u0224\u0225\7*\2\2\u0225\u0226\5B\"\2\u0226")
        buf.write(u"\u0229\3\2\2\2\u0227\u0229\5X-\2\u0228\u0222\3\2\2\2")
        buf.write(u"\u0228\u0227\3\2\2\2\u0229m\3\2\2\2\u022a\u022b\t\2\2")
        buf.write(u"\2\u022bo\3\2\2\2)sy\u0080\u0086\u008d\u009e\u00a8\u00b5")
        buf.write(u"\u00bb\u00c0\u00c6\u00ce\u00da\u00e6\u00f8\u0102\u010b")
        buf.write(u"\u0110\u0115\u011a\u0120\u012f\u0140\u0151\u0160\u0170")
        buf.write(u"\u017f\u0195\u01a5\u01b2\u01ce\u01da\u01ec\u01f9\u0201")
        buf.write(u"\u020a\u0218\u0220\u0228")
        return buf.getvalue()


class TransformationAlgebraParser ( Parser ):

    grammarFileName = "TransformationAlgebra.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'avg '", u"'min '", u"'max '", u"'sum '", 
                     u"'reify '", u"'deify '", u"'get '", u"'fcont '", u"'ocont '", 
                     u"'ratio '", u"'interpol '", u"'pi1 '", u"'pi2 '", 
                     u"'sigmae '", u"'sigmale '", u"'bowtie '", u"'bowtie* '", 
                     u"'groupby_avg '", u"'groupby_sum '", u"'groupby_min '", 
                     u"'groupby_max '", u"'odist '", u"'ldist '", u"'lodist '", 
                     u"'otopo '", u"'lotopo '", u"'ndist '", u"'lvis '", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"'in'", u"<INVALID>", u"<INVALID>", u"' '" ]

    symbolicNames = [ u"<INVALID>", u"AVG", u"MIN", u"MAX", u"SUM", u"REIFY", 
                      u"DEIFY", u"GET", u"FCONT", u"OCONT", u"RATIO", u"INTERPOL", 
                      u"PI1", u"PI2", u"SIGMAE2", u"SIGMASE2", u"BOWTIE", 
                      u"BOWTIESTAR", u"GROUPBYAVG", u"GROUPBYSUM", u"GROUPBYMIN", 
                      u"GROUPBYMAX", u"ODIST", u"LDIST", u"LODIST", u"OTOPO", 
                      u"LOTOPO", u"NDIST", u"LVIS", u"DATAPM", u"DATAAMOUNT", 
                      u"DATACONTOUR", u"DATAOBJQ", u"DATAOBJS", u"DATACONTOURLINE", 
                      u"DATAOBJCOUNT", u"DATAFIELD", u"TOPOV", u"BOOLV", 
                      u"DATAV", u"WHITESPACE", u"KEYWORD", u"WS" ]

    RULE_start = 0
    RULE_r = 1
    RULE_rr = 2
    RULE_v = 3
    RULE_countv = 4
    RULE_ratiov = 5
    RULE_intv = 6
    RULE_ordv = 7
    RULE_nomv = 8
    RULE_qv = 9
    RULE_sv = 10
    RULE_lv = 11
    RULE_ov = 12
    RULE_l = 13
    RULE_s = 14
    RULE_o = 15
    RULE_count = 16
    RULE_ratio = 17
    RULE_intt = 18
    RULE_ordinal = 19
    RULE_nom = 20
    RULE_q = 21
    RULE_sint = 22
    RULE_snom = 23
    RULE_ords = 24
    RULE_os = 25
    RULE_ints = 26
    RULE_ocount = 27
    RULE_lratio = 28
    RULE_noms = 29
    RULE_qs = 30
    RULE_oratio = 31
    RULE_oint = 32
    RULE_oord = 33
    RULE_onom = 34
    RULE_oq = 35
    RULE_lnom = 36
    RULE_lint = 37
    RULE_lord = 38
    RULE_lq = 39
    RULE_sord = 40
    RULE_sq = 41
    RULE_ocounto = 42
    RULE_oratioo = 43
    RULE_lratiol = 44
    RULE_lratioo = 45
    RULE_onomo = 46
    RULE_lnomo = 47
    RULE_lintl = 48
    RULE_lordl = 49
    RULE_lnoml = 50
    RULE_lbooll = 51
    RULE_oordo = 52
    RULE_ointo = 53
    RULE_groupbyaggord = 54

    ruleNames =  [ u"start", u"r", u"rr", u"v", u"countv", u"ratiov", u"intv", 
                   u"ordv", u"nomv", u"qv", u"sv", u"lv", u"ov", u"l", u"s", 
                   u"o", u"count", u"ratio", u"intt", u"ordinal", u"nom", 
                   u"q", u"sint", u"snom", u"ords", u"os", u"ints", u"ocount", 
                   u"lratio", u"noms", u"qs", u"oratio", u"oint", u"oord", 
                   u"onom", u"oq", u"lnom", u"lint", u"lord", u"lq", u"sord", 
                   u"sq", u"ocounto", u"oratioo", u"lratiol", u"lratioo", 
                   u"onomo", u"lnomo", u"lintl", u"lordl", u"lnoml", u"lbooll", 
                   u"oordo", u"ointo", u"groupbyaggord" ]

    EOF = Token.EOF
    AVG=1
    MIN=2
    MAX=3
    SUM=4
    REIFY=5
    DEIFY=6
    GET=7
    FCONT=8
    OCONT=9
    RATIO=10
    INTERPOL=11
    PI1=12
    PI2=13
    SIGMAE2=14
    SIGMASE2=15
    BOWTIE=16
    BOWTIESTAR=17
    GROUPBYAVG=18
    GROUPBYSUM=19
    GROUPBYMIN=20
    GROUPBYMAX=21
    ODIST=22
    LDIST=23
    LODIST=24
    OTOPO=25
    LOTOPO=26
    NDIST=27
    LVIS=28
    DATAPM=29
    DATAAMOUNT=30
    DATACONTOUR=31
    DATAOBJQ=32
    DATAOBJS=33
    DATACONTOURLINE=34
    DATAOBJCOUNT=35
    DATAFIELD=36
    TOPOV=37
    BOOLV=38
    DATAV=39
    WHITESPACE=40
    KEYWORD=41
    WS=42

    def __init__(self, input, output=sys.stdout):
        super(TransformationAlgebraParser, self).__init__(input, output=output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.StartContext, self).__init__(parent, invokingState)
            self.parser = parser

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RrContext,0)


        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.VContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_start

        def enterRule(self, listener):
            if hasattr(listener, "enterStart"):
                listener.enterStart(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStart"):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DEIFY, TransformationAlgebraParser.PI1, TransformationAlgebraParser.PI2]:
                self.state = 110
                self.r()
                pass
            elif token in [TransformationAlgebraParser.INTERPOL, TransformationAlgebraParser.SIGMAE2, TransformationAlgebraParser.SIGMASE2, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.GROUPBYAVG, TransformationAlgebraParser.GROUPBYSUM, TransformationAlgebraParser.GROUPBYMIN, TransformationAlgebraParser.GROUPBYMAX, TransformationAlgebraParser.DATAPM, TransformationAlgebraParser.DATAAMOUNT, TransformationAlgebraParser.DATACONTOUR, TransformationAlgebraParser.DATAOBJQ, TransformationAlgebraParser.DATAOBJS, TransformationAlgebraParser.DATAOBJCOUNT, TransformationAlgebraParser.DATAFIELD]:
                self.state = 111
                self.rr()
                pass
            elif token in [TransformationAlgebraParser.AVG, TransformationAlgebraParser.MIN, TransformationAlgebraParser.MAX, TransformationAlgebraParser.REIFY, TransformationAlgebraParser.GET, TransformationAlgebraParser.FCONT, TransformationAlgebraParser.OCONT, TransformationAlgebraParser.RATIO, TransformationAlgebraParser.TOPOV, TransformationAlgebraParser.DATAV, TransformationAlgebraParser.KEYWORD]:
                self.state = 112
                self.v()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RContext, self).__init__(parent, invokingState)
            self.parser = parser

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_r

        def enterRule(self, listener):
            if hasattr(listener, "enterR"):
                listener.enterR(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitR"):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_r)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 115
                self.l()
                pass

            elif la_ == 2:
                self.state = 116
                self.s()
                pass

            elif la_ == 3:
                self.state = 117
                self.q()
                pass

            elif la_ == 4:
                self.state = 118
                self.o()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RrContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def sq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SqContext,0)


        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_rr

        def enterRule(self, listener):
            if hasattr(listener, "enterRr"):
                listener.enterRr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRr"):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 121
                self.lq()
                pass

            elif la_ == 2:
                self.state = 122
                self.sq()
                pass

            elif la_ == 3:
                self.state = 123
                self.qs()
                pass

            elif la_ == 4:
                self.state = 124
                self.oq()
                pass

            elif la_ == 5:
                self.state = 125
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.VContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def lv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LvContext,0)


        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_v

        def enterRule(self, listener):
            if hasattr(listener, "enterV"):
                listener.enterV(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitV"):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_v)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 128
                self.ov()
                pass

            elif la_ == 2:
                self.state = 129
                self.lv()
                pass

            elif la_ == 3:
                self.state = 130
                self.sv()
                pass

            elif la_ == 4:
                self.state = 131
                self.qv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_countv

        def enterRule(self, listener):
            if hasattr(listener, "enterCountv"):
                listener.enterCountv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCountv"):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_countv)
        try:
            self.state = 139
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OCONT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 134
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 135
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 136
                self.match(TransformationAlgebraParser.GET)
                self.state = 137
                self.count()
                pass
            elif token in [TransformationAlgebraParser.DATAV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 138
                self.match(TransformationAlgebraParser.DATAV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatiovContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatiovContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FCONT(self):
            return self.getToken(TransformationAlgebraParser.FCONT, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def RATIO(self):
            return self.getToken(TransformationAlgebraParser.RATIO, 0)

        def ratiov(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.RatiovContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountvContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratiov

        def enterRule(self, listener):
            if hasattr(listener, "enterRatiov"):
                listener.enterRatiov(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatiov"):
                listener.exitRatiov(self)




    def ratiov(self):

        localctx = TransformationAlgebraParser.RatiovContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ratiov)
        try:
            self.state = 156
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 141
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 142
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 143
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 144
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 145
                self.match(TransformationAlgebraParser.RATIO)
                self.state = 146
                self.ratiov()
                self.state = 147
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 148
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 150
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 151
                self.oratio()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 152
                self.match(TransformationAlgebraParser.GET)
                self.state = 153
                self.ratio()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 154
                self.countv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 155
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def ratiov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intv

        def enterRule(self, listener):
            if hasattr(listener, "enterIntv"):
                listener.enterIntv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntv"):
                listener.exitIntv(self)




    def intv(self):

        localctx = TransformationAlgebraParser.IntvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_intv)
        try:
            self.state = 166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 158
                self.match(TransformationAlgebraParser.AVG)
                self.state = 159
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 160
                self.match(TransformationAlgebraParser.AVG)
                self.state = 161
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 162
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 163
                self.match(TransformationAlgebraParser.GET)
                self.state = 164
                self.intt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 165
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MAX(self):
            return self.getToken(TransformationAlgebraParser.MAX, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def MIN(self):
            return self.getToken(TransformationAlgebraParser.MIN, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordv

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdv"):
                listener.enterOrdv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdv"):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ordv)
        try:
            self.state = 179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 168
                self.match(TransformationAlgebraParser.MAX)
                self.state = 169
                self.lord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.match(TransformationAlgebraParser.MIN)
                self.state = 171
                self.lord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 172
                self.match(TransformationAlgebraParser.MAX)
                self.state = 173
                self.oord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 174
                self.match(TransformationAlgebraParser.MIN)
                self.state = 175
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 176
                self.match(TransformationAlgebraParser.GET)
                self.state = 177
                self.ordinal()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 178
                self.intv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def TOPOV(self):
            return self.getToken(TransformationAlgebraParser.TOPOV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nomv

        def enterRule(self, listener):
            if hasattr(listener, "enterNomv"):
                listener.enterNomv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNomv"):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nomv)
        try:
            self.state = 185
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 181
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 182
                self.match(TransformationAlgebraParser.GET)
                self.state = 183
                self.nom()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 184
                self.match(TransformationAlgebraParser.TOPOV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qv

        def enterRule(self, listener):
            if hasattr(listener, "enterQv"):
                listener.enterQv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQv"):
                listener.exitQv(self)




    def qv(self):

        localctx = TransformationAlgebraParser.QvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_qv)
        try:
            self.state = 190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 187
                self.match(TransformationAlgebraParser.GET)
                self.state = 188
                self.q()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 189
                self.nomv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REIFY(self):
            return self.getToken(TransformationAlgebraParser.REIFY, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sv

        def enterRule(self, listener):
            if hasattr(listener, "enterSv"):
                listener.enterSv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSv"):
                listener.exitSv(self)




    def sv(self):

        localctx = TransformationAlgebraParser.SvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sv)
        try:
            self.state = 196
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.REIFY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 192
                self.match(TransformationAlgebraParser.REIFY)
                self.state = 193
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 194
                self.match(TransformationAlgebraParser.GET)
                self.state = 195
                self.s()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lv

        def enterRule(self, listener):
            if hasattr(listener, "enterLv"):
                listener.enterLv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLv"):
                listener.exitLv(self)




    def lv(self):

        localctx = TransformationAlgebraParser.LvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_lv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(TransformationAlgebraParser.GET)
            self.state = 199
            self.l()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def KEYWORD(self):
            return self.getToken(TransformationAlgebraParser.KEYWORD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ov

        def enterRule(self, listener):
            if hasattr(listener, "enterOv"):
                listener.enterOv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOv"):
                listener.exitOv(self)




    def ov(self):

        localctx = TransformationAlgebraParser.OvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ov)
        try:
            self.state = 204
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 201
                self.match(TransformationAlgebraParser.GET)
                self.state = 202
                self.o()
                pass
            elif token in [TransformationAlgebraParser.KEYWORD]:
                self.enterOuterAlt(localctx, 2)
                self.state = 203
                self.match(TransformationAlgebraParser.KEYWORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DEIFY(self):
            return self.getToken(TransformationAlgebraParser.DEIFY, 0)

        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_l

        def enterRule(self, listener):
            if hasattr(listener, "enterL"):
                listener.enterL(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitL"):
                listener.exitL(self)




    def l(self):

        localctx = TransformationAlgebraParser.LContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_l)
        try:
            self.state = 216
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 206
                self.match(TransformationAlgebraParser.DEIFY)
                self.state = 207
                self.sv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 208
                self.match(TransformationAlgebraParser.PI1)
                self.state = 209
                self.lint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 210
                self.match(TransformationAlgebraParser.PI1)
                self.state = 211
                self.lord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 212
                self.match(TransformationAlgebraParser.PI1)
                self.state = 213
                self.lnom()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 214
                self.match(TransformationAlgebraParser.PI1)
                self.state = 215
                self.lq()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def sord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SordContext,0)


        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_s

        def enterRule(self, listener):
            if hasattr(listener, "enterS"):
                listener.enterS(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitS"):
                listener.exitS(self)




    def s(self):

        localctx = TransformationAlgebraParser.SContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_s)
        try:
            self.state = 228
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 218
                self.match(TransformationAlgebraParser.PI1)
                self.state = 219
                self.sint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 220
                self.match(TransformationAlgebraParser.PI1)
                self.state = 221
                self.sord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 222
                self.match(TransformationAlgebraParser.PI1)
                self.state = 223
                self.snom()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 224
                self.match(TransformationAlgebraParser.PI1)
                self.state = 225
                self.lq()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 226
                self.match(TransformationAlgebraParser.PI2)
                self.state = 227
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_o

        def enterRule(self, listener):
            if hasattr(listener, "enterO"):
                listener.enterO(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitO"):
                listener.exitO(self)




    def o(self):

        localctx = TransformationAlgebraParser.OContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_o)
        try:
            self.state = 246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 230
                self.match(TransformationAlgebraParser.PI1)
                self.state = 231
                self.os()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 232
                self.match(TransformationAlgebraParser.PI1)
                self.state = 233
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 234
                self.match(TransformationAlgebraParser.PI1)
                self.state = 235
                self.oint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 236
                self.match(TransformationAlgebraParser.PI1)
                self.state = 237
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 238
                self.match(TransformationAlgebraParser.PI1)
                self.state = 239
                self.onom()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 240
                self.match(TransformationAlgebraParser.PI1)
                self.state = 241
                self.oq()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 242
                self.match(TransformationAlgebraParser.PI1)
                self.state = 243
                self.onomo()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 244
                self.match(TransformationAlgebraParser.PI2)
                self.state = 245
                self.onomo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_count

        def enterRule(self, listener):
            if hasattr(listener, "enterCount"):
                listener.enterCount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCount"):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 248
            self.match(TransformationAlgebraParser.PI2)
            self.state = 249
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratio

        def enterRule(self, listener):
            if hasattr(listener, "enterRatio"):
                listener.enterRatio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatio"):
                listener.exitRatio(self)




    def ratio(self):

        localctx = TransformationAlgebraParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ratio)
        try:
            self.state = 256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 251
                self.match(TransformationAlgebraParser.PI2)
                self.state = 252
                self.oratio()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 253
                self.match(TransformationAlgebraParser.PI2)
                self.state = 254
                self.lratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 255
                self.count()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InttContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.InttContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ints(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntsContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intt

        def enterRule(self, listener):
            if hasattr(listener, "enterIntt"):
                listener.enterIntt(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntt"):
                listener.exitIntt(self)




    def intt(self):

        localctx = TransformationAlgebraParser.InttContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_intt)
        try:
            self.state = 265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 258
                self.match(TransformationAlgebraParser.PI1)
                self.state = 259
                self.ints()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 260
                self.match(TransformationAlgebraParser.PI2)
                self.state = 261
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 262
                self.match(TransformationAlgebraParser.PI2)
                self.state = 263
                self.lint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 264
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdinalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdinalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordinal

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdinal"):
                listener.enterOrdinal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdinal"):
                listener.exitOrdinal(self)




    def ordinal(self):

        localctx = TransformationAlgebraParser.OrdinalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordinal)
        try:
            self.state = 270
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 267
                self.match(TransformationAlgebraParser.PI1)
                self.state = 268
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 269
                self.intt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nom

        def enterRule(self, listener):
            if hasattr(listener, "enterNom"):
                listener.enterNom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNom"):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_nom)
        try:
            self.state = 275
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 272
                self.match(TransformationAlgebraParser.PI1)
                self.state = 273
                self.noms()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 274
                self.ordinal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_q

        def enterRule(self, listener):
            if hasattr(listener, "enterQ"):
                listener.enterQ(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQ"):
                listener.exitQ(self)




    def q(self):

        localctx = TransformationAlgebraParser.QContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_q)
        try:
            self.state = 280
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 277
                self.match(TransformationAlgebraParser.PI1)
                self.state = 278
                self.qs()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 279
                self.nom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAPM(self):
            return self.getToken(TransformationAlgebraParser.DATAPM, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sint

        def enterRule(self, listener):
            if hasattr(listener, "enterSint"):
                listener.enterSint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSint"):
                listener.exitSint(self)




    def sint(self):

        localctx = TransformationAlgebraParser.SintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(TransformationAlgebraParser.DATAPM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAAMOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAAMOUNT, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_snom

        def enterRule(self, listener):
            if hasattr(listener, "enterSnom"):
                listener.enterSnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSnom"):
                listener.exitSnom(self)




    def snom(self):

        localctx = TransformationAlgebraParser.SnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_snom)
        try:
            self.state = 286
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DATAAMOUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 284
                self.match(TransformationAlgebraParser.DATAAMOUNT)
                pass
            elif token in [TransformationAlgebraParser.DATAPM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 285
                self.sint()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOUR(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOUR, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ords

        def enterRule(self, listener):
            if hasattr(listener, "enterOrds"):
                listener.enterOrds(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrds"):
                listener.exitOrds(self)




    def ords(self):

        localctx = TransformationAlgebraParser.OrdsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_ords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(TransformationAlgebraParser.DATACONTOUR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def DATAOBJS(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJS, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_os

        def enterRule(self, listener):
            if hasattr(listener, "enterOs"):
                listener.enterOs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOs"):
                listener.exitOs(self)




    def os(self):

        localctx = TransformationAlgebraParser.OsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_os)
        try:
            self.state = 301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 290
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 291
                self.os()
                self.state = 292
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 293
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 296
                self.os()
                self.state = 297
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 298
                self.o()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 300
                self.match(TransformationAlgebraParser.DATAOBJS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOURLINE(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOURLINE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ints

        def enterRule(self, listener):
            if hasattr(listener, "enterInts"):
                listener.enterInts(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInts"):
                listener.exitInts(self)




    def ints(self):

        localctx = TransformationAlgebraParser.IntsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_ints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(TransformationAlgebraParser.DATACONTOURLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYSUM(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYSUM, 0)

        def ocounto(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountoContext,0)


        def DATAOBJCOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJCOUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocount

        def enterRule(self, listener):
            if hasattr(listener, "enterOcount"):
                listener.enterOcount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcount"):
                listener.exitOcount(self)




    def ocount(self):

        localctx = TransformationAlgebraParser.OcountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ocount)
        try:
            self.state = 318
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 305
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 306
                self.ocount()
                self.state = 307
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 308
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 310
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 311
                self.ocount()
                self.state = 312
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 313
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYSUM]:
                self.enterOuterAlt(localctx, 3)
                self.state = 315
                self.match(TransformationAlgebraParser.GROUPBYSUM)
                self.state = 316
                self.ocounto()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJCOUNT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 317
                self.match(TransformationAlgebraParser.DATAOBJCOUNT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAFIELD(self):
            return self.getToken(TransformationAlgebraParser.DATAFIELD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratio

        def enterRule(self, listener):
            if hasattr(listener, "enterLratio"):
                listener.enterLratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratio"):
                listener.exitLratio(self)




    def lratio(self):

        localctx = TransformationAlgebraParser.LratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_lratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            self.match(TransformationAlgebraParser.DATAFIELD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_noms

        def enterRule(self, listener):
            if hasattr(listener, "enterNoms"):
                listener.enterNoms(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNoms"):
                listener.exitNoms(self)




    def noms(self):

        localctx = TransformationAlgebraParser.NomsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_noms)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 322
            self.ords()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qs

        def enterRule(self, listener):
            if hasattr(listener, "enterQs"):
                listener.enterQs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQs"):
                listener.exitQs(self)




    def qs(self):

        localctx = TransformationAlgebraParser.QsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_qs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.noms()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def DATAOBJQ(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJQ, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratio

        def enterRule(self, listener):
            if hasattr(listener, "enterOratio"):
                listener.enterOratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratio"):
                listener.exitOratio(self)




    def oratio(self):

        localctx = TransformationAlgebraParser.OratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_oratio)
        try:
            self.state = 335
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 326
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 327
                self.oratio()
                self.state = 328
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 329
                self.o()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 331
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 332
                self.oratioo()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 333
                self.match(TransformationAlgebraParser.DATAOBJQ)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 334
                self.ocount()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oint

        def enterRule(self, listener):
            if hasattr(listener, "enterOint"):
                listener.enterOint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOint"):
                listener.exitOint(self)




    def oint(self):

        localctx = TransformationAlgebraParser.OintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_oint)
        try:
            self.state = 350
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 337
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 338
                self.oint()
                self.state = 339
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 340
                self.intv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 342
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 343
                self.oint()
                self.state = 344
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 345
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 347
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 348
                self.ointo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 349
                self.oratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oord

        def enterRule(self, listener):
            if hasattr(listener, "enterOord"):
                listener.enterOord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOord"):
                listener.exitOord(self)




    def oord(self):

        localctx = TransformationAlgebraParser.OordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_oord)
        try:
            self.state = 366
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 352
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 353
                self.oord()
                self.state = 354
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 355
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 357
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 358
                self.oord()
                self.state = 359
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 360
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 362
                self.groupbyaggord()
                self.state = 363
                self.oordo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 365
                self.oint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onom

        def enterRule(self, listener):
            if hasattr(listener, "enterOnom"):
                listener.enterOnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnom"):
                listener.exitOnom(self)




    def onom(self):

        localctx = TransformationAlgebraParser.OnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_onom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 368
            self.oord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oq

        def enterRule(self, listener):
            if hasattr(listener, "enterOq"):
                listener.enterOq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOq"):
                listener.exitOq(self)




    def oq(self):

        localctx = TransformationAlgebraParser.OqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_oq)
        try:
            self.state = 381
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 370
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 371
                self.oq()
                self.state = 372
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 373
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 375
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 376
                self.oq()
                self.state = 377
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 378
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 380
                self.onom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnom

        def enterRule(self, listener):
            if hasattr(listener, "enterLnom"):
                listener.enterLnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnom"):
                listener.exitLnom(self)




    def lnom(self):

        localctx = TransformationAlgebraParser.LnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_lnom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.lord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTERPOL(self):
            return self.getToken(TransformationAlgebraParser.INTERPOL, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def GROUPBYAVG(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYAVG, 0)

        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lint

        def enterRule(self, listener):
            if hasattr(listener, "enterLint"):
                listener.enterLint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLint"):
                listener.exitLint(self)




    def lint(self):

        localctx = TransformationAlgebraParser.LintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_lint)
        try:
            self.state = 403
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INTERPOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 385
                self.match(TransformationAlgebraParser.INTERPOL)
                self.state = 386
                self.sint()
                self.state = 387
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 388
                self.l()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 390
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 391
                self.lint()
                self.state = 392
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 393
                self.intv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 395
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 396
                self.lint()
                self.state = 397
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 398
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GROUPBYAVG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 400
                self.match(TransformationAlgebraParser.GROUPBYAVG)
                self.state = 401
                self.lintl()
                pass
            elif token in [TransformationAlgebraParser.DATAFIELD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 402
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def groupbyaggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.GroupbyaggordContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lord

        def enterRule(self, listener):
            if hasattr(listener, "enterLord"):
                listener.enterLord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLord"):
                listener.exitLord(self)




    def lord(self):

        localctx = TransformationAlgebraParser.LordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_lord)
        try:
            self.state = 419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 405
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 406
                self.lord()
                self.state = 407
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 408
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 410
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 411
                self.lord()
                self.state = 412
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 413
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 415
                self.groupbyaggord()
                self.state = 416
                self.lordl()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 418
                self.lint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lq

        def enterRule(self, listener):
            if hasattr(listener, "enterLq"):
                listener.enterLq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLq"):
                listener.exitLq(self)




    def lq(self):

        localctx = TransformationAlgebraParser.LqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_lq)
        try:
            self.state = 432
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 421
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 422
                self.lq()
                self.state = 423
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 424
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 426
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 427
                self.lq()
                self.state = 428
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 429
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 431
                self.lnom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sord

        def enterRule(self, listener):
            if hasattr(listener, "enterSord"):
                listener.enterSord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSord"):
                listener.exitSord(self)




    def sord(self):

        localctx = TransformationAlgebraParser.SordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_sord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 434
            self.sint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sq

        def enterRule(self, listener):
            if hasattr(listener, "enterSq"):
                listener.enterSq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSq"):
                listener.exitSq(self)




    def sq(self):

        localctx = TransformationAlgebraParser.SqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_sq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            self.snom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocounto

        def enterRule(self, listener):
            if hasattr(listener, "enterOcounto"):
                listener.enterOcounto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcounto"):
                listener.exitOcounto(self)




    def ocounto(self):

        localctx = TransformationAlgebraParser.OcountoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_ocounto)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self.match(TransformationAlgebraParser.BOWTIESTAR)
            self.state = 439
            self.onomo()
            self.state = 440
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 441
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ODIST(self):
            return self.getToken(TransformationAlgebraParser.ODIST, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def NDIST(self):
            return self.getToken(TransformationAlgebraParser.NDIST, 0)

        def o(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OContext,i)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterOratioo"):
                listener.enterOratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratioo"):
                listener.exitOratioo(self)




    def oratioo(self):

        localctx = TransformationAlgebraParser.OratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_oratioo)
        try:
            self.state = 460
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.ODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 443
                self.match(TransformationAlgebraParser.ODIST)
                self.state = 444
                self.os()
                self.state = 445
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 446
                self.os()
                pass
            elif token in [TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 448
                self.match(TransformationAlgebraParser.NDIST)
                self.state = 449
                self.o()
                self.state = 450
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 451
                self.o()
                self.state = 452
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 453
                self.oratioo()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 455
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 456
                self.onomo()
                self.state = 457
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 458
                self.oratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiolContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiolContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LDIST(self):
            return self.getToken(TransformationAlgebraParser.LDIST, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratiol

        def enterRule(self, listener):
            if hasattr(listener, "enterLratiol"):
                listener.enterLratiol(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratiol"):
                listener.exitLratiol(self)




    def lratiol(self):

        localctx = TransformationAlgebraParser.LratiolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_lratiol)
        try:
            self.state = 472
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 462
                self.match(TransformationAlgebraParser.LDIST)
                self.state = 463
                self.l()
                self.state = 464
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 465
                self.l()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 467
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 468
                self.lnoml()
                self.state = 469
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 470
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LODIST(self):
            return self.getToken(TransformationAlgebraParser.LODIST, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterLratioo"):
                listener.enterLratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratioo"):
                listener.exitLratioo(self)




    def lratioo(self):

        localctx = TransformationAlgebraParser.LratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_lratioo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.match(TransformationAlgebraParser.LODIST)
            self.state = 475
            self.l()
            self.state = 476
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 477
            self.o()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OTOPO(self):
            return self.getToken(TransformationAlgebraParser.OTOPO, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onomo

        def enterRule(self, listener):
            if hasattr(listener, "enterOnomo"):
                listener.enterOnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnomo"):
                listener.exitOnomo(self)




    def onomo(self):

        localctx = TransformationAlgebraParser.OnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_onomo)
        try:
            self.state = 490
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 479
                self.match(TransformationAlgebraParser.OTOPO)
                self.state = 480
                self.os()
                self.state = 481
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 482
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 484
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 485
                self.onomo()
                self.state = 486
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 487
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE2, TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 489
                self.oordo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LOTOPO(self):
            return self.getToken(TransformationAlgebraParser.LOTOPO, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnomo

        def enterRule(self, listener):
            if hasattr(listener, "enterLnomo"):
                listener.enterLnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnomo"):
                listener.exitLnomo(self)




    def lnomo(self):

        localctx = TransformationAlgebraParser.LnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_lnomo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 492
            self.match(TransformationAlgebraParser.LOTOPO)
            self.state = 493
            self.l()
            self.state = 494
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 495
            self.os()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratiol(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiolContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lintl

        def enterRule(self, listener):
            if hasattr(listener, "enterLintl"):
                listener.enterLintl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLintl"):
                listener.exitLintl(self)




    def lintl(self):

        localctx = TransformationAlgebraParser.LintlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_lintl)
        try:
            self.state = 503
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 497
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 498
                self.lnoml()
                self.state = 499
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 500
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 502
                self.lratiol()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lordl

        def enterRule(self, listener):
            if hasattr(listener, "enterLordl"):
                listener.enterLordl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLordl"):
                listener.exitLordl(self)




    def lordl(self):

        localctx = TransformationAlgebraParser.LordlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_lordl)
        try:
            self.state = 511
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 505
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 506
                self.lordl()
                self.state = 507
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 508
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 510
                self.lintl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnoml

        def enterRule(self, listener):
            if hasattr(listener, "enterLnoml"):
                listener.enterLnoml(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnoml"):
                listener.exitLnoml(self)




    def lnoml(self):

        localctx = TransformationAlgebraParser.LnomlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_lnoml)
        try:
            self.state = 520
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 513
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 514
                self.lnoml()
                self.state = 515
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 516
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 518
                self.lbooll()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 519
                self.lordl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LboollContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LboollContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LVIS(self):
            return self.getToken(TransformationAlgebraParser.LVIS, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def BOOLV(self):
            return self.getToken(TransformationAlgebraParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lbooll

        def enterRule(self, listener):
            if hasattr(listener, "enterLbooll"):
                listener.enterLbooll(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLbooll"):
                listener.exitLbooll(self)




    def lbooll(self):

        localctx = TransformationAlgebraParser.LboollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_lbooll)
        try:
            self.state = 534
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LVIS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 522
                self.match(TransformationAlgebraParser.LVIS)
                self.state = 523
                self.l()
                self.state = 524
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 525
                self.l()
                self.state = 526
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 527
                self.oint()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 529
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 530
                self.lbooll()
                self.state = 531
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 532
                self.match(TransformationAlgebraParser.BOOLV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oordo

        def enterRule(self, listener):
            if hasattr(listener, "enterOordo"):
                listener.enterOordo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOordo"):
                listener.exitOordo(self)




    def oordo(self):

        localctx = TransformationAlgebraParser.OordoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_oordo)
        try:
            self.state = 542
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 536
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 537
                self.oordo()
                self.state = 538
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 539
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIESTAR, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 541
                self.ointo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIESTAR(self):
            return self.getToken(TransformationAlgebraParser.BOWTIESTAR, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ointo

        def enterRule(self, listener):
            if hasattr(listener, "enterOinto"):
                listener.enterOinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOinto"):
                listener.exitOinto(self)




    def ointo(self):

        localctx = TransformationAlgebraParser.OintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_ointo)
        try:
            self.state = 550
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 544
                self.match(TransformationAlgebraParser.BOWTIESTAR)
                self.state = 545
                self.onomo()
                self.state = 546
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 547
                self.oint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 549
                self.oratioo()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupbyaggordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.GroupbyaggordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GROUPBYMIN(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMIN, 0)

        def GROUPBYMAX(self):
            return self.getToken(TransformationAlgebraParser.GROUPBYMAX, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_groupbyaggord

        def enterRule(self, listener):
            if hasattr(listener, "enterGroupbyaggord"):
                listener.enterGroupbyaggord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGroupbyaggord"):
                listener.exitGroupbyaggord(self)




    def groupbyaggord(self):

        localctx = TransformationAlgebraParser.GroupbyaggordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_groupbyaggord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            _la = self._input.LA(1)
            if not(_la==TransformationAlgebraParser.GROUPBYMIN or _la==TransformationAlgebraParser.GROUPBYMAX):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





