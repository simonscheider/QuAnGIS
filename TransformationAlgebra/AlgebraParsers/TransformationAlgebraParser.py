# Generated from TransformationAlgebra.g4 by ANTLR 4.8
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"&\u0210\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t")
        buf.write(u"\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$")
        buf.write(u"\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t")
        buf.write(u",\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63")
        buf.write(u"\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\3")
        buf.write(u"\2\3\2\3\2\5\2t\n\2\3\3\3\3\3\3\3\3\5\3z\n\3\3\4\3\4")
        buf.write(u"\3\4\3\4\3\4\5\4\u0081\n\4\3\5\3\5\3\5\3\5\5\5\u0087")
        buf.write(u"\n\5\3\6\3\6\3\6\3\6\3\6\5\6\u008e\n\6\3\7\3\7\3\7\3")
        buf.write(u"\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7\u009f")
        buf.write(u"\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00a9\n\b\3")
        buf.write(u"\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t\u00b6")
        buf.write(u"\n\t\3\n\3\n\3\n\5\n\u00bb\n\n\3\13\3\13\3\13\5\13\u00c0")
        buf.write(u"\n\13\3\f\3\f\3\f\3\f\5\f\u00c6\n\f\3\r\3\r\3\r\3\16")
        buf.write(u"\3\16\3\16\5\16\u00ce\n\16\3\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\17\3\17\3\17\3\17\3\17\5\17\u00da\n\17\3\20\3\20\3\20")
        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u00e6\n\20\3")
        buf.write(u"\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write(u"\3\21\5\21\u00f4\n\21\3\22\3\22\3\22\3\23\3\23\3\23\3")
        buf.write(u"\23\3\23\5\23\u00fe\n\23\3\24\3\24\3\24\3\24\3\24\3\24")
        buf.write(u"\3\24\5\24\u0107\n\24\3\25\3\25\3\25\5\25\u010c\n\25")
        buf.write(u"\3\26\3\26\3\26\5\26\u0111\n\26\3\27\3\27\3\27\5\27\u0116")
        buf.write(u"\n\27\3\30\3\30\3\31\3\31\5\31\u011c\n\31\3\32\3\32\3")
        buf.write(u"\33\3\33\3\33\3\33\3\33\3\33\5\33\u0126\n\33\3\34\3\34")
        buf.write(u"\3\35\3\35\3\35\3\35\3\35\3\35\5\35\u0130\n\35\3\36\3")
        buf.write(u"\36\3\37\3\37\3 \3 \3!\3!\3!\3!\3!\3!\3!\3!\3!\5!\u0141")
        buf.write(u"\n!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write(u"\"\3\"\5\"\u0151\n\"\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3")
        buf.write(u"#\3#\3#\3#\3#\5#\u0162\n#\3$\3$\3%\3%\3%\3%\3%\3%\3%")
        buf.write(u"\3%\3%\3%\3%\5%\u0171\n%\3&\3&\3\'\3\'\3\'\3\'\3\'\3")
        buf.write(u"\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u0185")
        buf.write(u"\n\'\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(")
        buf.write(u"\u0196\n(\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\5)\u01a3\n")
        buf.write(u")\3*\3*\3+\3+\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\5,")
        buf.write(u"\u01b5\n,\3-\3-\3-\3-\3-\3.\3.\3.\3.\3.\3/\3/\3/\3/\3")
        buf.write(u"/\3/\3/\3/\3/\3/\3/\5/\u01cc\n/\3\60\3\60\3\60\3\60\3")
        buf.write(u"\60\3\61\3\61\3\61\3\61\3\61\3\61\5\61\u01d9\n\61\3\62")
        buf.write(u"\3\62\3\62\3\62\3\62\3\62\5\62\u01e1\n\62\3\63\3\63\3")
        buf.write(u"\63\3\63\3\63\3\63\3\63\5\63\u01ea\n\63\3\64\3\64\3\64")
        buf.write(u"\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64\5\64\u01f8")
        buf.write(u"\n\64\3\65\3\65\3\65\3\65\3\65\3\65\5\65\u0200\n\65\3")
        buf.write(u"\66\3\66\3\66\3\66\3\66\3\66\5\66\u0208\n\66\3\67\3\67")
        buf.write(u"\5\67\u020c\n\67\38\38\38\2\29\2\4\6\b\n\f\16\20\22\24")
        buf.write(u"\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTV")
        buf.write(u"XZ\\^`bdfhjln\2\3\3\2\5\6\2\u022f\2s\3\2\2\2\4y\3\2\2")
        buf.write(u"\2\6\u0080\3\2\2\2\b\u0086\3\2\2\2\n\u008d\3\2\2\2\f")
        buf.write(u"\u009e\3\2\2\2\16\u00a8\3\2\2\2\20\u00b5\3\2\2\2\22\u00ba")
        buf.write(u"\3\2\2\2\24\u00bf\3\2\2\2\26\u00c5\3\2\2\2\30\u00c7\3")
        buf.write(u"\2\2\2\32\u00cd\3\2\2\2\34\u00d9\3\2\2\2\36\u00e5\3\2")
        buf.write(u"\2\2 \u00f3\3\2\2\2\"\u00f5\3\2\2\2$\u00fd\3\2\2\2&\u0106")
        buf.write(u"\3\2\2\2(\u010b\3\2\2\2*\u0110\3\2\2\2,\u0115\3\2\2\2")
        buf.write(u".\u0117\3\2\2\2\60\u011b\3\2\2\2\62\u011d\3\2\2\2\64")
        buf.write(u"\u0125\3\2\2\2\66\u0127\3\2\2\28\u012f\3\2\2\2:\u0131")
        buf.write(u"\3\2\2\2<\u0133\3\2\2\2>\u0135\3\2\2\2@\u0140\3\2\2\2")
        buf.write(u"B\u0150\3\2\2\2D\u0161\3\2\2\2F\u0163\3\2\2\2H\u0170")
        buf.write(u"\3\2\2\2J\u0172\3\2\2\2L\u0184\3\2\2\2N\u0195\3\2\2\2")
        buf.write(u"P\u01a2\3\2\2\2R\u01a4\3\2\2\2T\u01a6\3\2\2\2V\u01b4")
        buf.write(u"\3\2\2\2X\u01b6\3\2\2\2Z\u01bb\3\2\2\2\\\u01cb\3\2\2")
        buf.write(u"\2^\u01cd\3\2\2\2`\u01d8\3\2\2\2b\u01e0\3\2\2\2d\u01e9")
        buf.write(u"\3\2\2\2f\u01f7\3\2\2\2h\u01ff\3\2\2\2j\u0207\3\2\2\2")
        buf.write(u"l\u020b\3\2\2\2n\u020d\3\2\2\2pt\5\4\3\2qt\5\6\4\2rt")
        buf.write(u"\5\b\5\2sp\3\2\2\2sq\3\2\2\2sr\3\2\2\2t\3\3\2\2\2uz\5")
        buf.write(u"\34\17\2vz\5\36\20\2wz\5,\27\2xz\5 \21\2yu\3\2\2\2yv")
        buf.write(u"\3\2\2\2yw\3\2\2\2yx\3\2\2\2z\5\3\2\2\2{\u0081\5P)\2")
        buf.write(u"|\u0081\5T+\2}\u0081\5> \2~\u0081\5H%\2\177\u0081\5\64")
        buf.write(u"\33\2\u0080{\3\2\2\2\u0080|\3\2\2\2\u0080}\3\2\2\2\u0080")
        buf.write(u"~\3\2\2\2\u0080\177\3\2\2\2\u0081\7\3\2\2\2\u0082\u0087")
        buf.write(u"\5\32\16\2\u0083\u0087\5\30\r\2\u0084\u0087\5\26\f\2")
        buf.write(u"\u0085\u0087\5\24\13\2\u0086\u0082\3\2\2\2\u0086\u0083")
        buf.write(u"\3\2\2\2\u0086\u0084\3\2\2\2\u0086\u0085\3\2\2\2\u0087")
        buf.write(u"\t\3\2\2\2\u0088\u0089\7\13\2\2\u0089\u008e\5 \21\2\u008a")
        buf.write(u"\u008b\7\t\2\2\u008b\u008e\5\"\22\2\u008c\u008e\7#\2")
        buf.write(u"\2\u008d\u0088\3\2\2\2\u008d\u008a\3\2\2\2\u008d\u008c")
        buf.write(u"\3\2\2\2\u008e\13\3\2\2\2\u008f\u0090\7\n\2\2\u0090\u009f")
        buf.write(u"\5L\'\2\u0091\u0092\7\n\2\2\u0092\u009f\5\34\17\2\u0093")
        buf.write(u"\u0094\7\f\2\2\u0094\u0095\5\f\7\2\u0095\u0096\7$\2\2")
        buf.write(u"\u0096\u0097\5\f\7\2\u0097\u009f\3\2\2\2\u0098\u0099")
        buf.write(u"\7\13\2\2\u0099\u009f\5@!\2\u009a\u009b\7\t\2\2\u009b")
        buf.write(u"\u009f\5$\23\2\u009c\u009f\5\n\6\2\u009d\u009f\7#\2\2")
        buf.write(u"\u009e\u008f\3\2\2\2\u009e\u0091\3\2\2\2\u009e\u0093")
        buf.write(u"\3\2\2\2\u009e\u0098\3\2\2\2\u009e\u009a\3\2\2\2\u009e")
        buf.write(u"\u009c\3\2\2\2\u009e\u009d\3\2\2\2\u009f\r\3\2\2\2\u00a0")
        buf.write(u"\u00a1\7\4\2\2\u00a1\u00a9\5L\'\2\u00a2\u00a3\7\4\2\2")
        buf.write(u"\u00a3\u00a9\5B\"\2\u00a4\u00a9\5\f\7\2\u00a5\u00a6\7")
        buf.write(u"\t\2\2\u00a6\u00a9\5&\24\2\u00a7\u00a9\7#\2\2\u00a8\u00a0")
        buf.write(u"\3\2\2\2\u00a8\u00a2\3\2\2\2\u00a8\u00a4\3\2\2\2\u00a8")
        buf.write(u"\u00a5\3\2\2\2\u00a8\u00a7\3\2\2\2\u00a9\17\3\2\2\2\u00aa")
        buf.write(u"\u00ab\7\6\2\2\u00ab\u00b6\5N(\2\u00ac\u00ad\7\5\2\2")
        buf.write(u"\u00ad\u00b6\5N(\2\u00ae\u00af\7\6\2\2\u00af\u00b6\5")
        buf.write(u"D#\2\u00b0\u00b1\7\5\2\2\u00b1\u00b6\5D#\2\u00b2\u00b3")
        buf.write(u"\7\t\2\2\u00b3\u00b6\5(\25\2\u00b4\u00b6\5\16\b\2\u00b5")
        buf.write(u"\u00aa\3\2\2\2\u00b5\u00ac\3\2\2\2\u00b5\u00ae\3\2\2")
        buf.write(u"\2\u00b5\u00b0\3\2\2\2\u00b5\u00b2\3\2\2\2\u00b5\u00b4")
        buf.write(u"\3\2\2\2\u00b6\21\3\2\2\2\u00b7\u00bb\5\20\t\2\u00b8")
        buf.write(u"\u00b9\7\t\2\2\u00b9\u00bb\5*\26\2\u00ba\u00b7\3\2\2")
        buf.write(u"\2\u00ba\u00b8\3\2\2\2\u00bb\23\3\2\2\2\u00bc\u00bd\7")
        buf.write(u"\t\2\2\u00bd\u00c0\5,\27\2\u00be\u00c0\5\22\n\2\u00bf")
        buf.write(u"\u00bc\3\2\2\2\u00bf\u00be\3\2\2\2\u00c0\25\3\2\2\2\u00c1")
        buf.write(u"\u00c2\7\7\2\2\u00c2\u00c6\5\34\17\2\u00c3\u00c4\7\t")
        buf.write(u"\2\2\u00c4\u00c6\5\36\20\2\u00c5\u00c1\3\2\2\2\u00c5")
        buf.write(u"\u00c3\3\2\2\2\u00c6\27\3\2\2\2\u00c7\u00c8\7\t\2\2\u00c8")
        buf.write(u"\u00c9\5\34\17\2\u00c9\31\3\2\2\2\u00ca\u00cb\7\t\2\2")
        buf.write(u"\u00cb\u00ce\5 \21\2\u00cc\u00ce\7%\2\2\u00cd\u00ca\3")
        buf.write(u"\2\2\2\u00cd\u00cc\3\2\2\2\u00ce\33\3\2\2\2\u00cf\u00d0")
        buf.write(u"\7\b\2\2\u00d0\u00da\5\26\f\2\u00d1\u00d2\7\16\2\2\u00d2")
        buf.write(u"\u00da\5L\'\2\u00d3\u00d4\7\16\2\2\u00d4\u00da\5N(\2")
        buf.write(u"\u00d5\u00d6\7\16\2\2\u00d6\u00da\5J&\2\u00d7\u00d8\7")
        buf.write(u"\16\2\2\u00d8\u00da\5P)\2\u00d9\u00cf\3\2\2\2\u00d9\u00d1")
        buf.write(u"\3\2\2\2\u00d9\u00d3\3\2\2\2\u00d9\u00d5\3\2\2\2\u00d9")
        buf.write(u"\u00d7\3\2\2\2\u00da\35\3\2\2\2\u00db\u00dc\7\16\2\2")
        buf.write(u"\u00dc\u00e6\5.\30\2\u00dd\u00de\7\16\2\2\u00de\u00e6")
        buf.write(u"\5R*\2\u00df\u00e0\7\16\2\2\u00e0\u00e6\5\60\31\2\u00e1")
        buf.write(u"\u00e2\7\16\2\2\u00e2\u00e6\5P)\2\u00e3\u00e4\7\17\2")
        buf.write(u"\2\u00e4\u00e6\5\64\33\2\u00e5\u00db\3\2\2\2\u00e5\u00dd")
        buf.write(u"\3\2\2\2\u00e5\u00df\3\2\2\2\u00e5\u00e1\3\2\2\2\u00e5")
        buf.write(u"\u00e3\3\2\2\2\u00e6\37\3\2\2\2\u00e7\u00e8\7\16\2\2")
        buf.write(u"\u00e8\u00f4\5\64\33\2\u00e9\u00ea\7\16\2\2\u00ea\u00f4")
        buf.write(u"\5@!\2\u00eb\u00ec\7\16\2\2\u00ec\u00f4\5B\"\2\u00ed")
        buf.write(u"\u00ee\7\16\2\2\u00ee\u00f4\5D#\2\u00ef\u00f0\7\16\2")
        buf.write(u"\2\u00f0\u00f4\5F$\2\u00f1\u00f2\7\16\2\2\u00f2\u00f4")
        buf.write(u"\5H%\2\u00f3\u00e7\3\2\2\2\u00f3\u00e9\3\2\2\2\u00f3")
        buf.write(u"\u00eb\3\2\2\2\u00f3\u00ed\3\2\2\2\u00f3\u00ef\3\2\2")
        buf.write(u"\2\u00f3\u00f1\3\2\2\2\u00f4!\3\2\2\2\u00f5\u00f6\7\17")
        buf.write(u"\2\2\u00f6\u00f7\58\35\2\u00f7#\3\2\2\2\u00f8\u00f9\7")
        buf.write(u"\17\2\2\u00f9\u00fe\5@!\2\u00fa\u00fb\7\17\2\2\u00fb")
        buf.write(u"\u00fe\5:\36\2\u00fc\u00fe\5\"\22\2\u00fd\u00f8\3\2\2")
        buf.write(u"\2\u00fd\u00fa\3\2\2\2\u00fd\u00fc\3\2\2\2\u00fe%\3\2")
        buf.write(u"\2\2\u00ff\u0100\7\16\2\2\u0100\u0107\5\66\34\2\u0101")
        buf.write(u"\u0102\7\17\2\2\u0102\u0107\5B\"\2\u0103\u0104\7\17\2")
        buf.write(u"\2\u0104\u0107\5L\'\2\u0105\u0107\5$\23\2\u0106\u00ff")
        buf.write(u"\3\2\2\2\u0106\u0101\3\2\2\2\u0106\u0103\3\2\2\2\u0106")
        buf.write(u"\u0105\3\2\2\2\u0107\'\3\2\2\2\u0108\u0109\7\16\2\2\u0109")
        buf.write(u"\u010c\5\62\32\2\u010a\u010c\5&\24\2\u010b\u0108\3\2")
        buf.write(u"\2\2\u010b\u010a\3\2\2\2\u010c)\3\2\2\2\u010d\u010e\7")
        buf.write(u"\16\2\2\u010e\u0111\5<\37\2\u010f\u0111\5(\25\2\u0110")
        buf.write(u"\u010d\3\2\2\2\u0110\u010f\3\2\2\2\u0111+\3\2\2\2\u0112")
        buf.write(u"\u0113\7\16\2\2\u0113\u0116\5> \2\u0114\u0116\5*\26\2")
        buf.write(u"\u0115\u0112\3\2\2\2\u0115\u0114\3\2\2\2\u0116-\3\2\2")
        buf.write(u"\2\u0117\u0118\7\33\2\2\u0118/\3\2\2\2\u0119\u011c\7")
        buf.write(u"\34\2\2\u011a\u011c\5.\30\2\u011b\u0119\3\2\2\2\u011b")
        buf.write(u"\u011a\3\2\2\2\u011c\61\3\2\2\2\u011d\u011e\7\35\2\2")
        buf.write(u"\u011e\63\3\2\2\2\u011f\u0120\7\20\2\2\u0120\u0121\5")
        buf.write(u"\64\33\2\u0121\u0122\7$\2\2\u0122\u0123\5\32\16\2\u0123")
        buf.write(u"\u0126\3\2\2\2\u0124\u0126\7\37\2\2\u0125\u011f\3\2\2")
        buf.write(u"\2\u0125\u0124\3\2\2\2\u0126\65\3\2\2\2\u0127\u0128\7")
        buf.write(u" \2\2\u0128\67\3\2\2\2\u0129\u012a\7\20\2\2\u012a\u012b")
        buf.write(u"\58\35\2\u012b\u012c\7$\2\2\u012c\u012d\5\32\16\2\u012d")
        buf.write(u"\u0130\3\2\2\2\u012e\u0130\7!\2\2\u012f\u0129\3\2\2\2")
        buf.write(u"\u012f\u012e\3\2\2\2\u01309\3\2\2\2\u0131\u0132\7\"\2")
        buf.write(u"\2\u0132;\3\2\2\2\u0133\u0134\5\62\32\2\u0134=\3\2\2")
        buf.write(u"\2\u0135\u0136\5<\37\2\u0136?\3\2\2\2\u0137\u0138\7\22")
        buf.write(u"\2\2\u0138\u0139\5@!\2\u0139\u013a\7$\2\2\u013a\u013b")
        buf.write(u"\5 \21\2\u013b\u0141\3\2\2\2\u013c\u013d\7\23\2\2\u013d")
        buf.write(u"\u013e\7\4\2\2\u013e\u0141\5V,\2\u013f\u0141\7\36\2\2")
        buf.write(u"\u0140\u0137\3\2\2\2\u0140\u013c\3\2\2\2\u0140\u013f")
        buf.write(u"\3\2\2\2\u0141A\3\2\2\2\u0142\u0143\7\21\2\2\u0143\u0144")
        buf.write(u"\5B\"\2\u0144\u0145\7$\2\2\u0145\u0146\5\16\b\2\u0146")
        buf.write(u"\u0151\3\2\2\2\u0147\u0148\7\22\2\2\u0148\u0149\5B\"")
        buf.write(u"\2\u0149\u014a\7$\2\2\u014a\u014b\5 \21\2\u014b\u0151")
        buf.write(u"\3\2\2\2\u014c\u014d\7\23\2\2\u014d\u014e\7\4\2\2\u014e")
        buf.write(u"\u0151\5j\66\2\u014f\u0151\5@!\2\u0150\u0142\3\2\2\2")
        buf.write(u"\u0150\u0147\3\2\2\2\u0150\u014c\3\2\2\2\u0150\u014f")
        buf.write(u"\3\2\2\2\u0151C\3\2\2\2\u0152\u0153\7\21\2\2\u0153\u0154")
        buf.write(u"\5D#\2\u0154\u0155\7$\2\2\u0155\u0156\5\20\t\2\u0156")
        buf.write(u"\u0162\3\2\2\2\u0157\u0158\7\22\2\2\u0158\u0159\5D#\2")
        buf.write(u"\u0159\u015a\7$\2\2\u015a\u015b\5 \21\2\u015b\u0162\3")
        buf.write(u"\2\2\2\u015c\u015d\7\23\2\2\u015d\u015e\5n8\2\u015e\u015f")
        buf.write(u"\5h\65\2\u015f\u0162\3\2\2\2\u0160\u0162\5B\"\2\u0161")
        buf.write(u"\u0152\3\2\2\2\u0161\u0157\3\2\2\2\u0161\u015c\3\2\2")
        buf.write(u"\2\u0161\u0160\3\2\2\2\u0162E\3\2\2\2\u0163\u0164\5D")
        buf.write(u"#\2\u0164G\3\2\2\2\u0165\u0166\7\20\2\2\u0166\u0167\5")
        buf.write(u"H%\2\u0167\u0168\7$\2\2\u0168\u0169\5\24\13\2\u0169\u0171")
        buf.write(u"\3\2\2\2\u016a\u016b\7\22\2\2\u016b\u016c\5H%\2\u016c")
        buf.write(u"\u016d\7$\2\2\u016d\u016e\5 \21\2\u016e\u0171\3\2\2\2")
        buf.write(u"\u016f\u0171\5F$\2\u0170\u0165\3\2\2\2\u0170\u016a\3")
        buf.write(u"\2\2\2\u0170\u016f\3\2\2\2\u0171I\3\2\2\2\u0172\u0173")
        buf.write(u"\5N(\2\u0173K\3\2\2\2\u0174\u0175\7\r\2\2\u0175\u0185")
        buf.write(u"\5.\30\2\u0176\u0177\7\21\2\2\u0177\u0178\5L\'\2\u0178")
        buf.write(u"\u0179\7$\2\2\u0179\u017a\5\16\b\2\u017a\u0185\3\2\2")
        buf.write(u"\2\u017b\u017c\7\22\2\2\u017c\u017d\5L\'\2\u017d\u017e")
        buf.write(u"\7$\2\2\u017e\u017f\5\34\17\2\u017f\u0185\3\2\2\2\u0180")
        buf.write(u"\u0181\7\23\2\2\u0181\u0182\7\4\2\2\u0182\u0185\5`\61")
        buf.write(u"\2\u0183\u0185\5:\36\2\u0184\u0174\3\2\2\2\u0184\u0176")
        buf.write(u"\3\2\2\2\u0184\u017b\3\2\2\2\u0184\u0180\3\2\2\2\u0184")
        buf.write(u"\u0183\3\2\2\2\u0185M\3\2\2\2\u0186\u0187\7\21\2\2\u0187")
        buf.write(u"\u0188\5N(\2\u0188\u0189\7$\2\2\u0189\u018a\5\20\t\2")
        buf.write(u"\u018a\u0196\3\2\2\2\u018b\u018c\7\22\2\2\u018c\u018d")
        buf.write(u"\5N(\2\u018d\u018e\7$\2\2\u018e\u018f\5\34\17\2\u018f")
        buf.write(u"\u0196\3\2\2\2\u0190\u0191\7\23\2\2\u0191\u0192\5n8\2")
        buf.write(u"\u0192\u0193\5b\62\2\u0193\u0196\3\2\2\2\u0194\u0196")
        buf.write(u"\5L\'\2\u0195\u0186\3\2\2\2\u0195\u018b\3\2\2\2\u0195")
        buf.write(u"\u0190\3\2\2\2\u0195\u0194\3\2\2\2\u0196O\3\2\2\2\u0197")
        buf.write(u"\u0198\7\20\2\2\u0198\u0199\5P)\2\u0199\u019a\7$\2\2")
        buf.write(u"\u019a\u019b\5\24\13\2\u019b\u01a3\3\2\2\2\u019c\u019d")
        buf.write(u"\7\22\2\2\u019d\u019e\5P)\2\u019e\u019f\7$\2\2\u019f")
        buf.write(u"\u01a0\5\34\17\2\u01a0\u01a3\3\2\2\2\u01a1\u01a3\5J&")
        buf.write(u"\2\u01a2\u0197\3\2\2\2\u01a2\u019c\3\2\2\2\u01a2\u01a1")
        buf.write(u"\3\2\2\2\u01a3Q\3\2\2\2\u01a4\u01a5\5.\30\2\u01a5S\3")
        buf.write(u"\2\2\2\u01a6\u01a7\5\60\31\2\u01a7U\3\2\2\2\u01a8\u01a9")
        buf.write(u"\7\24\2\2\u01a9\u01aa\5\64\33\2\u01aa\u01ab\7$\2\2\u01ab")
        buf.write(u"\u01ac\5\64\33\2\u01ac\u01b5\3\2\2\2\u01ad\u01ae\7\31")
        buf.write(u"\2\2\u01ae\u01af\5 \21\2\u01af\u01b0\7$\2\2\u01b0\u01b1")
        buf.write(u"\5 \21\2\u01b1\u01b2\7$\2\2\u01b2\u01b3\5V,\2\u01b3\u01b5")
        buf.write(u"\3\2\2\2\u01b4\u01a8\3\2\2\2\u01b4\u01ad\3\2\2\2\u01b5")
        buf.write(u"W\3\2\2\2\u01b6\u01b7\7\25\2\2\u01b7\u01b8\5\34\17\2")
        buf.write(u"\u01b8\u01b9\7$\2\2\u01b9\u01ba\5\34\17\2\u01baY\3\2")
        buf.write(u"\2\2\u01bb\u01bc\7\26\2\2\u01bc\u01bd\5\34\17\2\u01bd")
        buf.write(u"\u01be\7$\2\2\u01be\u01bf\5 \21\2\u01bf[\3\2\2\2\u01c0")
        buf.write(u"\u01c1\7\27\2\2\u01c1\u01c2\5\64\33\2\u01c2\u01c3\7$")
        buf.write(u"\2\2\u01c3\u01c4\5\64\33\2\u01c4\u01cc\3\2\2\2\u01c5")
        buf.write(u"\u01c6\7\20\2\2\u01c6\u01c7\5\\/\2\u01c7\u01c8\7$\2\2")
        buf.write(u"\u01c8\u01c9\5\22\n\2\u01c9\u01cc\3\2\2\2\u01ca\u01cc")
        buf.write(u"\5h\65\2\u01cb\u01c0\3\2\2\2\u01cb\u01c5\3\2\2\2\u01cb")
        buf.write(u"\u01ca\3\2\2\2\u01cc]\3\2\2\2\u01cd\u01ce\7\30\2\2\u01ce")
        buf.write(u"\u01cf\5\34\17\2\u01cf\u01d0\7$\2\2\u01d0\u01d1\5\64")
        buf.write(u"\33\2\u01d1_\3\2\2\2\u01d2\u01d3\7\22\2\2\u01d3\u01d4")
        buf.write(u"\5d\63\2\u01d4\u01d5\7$\2\2\u01d5\u01d6\5L\'\2\u01d6")
        buf.write(u"\u01d9\3\2\2\2\u01d7\u01d9\5X-\2\u01d8\u01d2\3\2\2\2")
        buf.write(u"\u01d8\u01d7\3\2\2\2\u01d9a\3\2\2\2\u01da\u01db\7\21")
        buf.write(u"\2\2\u01db\u01dc\5b\62\2\u01dc\u01dd\7$\2\2\u01dd\u01de")
        buf.write(u"\5\20\t\2\u01de\u01e1\3\2\2\2\u01df\u01e1\5`\61\2\u01e0")
        buf.write(u"\u01da\3\2\2\2\u01e0\u01df\3\2\2\2\u01e1c\3\2\2\2\u01e2")
        buf.write(u"\u01e3\7\20\2\2\u01e3\u01e4\5d\63\2\u01e4\u01e5\7$\2")
        buf.write(u"\2\u01e5\u01e6\5\22\n\2\u01e6\u01ea\3\2\2\2\u01e7\u01ea")
        buf.write(u"\5f\64\2\u01e8\u01ea\5b\62\2\u01e9\u01e2\3\2\2\2\u01e9")
        buf.write(u"\u01e7\3\2\2\2\u01e9\u01e8\3\2\2\2\u01eae\3\2\2\2\u01eb")
        buf.write(u"\u01ec\7\32\2\2\u01ec\u01ed\5\34\17\2\u01ed\u01ee\7$")
        buf.write(u"\2\2\u01ee\u01ef\5\34\17\2\u01ef\u01f0\7$\2\2\u01f0\u01f1")
        buf.write(u"\5B\"\2\u01f1\u01f8\3\2\2\2\u01f2\u01f3\7\20\2\2\u01f3")
        buf.write(u"\u01f4\5f\64\2\u01f4\u01f5\7$\2\2\u01f5\u01f6\7\3\2\2")
        buf.write(u"\u01f6\u01f8\3\2\2\2\u01f7\u01eb\3\2\2\2\u01f7\u01f2")
        buf.write(u"\3\2\2\2\u01f8g\3\2\2\2\u01f9\u01fa\7\21\2\2\u01fa\u01fb")
        buf.write(u"\5h\65\2\u01fb\u01fc\7$\2\2\u01fc\u01fd\5\20\t\2\u01fd")
        buf.write(u"\u0200\3\2\2\2\u01fe\u0200\5j\66\2\u01ff\u01f9\3\2\2")
        buf.write(u"\2\u01ff\u01fe\3\2\2\2\u0200i\3\2\2\2\u0201\u0202\7\22")
        buf.write(u"\2\2\u0202\u0203\5\\/\2\u0203\u0204\7$\2\2\u0204\u0205")
        buf.write(u"\5B\"\2\u0205\u0208\3\2\2\2\u0206\u0208\5V,\2\u0207\u0201")
        buf.write(u"\3\2\2\2\u0207\u0206\3\2\2\2\u0208k\3\2\2\2\u0209\u020c")
        buf.write(u"\7\4\2\2\u020a\u020c\5n8\2\u020b\u0209\3\2\2\2\u020b")
        buf.write(u"\u020a\3\2\2\2\u020cm\3\2\2\2\u020d\u020e\t\2\2\2\u020e")
        buf.write(u"o\3\2\2\2)sy\u0080\u0086\u008d\u009e\u00a8\u00b5\u00ba")
        buf.write(u"\u00bf\u00c5\u00cd\u00d9\u00e5\u00f3\u00fd\u0106\u010b")
        buf.write(u"\u0110\u0115\u011b\u0125\u012f\u0140\u0150\u0161\u0170")
        buf.write(u"\u0184\u0195\u01a2\u01b4\u01cb\u01d8\u01e0\u01e9\u01f7")
        buf.write(u"\u01ff\u0207\u020b")
        return buf.getvalue()


class TransformationAlgebraParser ( Parser ):

    grammarFileName = "TransformationAlgebra.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"'average '", u"'min '", 
                     u"'max '", u"'reify '", u"'deify '", u"'get '", u"'fcont '", 
                     u"'ocont '", u"'ratio '", u"'interpol '", u"'pi1 '", 
                     u"'pi2 '", u"'sigmae '", u"'sigmale '", u"'bowtie '", 
                     u"'groupby '", u"'odist '", u"'ldist '", u"'lodist '", 
                     u"'otopo '", u"'lotopo '", u"'ndist '", u"'lvis '", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"' '" ]

    symbolicNames = [ u"<INVALID>", u"BOOLV", u"AVG", u"MIN", u"MAX", u"REIFY", 
                      u"DEIFY", u"GET", u"FCONT", u"OCONT", u"RATIO", u"INTERPOL", 
                      u"PI1", u"PI2", u"SIGMAE2", u"SIGMASE2", u"BOWTIE", 
                      u"GROUPBY", u"ODIST", u"LDIST", u"LODIST", u"OTOPO", 
                      u"LOTOPO", u"NDIST", u"LVIS", u"DATAPM", u"DATAAMOUNT", 
                      u"DATACONTOUR", u"DATAOBJQ", u"DATAOBJS", u"DATACONTOURLINE", 
                      u"DATAOBJCOUNT", u"DATAFIELD", u"DATAV", u"WHITESPACE", 
                      u"KEYWORD", u"WS" ]

    RULE_start = 0
    RULE_r = 1
    RULE_rr = 2
    RULE_v = 3
    RULE_countv = 4
    RULE_ratiov = 5
    RULE_intv = 6
    RULE_ordv = 7
    RULE_nomv = 8
    RULE_qv = 9
    RULE_sv = 10
    RULE_lv = 11
    RULE_ov = 12
    RULE_l = 13
    RULE_s = 14
    RULE_o = 15
    RULE_count = 16
    RULE_ratio = 17
    RULE_intt = 18
    RULE_ordinal = 19
    RULE_nom = 20
    RULE_q = 21
    RULE_sint = 22
    RULE_snom = 23
    RULE_ords = 24
    RULE_os = 25
    RULE_ints = 26
    RULE_ocount = 27
    RULE_lratio = 28
    RULE_noms = 29
    RULE_qs = 30
    RULE_oratio = 31
    RULE_oint = 32
    RULE_oord = 33
    RULE_onom = 34
    RULE_oq = 35
    RULE_lnom = 36
    RULE_lint = 37
    RULE_lord = 38
    RULE_lq = 39
    RULE_sord = 40
    RULE_sq = 41
    RULE_oratioo = 42
    RULE_lratiol = 43
    RULE_lratioo = 44
    RULE_onomo = 45
    RULE_lnomo = 46
    RULE_lintl = 47
    RULE_lordl = 48
    RULE_lnoml = 49
    RULE_lbooll = 50
    RULE_oordo = 51
    RULE_ointo = 52
    RULE_agg = 53
    RULE_aggord = 54

    ruleNames =  [ u"start", u"r", u"rr", u"v", u"countv", u"ratiov", u"intv", 
                   u"ordv", u"nomv", u"qv", u"sv", u"lv", u"ov", u"l", u"s", 
                   u"o", u"count", u"ratio", u"intt", u"ordinal", u"nom", 
                   u"q", u"sint", u"snom", u"ords", u"os", u"ints", u"ocount", 
                   u"lratio", u"noms", u"qs", u"oratio", u"oint", u"oord", 
                   u"onom", u"oq", u"lnom", u"lint", u"lord", u"lq", u"sord", 
                   u"sq", u"oratioo", u"lratiol", u"lratioo", u"onomo", 
                   u"lnomo", u"lintl", u"lordl", u"lnoml", u"lbooll", u"oordo", 
                   u"ointo", u"agg", u"aggord" ]

    EOF = Token.EOF
    BOOLV=1
    AVG=2
    MIN=3
    MAX=4
    REIFY=5
    DEIFY=6
    GET=7
    FCONT=8
    OCONT=9
    RATIO=10
    INTERPOL=11
    PI1=12
    PI2=13
    SIGMAE2=14
    SIGMASE2=15
    BOWTIE=16
    GROUPBY=17
    ODIST=18
    LDIST=19
    LODIST=20
    OTOPO=21
    LOTOPO=22
    NDIST=23
    LVIS=24
    DATAPM=25
    DATAAMOUNT=26
    DATACONTOUR=27
    DATAOBJQ=28
    DATAOBJS=29
    DATACONTOURLINE=30
    DATAOBJCOUNT=31
    DATAFIELD=32
    DATAV=33
    WHITESPACE=34
    KEYWORD=35
    WS=36

    def __init__(self, input, output=sys.stdout):
        super(TransformationAlgebraParser, self).__init__(input, output=output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.StartContext, self).__init__(parent, invokingState)
            self.parser = parser

        def r(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RContext,0)


        def rr(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RrContext,0)


        def v(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.VContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_start

        def enterRule(self, listener):
            if hasattr(listener, "enterStart"):
                listener.enterStart(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStart"):
                listener.exitStart(self)




    def start(self):

        localctx = TransformationAlgebraParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DEIFY, TransformationAlgebraParser.PI1, TransformationAlgebraParser.PI2]:
                self.state = 110
                self.r()
                pass
            elif token in [TransformationAlgebraParser.INTERPOL, TransformationAlgebraParser.SIGMAE2, TransformationAlgebraParser.SIGMASE2, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.GROUPBY, TransformationAlgebraParser.DATAPM, TransformationAlgebraParser.DATAAMOUNT, TransformationAlgebraParser.DATACONTOUR, TransformationAlgebraParser.DATAOBJQ, TransformationAlgebraParser.DATAOBJS, TransformationAlgebraParser.DATAFIELD]:
                self.state = 111
                self.rr()
                pass
            elif token in [TransformationAlgebraParser.AVG, TransformationAlgebraParser.MIN, TransformationAlgebraParser.MAX, TransformationAlgebraParser.REIFY, TransformationAlgebraParser.GET, TransformationAlgebraParser.FCONT, TransformationAlgebraParser.OCONT, TransformationAlgebraParser.RATIO, TransformationAlgebraParser.DATAV, TransformationAlgebraParser.KEYWORD]:
                self.state = 112
                self.v()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RContext, self).__init__(parent, invokingState)
            self.parser = parser

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_r

        def enterRule(self, listener):
            if hasattr(listener, "enterR"):
                listener.enterR(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitR"):
                listener.exitR(self)




    def r(self):

        localctx = TransformationAlgebraParser.RContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_r)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 115
                self.l()
                pass

            elif la_ == 2:
                self.state = 116
                self.s()
                pass

            elif la_ == 3:
                self.state = 117
                self.q()
                pass

            elif la_ == 4:
                self.state = 118
                self.o()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RrContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RrContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def sq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SqContext,0)


        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_rr

        def enterRule(self, listener):
            if hasattr(listener, "enterRr"):
                listener.enterRr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRr"):
                listener.exitRr(self)




    def rr(self):

        localctx = TransformationAlgebraParser.RrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 121
                self.lq()
                pass

            elif la_ == 2:
                self.state = 122
                self.sq()
                pass

            elif la_ == 3:
                self.state = 123
                self.qs()
                pass

            elif la_ == 4:
                self.state = 124
                self.oq()
                pass

            elif la_ == 5:
                self.state = 125
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.VContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def lv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LvContext,0)


        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_v

        def enterRule(self, listener):
            if hasattr(listener, "enterV"):
                listener.enterV(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitV"):
                listener.exitV(self)




    def v(self):

        localctx = TransformationAlgebraParser.VContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_v)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 128
                self.ov()
                pass

            elif la_ == 2:
                self.state = 129
                self.lv()
                pass

            elif la_ == 3:
                self.state = 130
                self.sv()
                pass

            elif la_ == 4:
                self.state = 131
                self.qv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_countv

        def enterRule(self, listener):
            if hasattr(listener, "enterCountv"):
                listener.enterCountv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCountv"):
                listener.exitCountv(self)




    def countv(self):

        localctx = TransformationAlgebraParser.CountvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_countv)
        try:
            self.state = 139
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OCONT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 134
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 135
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 136
                self.match(TransformationAlgebraParser.GET)
                self.state = 137
                self.count()
                pass
            elif token in [TransformationAlgebraParser.DATAV]:
                self.enterOuterAlt(localctx, 3)
                self.state = 138
                self.match(TransformationAlgebraParser.DATAV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatiovContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatiovContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FCONT(self):
            return self.getToken(TransformationAlgebraParser.FCONT, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def RATIO(self):
            return self.getToken(TransformationAlgebraParser.RATIO, 0)

        def ratiov(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.RatiovContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def OCONT(self):
            return self.getToken(TransformationAlgebraParser.OCONT, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def countv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountvContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratiov

        def enterRule(self, listener):
            if hasattr(listener, "enterRatiov"):
                listener.enterRatiov(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatiov"):
                listener.exitRatiov(self)




    def ratiov(self):

        localctx = TransformationAlgebraParser.RatiovContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_ratiov)
        try:
            self.state = 156
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 141
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 142
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 143
                self.match(TransformationAlgebraParser.FCONT)
                self.state = 144
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 145
                self.match(TransformationAlgebraParser.RATIO)
                self.state = 146
                self.ratiov()
                self.state = 147
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 148
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 150
                self.match(TransformationAlgebraParser.OCONT)
                self.state = 151
                self.oratio()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 152
                self.match(TransformationAlgebraParser.GET)
                self.state = 153
                self.ratio()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 154
                self.countv()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 155
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def ratiov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatiovContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def DATAV(self):
            return self.getToken(TransformationAlgebraParser.DATAV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intv

        def enterRule(self, listener):
            if hasattr(listener, "enterIntv"):
                listener.enterIntv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntv"):
                listener.exitIntv(self)




    def intv(self):

        localctx = TransformationAlgebraParser.IntvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_intv)
        try:
            self.state = 166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 158
                self.match(TransformationAlgebraParser.AVG)
                self.state = 159
                self.lint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 160
                self.match(TransformationAlgebraParser.AVG)
                self.state = 161
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 162
                self.ratiov()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 163
                self.match(TransformationAlgebraParser.GET)
                self.state = 164
                self.intt()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 165
                self.match(TransformationAlgebraParser.DATAV)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MAX(self):
            return self.getToken(TransformationAlgebraParser.MAX, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def MIN(self):
            return self.getToken(TransformationAlgebraParser.MIN, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordv

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdv"):
                listener.enterOrdv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdv"):
                listener.exitOrdv(self)




    def ordv(self):

        localctx = TransformationAlgebraParser.OrdvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ordv)
        try:
            self.state = 179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 168
                self.match(TransformationAlgebraParser.MAX)
                self.state = 169
                self.lord()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.match(TransformationAlgebraParser.MIN)
                self.state = 171
                self.lord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 172
                self.match(TransformationAlgebraParser.MAX)
                self.state = 173
                self.oord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 174
                self.match(TransformationAlgebraParser.MIN)
                self.state = 175
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 176
                self.match(TransformationAlgebraParser.GET)
                self.state = 177
                self.ordinal()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 178
                self.intv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nomv

        def enterRule(self, listener):
            if hasattr(listener, "enterNomv"):
                listener.enterNomv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNomv"):
                listener.exitNomv(self)




    def nomv(self):

        localctx = TransformationAlgebraParser.NomvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nomv)
        try:
            self.state = 184
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 181
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 182
                self.match(TransformationAlgebraParser.GET)
                self.state = 183
                self.nom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def q(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qv

        def enterRule(self, listener):
            if hasattr(listener, "enterQv"):
                listener.enterQv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQv"):
                listener.exitQv(self)




    def qv(self):

        localctx = TransformationAlgebraParser.QvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_qv)
        try:
            self.state = 189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 186
                self.match(TransformationAlgebraParser.GET)
                self.state = 187
                self.q()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 188
                self.nomv()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REIFY(self):
            return self.getToken(TransformationAlgebraParser.REIFY, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def s(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sv

        def enterRule(self, listener):
            if hasattr(listener, "enterSv"):
                listener.enterSv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSv"):
                listener.exitSv(self)




    def sv(self):

        localctx = TransformationAlgebraParser.SvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sv)
        try:
            self.state = 195
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.REIFY]:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                self.match(TransformationAlgebraParser.REIFY)
                self.state = 192
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 193
                self.match(TransformationAlgebraParser.GET)
                self.state = 194
                self.s()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lv

        def enterRule(self, listener):
            if hasattr(listener, "enterLv"):
                listener.enterLv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLv"):
                listener.exitLv(self)




    def lv(self):

        localctx = TransformationAlgebraParser.LvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_lv)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(TransformationAlgebraParser.GET)
            self.state = 198
            self.l()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OvContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OvContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GET(self):
            return self.getToken(TransformationAlgebraParser.GET, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def KEYWORD(self):
            return self.getToken(TransformationAlgebraParser.KEYWORD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ov

        def enterRule(self, listener):
            if hasattr(listener, "enterOv"):
                listener.enterOv(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOv"):
                listener.exitOv(self)




    def ov(self):

        localctx = TransformationAlgebraParser.OvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ov)
        try:
            self.state = 203
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.GET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 200
                self.match(TransformationAlgebraParser.GET)
                self.state = 201
                self.o()
                pass
            elif token in [TransformationAlgebraParser.KEYWORD]:
                self.enterOuterAlt(localctx, 2)
                self.state = 202
                self.match(TransformationAlgebraParser.KEYWORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DEIFY(self):
            return self.getToken(TransformationAlgebraParser.DEIFY, 0)

        def sv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SvContext,0)


        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_l

        def enterRule(self, listener):
            if hasattr(listener, "enterL"):
                listener.enterL(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitL"):
                listener.exitL(self)




    def l(self):

        localctx = TransformationAlgebraParser.LContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_l)
        try:
            self.state = 215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 205
                self.match(TransformationAlgebraParser.DEIFY)
                self.state = 206
                self.sv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 207
                self.match(TransformationAlgebraParser.PI1)
                self.state = 208
                self.lint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 209
                self.match(TransformationAlgebraParser.PI1)
                self.state = 210
                self.lord()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 211
                self.match(TransformationAlgebraParser.PI1)
                self.state = 212
                self.lnom()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 213
                self.match(TransformationAlgebraParser.PI1)
                self.state = 214
                self.lq()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def sord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SordContext,0)


        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_s

        def enterRule(self, listener):
            if hasattr(listener, "enterS"):
                listener.enterS(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitS"):
                listener.exitS(self)




    def s(self):

        localctx = TransformationAlgebraParser.SContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_s)
        try:
            self.state = 227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 217
                self.match(TransformationAlgebraParser.PI1)
                self.state = 218
                self.sint()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 219
                self.match(TransformationAlgebraParser.PI1)
                self.state = 220
                self.sord()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 221
                self.match(TransformationAlgebraParser.PI1)
                self.state = 222
                self.snom()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 223
                self.match(TransformationAlgebraParser.PI1)
                self.state = 224
                self.lq()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 225
                self.match(TransformationAlgebraParser.PI2)
                self.state = 226
                self.os()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_o

        def enterRule(self, listener):
            if hasattr(listener, "enterO"):
                listener.enterO(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitO"):
                listener.exitO(self)




    def o(self):

        localctx = TransformationAlgebraParser.OContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_o)
        try:
            self.state = 241
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 229
                self.match(TransformationAlgebraParser.PI1)
                self.state = 230
                self.os()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 231
                self.match(TransformationAlgebraParser.PI1)
                self.state = 232
                self.oratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 233
                self.match(TransformationAlgebraParser.PI1)
                self.state = 234
                self.oint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 235
                self.match(TransformationAlgebraParser.PI1)
                self.state = 236
                self.oord()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 237
                self.match(TransformationAlgebraParser.PI1)
                self.state = 238
                self.onom()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 239
                self.match(TransformationAlgebraParser.PI1)
                self.state = 240
                self.oq()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.CountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_count

        def enterRule(self, listener):
            if hasattr(listener, "enterCount"):
                listener.enterCount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCount"):
                listener.exitCount(self)




    def count(self):

        localctx = TransformationAlgebraParser.CountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_count)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.match(TransformationAlgebraParser.PI2)
            self.state = 244
            self.ocount()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.RatioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def count(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.CountContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ratio

        def enterRule(self, listener):
            if hasattr(listener, "enterRatio"):
                listener.enterRatio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRatio"):
                listener.exitRatio(self)




    def ratio(self):

        localctx = TransformationAlgebraParser.RatioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_ratio)
        try:
            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 246
                self.match(TransformationAlgebraParser.PI2)
                self.state = 247
                self.oratio()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 248
                self.match(TransformationAlgebraParser.PI2)
                self.state = 249
                self.lratio()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 250
                self.count()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InttContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.InttContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ints(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntsContext,0)


        def PI2(self):
            return self.getToken(TransformationAlgebraParser.PI2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def ratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.RatioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_intt

        def enterRule(self, listener):
            if hasattr(listener, "enterIntt"):
                listener.enterIntt(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntt"):
                listener.exitIntt(self)




    def intt(self):

        localctx = TransformationAlgebraParser.InttContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_intt)
        try:
            self.state = 260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 253
                self.match(TransformationAlgebraParser.PI1)
                self.state = 254
                self.ints()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 255
                self.match(TransformationAlgebraParser.PI2)
                self.state = 256
                self.oint()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 257
                self.match(TransformationAlgebraParser.PI2)
                self.state = 258
                self.lint()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 259
                self.ratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdinalContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdinalContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def intt(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.InttContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ordinal

        def enterRule(self, listener):
            if hasattr(listener, "enterOrdinal"):
                listener.enterOrdinal(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrdinal"):
                listener.exitOrdinal(self)




    def ordinal(self):

        localctx = TransformationAlgebraParser.OrdinalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_ordinal)
        try:
            self.state = 265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 262
                self.match(TransformationAlgebraParser.PI1)
                self.state = 263
                self.ords()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 264
                self.intt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def ordinal(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdinalContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_nom

        def enterRule(self, listener):
            if hasattr(listener, "enterNom"):
                listener.enterNom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNom"):
                listener.exitNom(self)




    def nom(self):

        localctx = TransformationAlgebraParser.NomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_nom)
        try:
            self.state = 270
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 267
                self.match(TransformationAlgebraParser.PI1)
                self.state = 268
                self.noms()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 269
                self.ordinal()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PI1(self):
            return self.getToken(TransformationAlgebraParser.PI1, 0)

        def qs(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QsContext,0)


        def nom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_q

        def enterRule(self, listener):
            if hasattr(listener, "enterQ"):
                listener.enterQ(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQ"):
                listener.exitQ(self)




    def q(self):

        localctx = TransformationAlgebraParser.QContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_q)
        try:
            self.state = 275
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 272
                self.match(TransformationAlgebraParser.PI1)
                self.state = 273
                self.qs()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 274
                self.nom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAPM(self):
            return self.getToken(TransformationAlgebraParser.DATAPM, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sint

        def enterRule(self, listener):
            if hasattr(listener, "enterSint"):
                listener.enterSint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSint"):
                listener.exitSint(self)




    def sint(self):

        localctx = TransformationAlgebraParser.SintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_sint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.match(TransformationAlgebraParser.DATAPM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAAMOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAAMOUNT, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_snom

        def enterRule(self, listener):
            if hasattr(listener, "enterSnom"):
                listener.enterSnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSnom"):
                listener.exitSnom(self)




    def snom(self):

        localctx = TransformationAlgebraParser.SnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_snom)
        try:
            self.state = 281
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.DATAAMOUNT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 279
                self.match(TransformationAlgebraParser.DATAAMOUNT)
                pass
            elif token in [TransformationAlgebraParser.DATAPM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 280
                self.sint()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrdsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OrdsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOUR(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOUR, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ords

        def enterRule(self, listener):
            if hasattr(listener, "enterOrds"):
                listener.enterOrds(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOrds"):
                listener.exitOrds(self)




    def ords(self):

        localctx = TransformationAlgebraParser.OrdsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_ords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(TransformationAlgebraParser.DATACONTOUR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def DATAOBJS(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJS, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_os

        def enterRule(self, listener):
            if hasattr(listener, "enterOs"):
                listener.enterOs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOs"):
                listener.exitOs(self)




    def os(self):

        localctx = TransformationAlgebraParser.OsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_os)
        try:
            self.state = 291
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 285
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 286
                self.os()
                self.state = 287
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 288
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 290
                self.match(TransformationAlgebraParser.DATAOBJS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.IntsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATACONTOURLINE(self):
            return self.getToken(TransformationAlgebraParser.DATACONTOURLINE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ints

        def enterRule(self, listener):
            if hasattr(listener, "enterInts"):
                listener.enterInts(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInts"):
                listener.exitInts(self)




    def ints(self):

        localctx = TransformationAlgebraParser.IntsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_ints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(TransformationAlgebraParser.DATACONTOURLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OcountContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OcountContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def ocount(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OcountContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ov(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OvContext,0)


        def DATAOBJCOUNT(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJCOUNT, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ocount

        def enterRule(self, listener):
            if hasattr(listener, "enterOcount"):
                listener.enterOcount(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOcount"):
                listener.exitOcount(self)




    def ocount(self):

        localctx = TransformationAlgebraParser.OcountContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_ocount)
        try:
            self.state = 301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 295
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 296
                self.ocount()
                self.state = 297
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 298
                self.ov()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJCOUNT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 300
                self.match(TransformationAlgebraParser.DATAOBJCOUNT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DATAFIELD(self):
            return self.getToken(TransformationAlgebraParser.DATAFIELD, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratio

        def enterRule(self, listener):
            if hasattr(listener, "enterLratio"):
                listener.enterLratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratio"):
                listener.exitLratio(self)




    def lratio(self):

        localctx = TransformationAlgebraParser.LratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_lratio)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(TransformationAlgebraParser.DATAFIELD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NomsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.NomsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ords(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_noms

        def enterRule(self, listener):
            if hasattr(listener, "enterNoms"):
                listener.enterNoms(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNoms"):
                listener.exitNoms(self)




    def noms(self):

        localctx = TransformationAlgebraParser.NomsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_noms)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.ords()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.QsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def noms(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_qs

        def enterRule(self, listener):
            if hasattr(listener, "enterQs"):
                listener.enterQs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitQs"):
                listener.exitQs(self)




    def qs(self):

        localctx = TransformationAlgebraParser.QsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_qs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self.noms()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratioContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratioContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBY(self):
            return self.getToken(TransformationAlgebraParser.GROUPBY, 0)

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def DATAOBJQ(self):
            return self.getToken(TransformationAlgebraParser.DATAOBJQ, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratio

        def enterRule(self, listener):
            if hasattr(listener, "enterOratio"):
                listener.enterOratio(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratio"):
                listener.exitOratio(self)




    def oratio(self):

        localctx = TransformationAlgebraParser.OratioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_oratio)
        try:
            self.state = 318
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 309
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 310
                self.oratio()
                self.state = 311
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 312
                self.o()
                pass
            elif token in [TransformationAlgebraParser.GROUPBY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 314
                self.match(TransformationAlgebraParser.GROUPBY)
                self.state = 315
                self.match(TransformationAlgebraParser.AVG)
                self.state = 316
                self.oratioo()
                pass
            elif token in [TransformationAlgebraParser.DATAOBJQ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 317
                self.match(TransformationAlgebraParser.DATAOBJQ)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBY(self):
            return self.getToken(TransformationAlgebraParser.GROUPBY, 0)

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def oratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oint

        def enterRule(self, listener):
            if hasattr(listener, "enterOint"):
                listener.enterOint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOint"):
                listener.exitOint(self)




    def oint(self):

        localctx = TransformationAlgebraParser.OintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_oint)
        try:
            self.state = 334
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 321
                self.oint()
                self.state = 322
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 323
                self.intv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 325
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 326
                self.oint()
                self.state = 327
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 328
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 330
                self.match(TransformationAlgebraParser.GROUPBY)
                self.state = 331
                self.match(TransformationAlgebraParser.AVG)
                self.state = 332
                self.ointo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 333
                self.oratio()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def GROUPBY(self):
            return self.getToken(TransformationAlgebraParser.GROUPBY, 0)

        def aggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.AggordContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oord

        def enterRule(self, listener):
            if hasattr(listener, "enterOord"):
                listener.enterOord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOord"):
                listener.exitOord(self)




    def oord(self):

        localctx = TransformationAlgebraParser.OordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_oord)
        try:
            self.state = 351
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 336
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 337
                self.oord()
                self.state = 338
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 339
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 341
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 342
                self.oord()
                self.state = 343
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 344
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 346
                self.match(TransformationAlgebraParser.GROUPBY)
                self.state = 347
                self.aggord()
                self.state = 348
                self.oordo()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 350
                self.oint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def oord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onom

        def enterRule(self, listener):
            if hasattr(listener, "enterOnom"):
                listener.enterOnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnom"):
                listener.exitOnom(self)




    def onom(self):

        localctx = TransformationAlgebraParser.OnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_onom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.oord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def oq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def onom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oq

        def enterRule(self, listener):
            if hasattr(listener, "enterOq"):
                listener.enterOq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOq"):
                listener.exitOq(self)




    def oq(self):

        localctx = TransformationAlgebraParser.OqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_oq)
        try:
            self.state = 366
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 355
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 356
                self.oq()
                self.state = 357
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 358
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 360
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 361
                self.oq()
                self.state = 362
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 363
                self.o()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 365
                self.onom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnom

        def enterRule(self, listener):
            if hasattr(listener, "enterLnom"):
                listener.enterLnom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnom"):
                listener.exitLnom(self)




    def lnom(self):

        localctx = TransformationAlgebraParser.LnomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_lnom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 368
            self.lord()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTERPOL(self):
            return self.getToken(TransformationAlgebraParser.INTERPOL, 0)

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def intv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.IntvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GROUPBY(self):
            return self.getToken(TransformationAlgebraParser.GROUPBY, 0)

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def lratio(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratioContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lint

        def enterRule(self, listener):
            if hasattr(listener, "enterLint"):
                listener.enterLint(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLint"):
                listener.exitLint(self)




    def lint(self):

        localctx = TransformationAlgebraParser.LintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_lint)
        try:
            self.state = 386
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.INTERPOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 370
                self.match(TransformationAlgebraParser.INTERPOL)
                self.state = 371
                self.sint()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 372
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 373
                self.lint()
                self.state = 374
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 375
                self.intv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 377
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 378
                self.lint()
                self.state = 379
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 380
                self.l()
                pass
            elif token in [TransformationAlgebraParser.GROUPBY]:
                self.enterOuterAlt(localctx, 4)
                self.state = 382
                self.match(TransformationAlgebraParser.GROUPBY)
                self.state = 383
                self.match(TransformationAlgebraParser.AVG)
                self.state = 384
                self.lintl()
                pass
            elif token in [TransformationAlgebraParser.DATAFIELD]:
                self.enterOuterAlt(localctx, 5)
                self.state = 385
                self.lratio()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def GROUPBY(self):
            return self.getToken(TransformationAlgebraParser.GROUPBY, 0)

        def aggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.AggordContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lord

        def enterRule(self, listener):
            if hasattr(listener, "enterLord"):
                listener.enterLord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLord"):
                listener.exitLord(self)




    def lord(self):

        localctx = TransformationAlgebraParser.LordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_lord)
        try:
            self.state = 403
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 388
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 389
                self.lord()
                self.state = 390
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 391
                self.ordv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 393
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 394
                self.lord()
                self.state = 395
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 396
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 398
                self.match(TransformationAlgebraParser.GROUPBY)
                self.state = 399
                self.aggord()
                self.state = 400
                self.lordl()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 402
                self.lint()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lq(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LqContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def qv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.QvContext,0)


        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def lnom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lq

        def enterRule(self, listener):
            if hasattr(listener, "enterLq"):
                listener.enterLq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLq"):
                listener.exitLq(self)




    def lq(self):

        localctx = TransformationAlgebraParser.LqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_lq)
        try:
            self.state = 416
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 405
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 406
                self.lq()
                self.state = 407
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 408
                self.qv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 410
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 411
                self.lq()
                self.state = 412
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 413
                self.l()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 415
                self.lnom()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def sint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SintContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sord

        def enterRule(self, listener):
            if hasattr(listener, "enterSord"):
                listener.enterSord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSord"):
                listener.exitSord(self)




    def sord(self):

        localctx = TransformationAlgebraParser.SordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_sord)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.sint()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SqContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.SqContext, self).__init__(parent, invokingState)
            self.parser = parser

        def snom(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.SnomContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_sq

        def enterRule(self, listener):
            if hasattr(listener, "enterSq"):
                listener.enterSq(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSq"):
                listener.exitSq(self)




    def sq(self):

        localctx = TransformationAlgebraParser.SqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_sq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 420
            self.snom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ODIST(self):
            return self.getToken(TransformationAlgebraParser.ODIST, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def NDIST(self):
            return self.getToken(TransformationAlgebraParser.NDIST, 0)

        def o(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OContext,i)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterOratioo"):
                listener.enterOratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOratioo"):
                listener.exitOratioo(self)




    def oratioo(self):

        localctx = TransformationAlgebraParser.OratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_oratioo)
        try:
            self.state = 434
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.ODIST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 422
                self.match(TransformationAlgebraParser.ODIST)
                self.state = 423
                self.os()
                self.state = 424
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 425
                self.os()
                pass
            elif token in [TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 427
                self.match(TransformationAlgebraParser.NDIST)
                self.state = 428
                self.o()
                self.state = 429
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 430
                self.o()
                self.state = 431
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 432
                self.oratioo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiolContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiolContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LDIST(self):
            return self.getToken(TransformationAlgebraParser.LDIST, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratiol

        def enterRule(self, listener):
            if hasattr(listener, "enterLratiol"):
                listener.enterLratiol(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratiol"):
                listener.exitLratiol(self)




    def lratiol(self):

        localctx = TransformationAlgebraParser.LratiolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_lratiol)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            self.match(TransformationAlgebraParser.LDIST)
            self.state = 437
            self.l()
            self.state = 438
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 439
            self.l()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LratiooContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LratiooContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LODIST(self):
            return self.getToken(TransformationAlgebraParser.LODIST, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def o(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lratioo

        def enterRule(self, listener):
            if hasattr(listener, "enterLratioo"):
                listener.enterLratioo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLratioo"):
                listener.exitLratioo(self)




    def lratioo(self):

        localctx = TransformationAlgebraParser.LratiooContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_lratioo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(TransformationAlgebraParser.LODIST)
            self.state = 442
            self.l()
            self.state = 443
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 444
            self.o()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def OTOPO(self):
            return self.getToken(TransformationAlgebraParser.OTOPO, 0)

        def os(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.OsContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,i)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_onomo

        def enterRule(self, listener):
            if hasattr(listener, "enterOnomo"):
                listener.enterOnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOnomo"):
                listener.exitOnomo(self)




    def onomo(self):

        localctx = TransformationAlgebraParser.OnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_onomo)
        try:
            self.state = 457
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.OTOPO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 446
                self.match(TransformationAlgebraParser.OTOPO)
                self.state = 447
                self.os()
                self.state = 448
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 449
                self.os()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 451
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 452
                self.onomo()
                self.state = 453
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 454
                self.nomv()
                pass
            elif token in [TransformationAlgebraParser.SIGMASE2, TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 456
                self.oordo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LOTOPO(self):
            return self.getToken(TransformationAlgebraParser.LOTOPO, 0)

        def l(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def os(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OsContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnomo

        def enterRule(self, listener):
            if hasattr(listener, "enterLnomo"):
                listener.enterLnomo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnomo"):
                listener.exitLnomo(self)




    def lnomo(self):

        localctx = TransformationAlgebraParser.LnomoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_lnomo)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            self.match(TransformationAlgebraParser.LOTOPO)
            self.state = 460
            self.l()
            self.state = 461
            self.match(TransformationAlgebraParser.WHITESPACE)
            self.state = 462
            self.os()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LintlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LintlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def lint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintContext,0)


        def lratiol(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LratiolContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lintl

        def enterRule(self, listener):
            if hasattr(listener, "enterLintl"):
                listener.enterLintl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLintl"):
                listener.exitLintl(self)




    def lintl(self):

        localctx = TransformationAlgebraParser.LintlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_lintl)
        try:
            self.state = 470
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 464
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 465
                self.lnoml()
                self.state = 466
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 467
                self.lint()
                pass
            elif token in [TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 469
                self.lratiol()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LordlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LordlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def lintl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LintlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lordl

        def enterRule(self, listener):
            if hasattr(listener, "enterLordl"):
                listener.enterLordl(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLordl"):
                listener.exitLordl(self)




    def lordl(self):

        localctx = TransformationAlgebraParser.LordlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_lordl)
        try:
            self.state = 478
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 472
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 473
                self.lordl()
                self.state = 474
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 475
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.LDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 477
                self.lintl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LnomlContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LnomlContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lnoml(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LnomlContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def nomv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.NomvContext,0)


        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def lordl(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LordlContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lnoml

        def enterRule(self, listener):
            if hasattr(listener, "enterLnoml"):
                listener.enterLnoml(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLnoml"):
                listener.exitLnoml(self)




    def lnoml(self):

        localctx = TransformationAlgebraParser.LnomlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_lnoml)
        try:
            self.state = 487
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 480
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 481
                self.lnoml()
                self.state = 482
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 483
                self.nomv()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 485
                self.lbooll()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 486
                self.lordl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LboollContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.LboollContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LVIS(self):
            return self.getToken(TransformationAlgebraParser.LVIS, 0)

        def l(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TransformationAlgebraParser.LContext)
            else:
                return self.getTypedRuleContext(TransformationAlgebraParser.LContext,i)


        def WHITESPACE(self, i=None):
            if i is None:
                return self.getTokens(TransformationAlgebraParser.WHITESPACE)
            else:
                return self.getToken(TransformationAlgebraParser.WHITESPACE, i)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def SIGMAE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMAE2, 0)

        def lbooll(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.LboollContext,0)


        def BOOLV(self):
            return self.getToken(TransformationAlgebraParser.BOOLV, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_lbooll

        def enterRule(self, listener):
            if hasattr(listener, "enterLbooll"):
                listener.enterLbooll(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLbooll"):
                listener.exitLbooll(self)




    def lbooll(self):

        localctx = TransformationAlgebraParser.LboollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_lbooll)
        try:
            self.state = 501
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.LVIS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 489
                self.match(TransformationAlgebraParser.LVIS)
                self.state = 490
                self.l()
                self.state = 491
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 492
                self.l()
                self.state = 493
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 494
                self.oint()
                pass
            elif token in [TransformationAlgebraParser.SIGMAE2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 496
                self.match(TransformationAlgebraParser.SIGMAE2)
                self.state = 497
                self.lbooll()
                self.state = 498
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 499
                self.match(TransformationAlgebraParser.BOOLV)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OordoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OordoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGMASE2(self):
            return self.getToken(TransformationAlgebraParser.SIGMASE2, 0)

        def oordo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OordoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def ordv(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OrdvContext,0)


        def ointo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintoContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_oordo

        def enterRule(self, listener):
            if hasattr(listener, "enterOordo"):
                listener.enterOordo(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOordo"):
                listener.exitOordo(self)




    def oordo(self):

        localctx = TransformationAlgebraParser.OordoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_oordo)
        try:
            self.state = 509
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.SIGMASE2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 503
                self.match(TransformationAlgebraParser.SIGMASE2)
                self.state = 504
                self.oordo()
                self.state = 505
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 506
                self.ordv()
                pass
            elif token in [TransformationAlgebraParser.BOWTIE, TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 508
                self.ointo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OintoContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.OintoContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOWTIE(self):
            return self.getToken(TransformationAlgebraParser.BOWTIE, 0)

        def onomo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OnomoContext,0)


        def WHITESPACE(self):
            return self.getToken(TransformationAlgebraParser.WHITESPACE, 0)

        def oint(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OintContext,0)


        def oratioo(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.OratiooContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_ointo

        def enterRule(self, listener):
            if hasattr(listener, "enterOinto"):
                listener.enterOinto(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOinto"):
                listener.exitOinto(self)




    def ointo(self):

        localctx = TransformationAlgebraParser.OintoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_ointo)
        try:
            self.state = 517
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.BOWTIE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 511
                self.match(TransformationAlgebraParser.BOWTIE)
                self.state = 512
                self.onomo()
                self.state = 513
                self.match(TransformationAlgebraParser.WHITESPACE)
                self.state = 514
                self.oint()
                pass
            elif token in [TransformationAlgebraParser.ODIST, TransformationAlgebraParser.NDIST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 516
                self.oratioo()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.AggContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AVG(self):
            return self.getToken(TransformationAlgebraParser.AVG, 0)

        def aggord(self):
            return self.getTypedRuleContext(TransformationAlgebraParser.AggordContext,0)


        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_agg

        def enterRule(self, listener):
            if hasattr(listener, "enterAgg"):
                listener.enterAgg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAgg"):
                listener.exitAgg(self)




    def agg(self):

        localctx = TransformationAlgebraParser.AggContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_agg)
        try:
            self.state = 521
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TransformationAlgebraParser.AVG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 519
                self.match(TransformationAlgebraParser.AVG)
                pass
            elif token in [TransformationAlgebraParser.MIN, TransformationAlgebraParser.MAX]:
                self.enterOuterAlt(localctx, 2)
                self.state = 520
                self.aggord()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggordContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TransformationAlgebraParser.AggordContext, self).__init__(parent, invokingState)
            self.parser = parser

        def MIN(self):
            return self.getToken(TransformationAlgebraParser.MIN, 0)

        def MAX(self):
            return self.getToken(TransformationAlgebraParser.MAX, 0)

        def getRuleIndex(self):
            return TransformationAlgebraParser.RULE_aggord

        def enterRule(self, listener):
            if hasattr(listener, "enterAggord"):
                listener.enterAggord(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAggord"):
                listener.exitAggord(self)




    def aggord(self):

        localctx = TransformationAlgebraParser.AggordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_aggord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 523
            _la = self._input.LA(1)
            if not(_la==TransformationAlgebraParser.MIN or _la==TransformationAlgebraParser.MAX):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





